<html>
<head>
<title>3DR</title>
<script src="../../code/FF.js"></script>
</head>
<script type="text/javascript">
function pageLoadedFxn(){
	var ff = new FF("../../code/",ffLoadedFxn);
}
function ffLoadedFxn(){
	(new ScriptLoader("./",["App3DR.js", "../SIFTDescriptor.js", "../R3D.js","../R3DDense.js","../R3DBA.js","../R3DDense.js","../Cam2D.js","../Cam3D.js","../Render3D.js","Stereopsis.js"],this,classesLoadedFxn)).load();
}
function classesLoadedFxn(){
/*
	// rotation averaging
	var matrix = new Matrix(4,4).identity();
	matrix = Matrix.transform3DRotateZ(matrix, Code.radians(45));
	matrix = Matrix.transform3DRotateX(matrix, Code.radians(15));
	matrix = Matrix.transform3DRotateY(matrix, Code.radians(-15));
	matrix = Matrix.transform3DRotateZ(matrix, Code.radians(-5));
	matrix = Matrix.transform3DRotateY(matrix, Code.radians(-10));
	matrix = Matrix.transform3DRotateX(matrix, Code.radians(-20));
	matrix = Matrix.transform3DTranslate(matrix, 1,2,3);
	console.log(matrix+"");
	var twist = Code.vectorTwistFromMatrix3D(matrix);
	console.log(twist);
	var angle = twist["angle"];
	var direction = twist["direction"];
	console.log(angle);
	console.log(direction);
	throw "?";
*/
/*
	var vectors = [];
		vectors.push(new V2D(1,0).rotate(Code.radians(10.0)));
		vectors.push(new V2D(1,0).rotate(Code.radians(20.0)));
		vectors.push(new V2D(1,0).rotate(Code.radians(-30.0)));
		// vectors.push(new V2D(1,0).rotate(Code.radians(-15.0)));
	var avg2 = Code.averageAngleVector2D(vectors);
	var angle = V2D.angleDirection(V2D.DIRX,avg2);
	console.log(avg2+"");
	console.log(Code.degrees(angle)+"");


	vectors = [];
		vectors.push(new V3D(1,0).rotate( new V3D(0,0,1), Code.radians(10.0)));
		vectors.push(new V3D(1,0).rotate( new V3D(0,0,1), Code.radians(20.0)));
		vectors.push(new V3D(1,0).rotate( new V3D(0,0,1), Code.radians(-30.0)));
		//console.log(vectors+"")
		// vectors.push(new V2D(1,0).rotate(Code.radians(-15.0)));
	var avg3 = Code.averageAngleVector3D(vectors);
	var angle = V2D.angleDirection(V3D.DIRX,avg3);
	console.log(avg3+"");
	console.log(Code.degrees(angle)+"");

	return;
*/
	// AVERAGING 2D POINTS ITERITIVELY
// 	var points = [];
// 		points.push(new V2D(0,0));
// 		points.push(new V2D(2,0));
// 		points.push(new V2D(1,3));
// 	var avg = V2D.meanFromArray(points);
// 	console.log(avg+"");
// 	var weight = 1;
// 	var total = points[0].copy();
// 	for(var i=1; i<points.length; ++i){
// 		var point = points[i];
// 		var dir = V2D.sub(point,total);
// 		weight += 1;
// 		total.add( dir.scale(1.0/weight) );
// 	}
// 	console.log(total+" ? ");
// return;

// AVERAGING 3D POINTS 

// STAGE:
// console.log("BeliefTest");
	this._canvas = new Canvas(null,0,0,Canvas.STAGE_FIT_FILL, false,false);
	this._stage = new Stage(this._canvas, 1000/20);
	this._root = new DO();
	this._stage.addChild(this._root);
	this._canvas.addListeners();
	this._stage.addListeners();
	this._stage.start();
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_CLICK,this.handleMouseClickFxn,this);
	GLOBALSTAGE = this._stage;

	
	var points = [];
		// points.push([new V2D(0,0), 0.0]);
		// points.push([new V2D(2,0), 0.0]);
		// points.push([new V2D(3,0), 0.0]);
		// points.push([new V2D(5,0), 0.0]);
		// points.push([new V2D(7,0), 0.0]);
		points.push([new V3D(0,0,0), Code.radians(0.0)]);
		points.push([new V3D(2,1,0), Code.radians(20.0)]);
		points.push([new V3D(3,0,0), Code.radians(30.0)]);
		points.push([new V3D(5,2,0), Code.radians(20.0)]);
		points.push([new V3D(7,0,0), Code.radians(40.0)]);
		points.push([new V3D(1,3,0), Code.radians(90.0)]);
	var edges = [];
		edges.push([0,1, 0.5]);
		edges.push([0,2, 0.5]);
			edges.push([0,3, 0.1]);
			edges.push([0,4, 0.5]);
			edges.push([0,5, 0.1]);
// edges.push([0,5, 0.5]);
// edges.push([0,5, 0.001]);
	
		edges.push([1,2, 0.5]);
		edges.push([1,3, 0.3]);
			edges.push([1,4, 0.2]);
			edges.push([1,5, 0.1]);

		edges.push([2,3, 0.5]);
			edges.push([2,4, 0.3]);
			edges.push([2,5, 0.2]);

		edges.push([3,4, 0.4]);
			edges.push([3,5, 0.5]);

		edges.push([4,5, 0.2]);

		

	var graph = new Graph();
	var vs = [];
	for(var i=0; i<points.length; ++i){
		var v = graph.addVertex();
		v.data([i,points[i],null, ]);
		vs[i] = v;
	}
	var es = [];
var relativeEdges = [];
var relativeLocations = [];
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var a = edge[0];
		var b = edge[1];
		var error = edge[2];
			error = error;
		var w = 1.0/Math.max(error,1E-6);
		var va = vs[a];
		var vb = vs[b];
		var pa = points[a][0];
		var pb = points[b][0];
		var ra = points[a][1];
		var rb = points[b][1];
		var e = graph.addEdge(va,vb, w, Graph.Edge.DIRECTION_DUPLEX);
		var vector = V3D.sub(pb,pa);
		var angle = Code.angleDirection(ra,rb);
var errorAngle = error * 3.0;
var errorLocation = error * 3.0;
// console.log("errorLocation: "+errorLocation);
// errorLocation *= 0.001;
		// var angle = Code.angleDifference(ra,rb);
		// console.log(Code.degrees(ra)+" & "+Code.degrees(rb)+" = "+Code.degrees(angle));
		var len = vector.length();
		len = 1.0;
		vector.add( Code.randomFloat(-errorLocation,errorLocation)*len, Code.randomFloat(-errorLocation,errorLocation)*len , Code.randomFloat(-errorLocation,errorLocation)*len*0 );
		angle += Code.randomFloat(-errorAngle,errorAngle)
		e.data([va,vb,vector,angle,error]);
		es[i] = e;
		//relativeEdges[i] = [a,b,angle,errorAngle];
			var twist = {"direction":new V3D(0,0,1),"angle":angle};
			relativeEdges[i] = [a,b,twist,errorAngle];
		relativeLocations[i] = [a,b,vector,errorLocation];
	}


	// initial estimation:
	var root = vs[0];
	var origin = new V3D(0,0,0);
	var locations = [];
	var rotations = [];
	locations.push(origin);
	rotations.push(0);
	for(var i=1; i<vs.length; ++i){
		var target = vs[i];
		var path = graph.minPath(root,target);
		var edges = path["edges"];
		var vertex = root;
		var location = origin.copy();
		var rotation = 0;
		var sigma = 0;
		for(var j=0; j<edges.length; ++j){
			var edge = edges[j];
			var data = edge.data();
			var va = data[0];
			var vb = data[1];
			var dir = data[2];
			var angle = data[3];
			var error = data[4];
			sigma = sigma + error;
			if(vb==vertex){ // invert direction
				angle = -angle;
				dir = dir.copy().scale(-1);
			}
			vertex = edge.opposite(vertex);
			location.add(dir);
			rotation += angle;
		}
		console.log("LOCATION: "+i+" = "+location+" @ "+Code.degrees(rotation));
		// console.log("LOCATION: "+i+" = "+location);
		rotation = Code.angleZeroTwoPi(rotation);
		locations.push(location);
		rotations.push(rotation);
		vertex.data()[2] = location;
		vertex.data()[3] = rotation;
	}

	var SCA = 100.0;
	var OFFX = 40;
	var OFFY = 60;
	// actual
	for(var i=0; i<locations.length; ++i){
		var location = points[i][0];
		var angle = points[i][1];
		var rad = 25.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFF004400);
			d.graphics().setFill(0x6600FF00);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			// d.graphics().fill();
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);
	}

	// estimated
	for(var i=0; i<locations.length; ++i){
		var location = locations[i];
		var angle = rotations[i];
		var rad = 28.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFFFF0000);
			d.graphics().setFill(0x66FF0000);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			// d.graphics().fill();
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);
	}


	var results = R3D.optiumGraphAngle2D(relativeEdges);
	console.log(results);
	rotations = results["absolute"];

	




	var results = R3D.optiumGraphLocation2D(relativeLocations);
	console.log(results);
	locations = results["absolute"];



	console.log("relativeLocations");
	console.log(relativeLocations);

	console.log("locations");
	console.log(locations);

	var result = R3D.optiumGraphLocation3D(relativeLocations);
	// var result = R3D.optimumGraphLocation3DLeastSquares(relativeLocations);
	console.log("result");
	console.log(result);
	locations = result["absolute"];
	console.log("locations");
	console.log(locations);


	var results = R3D.optiumGraphAngle3D(relativeEdges);
	console.log(results);
	rotations = results["absolute"];



	// SHOW AGAIN:
	for(var i=0; i<locations.length; ++i){
		var location = locations[i];
		var rot = rotations[i];
		console.log(rot);
		var angle = rot["angle"];
		var rad = 30.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFF0000CC);
			d.graphics().setFill(0x6600FF00);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			// d.graphics().fill();
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);

	}


// throw "TESTING";
// return;

	// paths = graph.minPath(vs[0],vs[3]);
	// console.log(paths);

	/*
		graph use squared error as edge weights
		
		find root with minimized total error at leaves
			- get shortest paths to all vertexes & sum all paths

????
		
		calculate absolute positions from root
		
		iterate till convergence: (GD)
			relative = edge_ab
			calculated = (absB-absA) [inverse]
			
			error_t = distance from centers
			
			error_r = angle ?



			error += ^2 * sigma
			=> update absolute positions

		
	*/


	// var vertexes = [];
	// for(var i=0; i<4; ++i){
	// 	var v = graph.addVertex();
	// 	vertexes[i] = v;
	// }
	// var a = vertexes[0];
	// var b = vertexes[1];
	// var c = vertexes[2];
	// var d = vertexes[3];
	// a.data("A");
	// b.data("B");
	// c.data("C");
	// d.data("D");
	// var ab = graph.addEdge(a,b, 1, Graph.Edge.DIRECTION_DUPLEX);
	// var bc = graph.addEdge(a,b, 1, Graph.Edge.DIRECTION_DUPLEX);
	// var bd = graph.addEdge(a,b, 1, Graph.Edge.DIRECTION_DUPLEX);
	// var ab = graph.addEdge(a,b, 1, Graph.Edge.DIRECTION_DUPLEX);
	// 	ab.data(new V2D(2,0));
	// 	bc.data(new V2D(1,0));
	// 	bd.data(new V2D(1,0));
	// 	cd.data(new V2D(1,0));

/*
	error:
		| relAB - (absA-absB) |^2
*/

	// return;

/*
	var imageWidth = 500;
	var imageHeight = 350;
	var f = (imageWidth+imageHeight)*0.5;
	var fx = f;
	var fy = f;
	var s = 0;
	var cx = 0.5*imageWidth;
	var cy = 0.5*imageHeight;
	var distortion = null;
	var K = new Matrix(3,3).fromArray([fx,s,cx, 0,fy,cy, 0,0,1]);
	var Kinv = Matrix.inverse(K);
	var identity = new Matrix(4,4).identity();

	// actual point movement
		var mat = new Matrix(4,4).identity();
		mat = Matrix.transform3DTranslate(mat, -1,0,0);
			mat = Matrix.transform3DRotateY(mat, Code.radians(-10.0));
	var absA = mat;
	
		var mat = new Matrix(4,4).identity();
			mat = Matrix.transform3DTranslate(mat, 1,0,0);
			mat = Matrix.transform3DRotateY(mat, Code.radians(10.0));
	var absB = mat;

	// actual camera movement
	var invA = Matrix.inverse(absA);
	var invB = Matrix.inverse(absB);

	// point movement
	var transAB = Matrix.mult(absB,invA);
	// camera movement
	var transBA = Matrix.inverse(transAB);

	var Fab = R3D.fundamentalFromCamera(transAB, K, Kinv);
	var Fba = R3D.fundamentalInverse(Fab);//R3D.fundamentalFromCamera(transBA, K, Kinv);
	
	var point3D = new V3D(1,1,-20);

	var point2DA = R3D.projectPoint3DToCamera2DForward(point3D, absA, K, null);
	var point2DB = R3D.projectPoint3DToCamera2DForward(point3D, absB, K, null);

	// ORIGINAL:
	//var estimated3D = R3D.triangulatePointDLT(point2DA,point2DB, absA,absB, Kinv, Kinv);

	// REPLACE
	var estimated3D = R3D.triangulatePointDLT(point2DA,point2DB, identity,transAB, Kinv, Kinv);

var error = R3D.reprojectionError(estimated3D, point2DA,point2DB, identity, transAB, K, K);
console.log("reprojection error: "+error["error"]);

		invA.multV3DtoV3D(estimated3D,estimated3D);

	// NOT WORK:
	// var estimated3D = R3D.triangulatePointDLT(point2DA,point2DB, identity,transBA, Kinv, Kinv);
	// 	absA.multV3DtoV3D(estimated3D,estimated3D);


			//transAB.multV3DtoV3D(estimated3D,estimated3D);

	console.log("          ..."+estimated3D+" =?= "+point3D);


	

	
	// var rayA = R3D.projectPoint2DToCamera3DRay(point2DA, absA, Kinv, null);
	// var rayB = R3D.projectPoint2DToCamera3DRay(point2DB, absB, Kinv, null);
	var rayA = R3D.projectPoint2DToCamera3DRay(point2DA, invA, Kinv, null);
	var rayB = R3D.projectPoint2DToCamera3DRay(point2DB, invB, Kinv, null);

	var closest = Code.closestPointsLines3D(rayA["o"],rayA["d"], rayB["o"],rayB["d"]);
	var avg = V3D.avg(closest[0],closest[1]);
	console.log(avg+"");
	// console.log(avg.x/point3D.x,avg.y/point3D.y,avg.z/point3D.z);

console.log(Kinv+"")

var distance3D = V3D.distance(estimated3D,point3D);
console.log("distance3D: "+distance3D);
if(distance3D>1E-6){
	console.log(closest)
	console.log(" point2DA: "+point2DA);
	console.log(" point2DB: "+point2DB);
	console.log(" point3D: "+point3D);
	console.log(" estimated3D: "+estimated3D);

	throw "not match";
}




// NONLINEAR OPTIMIZING:
	points3D = [];
	points3D.push(new V3D(0,0,10));

	points3D.push(new V3D(0,-1,7));
	points3D.push(new V3D(-1,0,7));
	points3D.push(new V3D(-1,-1,7));
	
	points3D.push(new V3D(0,-10,10));
	points3D.push(new V3D(-10,0,10));
	points3D.push(new V3D(-10,-10,10));

	points3D.push(new V3D(1,0,12));
	points3D.push(new V3D(0,1,12));
	points3D.push(new V3D(1,1,12));

	points3D.push(new V3D(0,10,11));
	points3D.push(new V3D(10,0,11));
	points3D.push(new V3D(10,10,11));

	// var errorPixels = 2;
	var errorPixels = 1;
	// var errorPixels = 0;
	// var badCount = 0;
	// var badCount = 1;
	var badCount = Math.floor(points3D.length*0.5);


console.log("nonlinearness");
	cameras = [absA,absB];
	points2DA = [];
	points2DB = [];
	points2D = [points2DA,points2DB];
	for(var i=0; i<points3D.length; ++i){
		var point3D = points3D[i];
		var list = [];
		for(var j=0; j<cameras.length; ++j){
			var camAbs = cameras[j];
			var point2D = R3D.projectPoint3DToCamera2DForward(point3D, camAbs, K, null, true);
			console.log(i+" "+point2D);
			points2D[j].push(point2D);
			// console.log(points2D[j])
			if(point2D){
				point2D.add(Math.random()*errorPixels,Math.random()*errorPixels);
				// list.push(point2D);
			}
			list.push(point2D);
		}
	}
	console.log("MATCHES BEFORE: "+points2DA.length);
	// add bad points:
	for(var i=0; i<badCount; ++i){
		for(var j=0; j<cameras.length; ++j){
			points2D[j].push(new V2D(Math.random()*imageWidth,Math.random()*imageHeight) );
		}
	}
	console.log("MATCHES ERROR: "+points2DA.length);

	

	var F = null;
	var P = null;
	var Ka = K;
	var Kb = K;
	var KaInv = Matrix.inverse(Ka);
	var KbInv = Matrix.inverse(Kb);

	
	// TODO: WHERE DOES TRHESHOLD ERROR COME FROM ?


	var inlierPixelError = 2;
	var result = R3D.fundamentalRANSACFromPoints(points2DA,points2DB, inlierPixelError);
	// console.log(result);
	F = result["F"];
	console.log(F+"");

	var matches = result["matches"];
	points2DA = matches[0];
	points2DB = matches[1];
	console.log("MATCHES AFTER: "+points2DA.length);
	//F = R3D.fundamentalFromUnnormalized(points2DA,points2DB);
	
	// F = R3D.fundamentalMatrixNonlinear(F,points2DA,points2DB);
	// console.log(F+"");

	// TODO: RANSAC P drop points

	//P = R3D.transformFromFundamental(points2DA,points2DB, F, Ka, Kb, null, true);

	// TODO: WHERE DOES TRHESHOLD ERROR COME FROM ?
	result = R3D.cameraExtrinsicRANSACFromPointsAutomated(points2DA,points2DB,Ka,Kb,KaInv,KbInv);

	P = result["P"];
	console.log(P+"");


	console.log(P);

throw "yerp"

	var Pa = new Matrix(4,4).identity();
	var Pb = P;

	// NONLINEAR OPTIMIZING:
		var Ps = [Pa,Pb];
		var Ks = [Ka,Kb];
		var Is = [KaInv,KbInv];
		var points2D = [points2DA,points2DB];

		// TODO:
		var estimated3D = [];
		for(i=0; i<points2DA.length; ++i){
			var pA = points2DA[i];
			var pB = points2DB[i];
			var p3D = R3D.triangulatePointDLT(pA,pB, Pa,Pb, KaInv, KbInv);
			estimated3D.push(p3D);
		}
		// // points3D =  estimated
		// var estimated3D = R3D.triangulatePointDLT(pA,pB, cameraA,cameraB, KaInv, KbInv);
		// match.estimated3D(estimated3D);


		var result = R3D.BundleAdjustCameraExtrinsic(Ks, Is, Ps, points2D, estimated3D, 25);
		console.log(result);
		var extrinsics = result["extrinsics"];
		var absA = extrinsics[0];
		var absB = extrinsics[1];
		
		// var invA = Matrix.inverse(absA);
		// var relativeAtoB = Matrix.mult(invA,absB);
		// var absoluteB = Matrix.mult(Pa,relativeAtoB);
		// viewB.absoluteTransform(absoluteB);


	return;

*/


	/*
	console.log("test combining");


	var viewA = new Matrix(4,4).identity();
		viewA = Matrix.transform3DTranslate(viewA, 1,1,1);

	var viewB = new Matrix(4,4).identity();
		viewB = Matrix.transform3DTranslate(viewB, 1,2,3);
		viewB = Matrix.transform3DRotateY(viewB, Code.radians(30.0));
		viewB = Matrix.transform3DRotateX(viewB, Code.radians(15.0));

	var viewC = new Matrix(4,4).identity();
		viewC = Matrix.transform3DTranslate(viewC, -2,-2,-2);
		viewC = Matrix.transform3DRotateY(viewC, Code.radians(10.0));
		viewC = Matrix.transform3DRotateX(viewC, Code.radians(-10.0));

	var invA = Matrix.inverse(viewA);
	var invB = Matrix.inverse(viewB);
	var invC = Matrix.inverse(viewC);
	// var transformAB = Matrix.mult(invA,viewC);
	// var transformAC = Matrix.mult(invA,viewB);
	// var transformBC = Matrix.mult(invB,viewC);
	var transformAB = Matrix.mult(viewB,invA);
	var transformAC = Matrix.mult(viewC,invA);
	var transformBC = Matrix.mult(viewC,invB);
	
	// ?

	var point1 = new V3D(0,0,0);

	var point1A = invA.multV3DtoV3D(point1);
	var point1B = invB.multV3DtoV3D(point1);
	var point1C = invC.multV3DtoV3D(point1);

	console.log(" POINT IN RESPECTIVE FRAMES OF REFERENCE: inv_i(p_abs) = p_i");
	console.log("point1: "+point1);
	console.log("point1A: "+point1A);
	console.log("point1B: "+point1B);
	console.log("point1C: "+point1C);
	console.log("...............................");


	var point2 = new V3D(0,0,0);
	var point2A = viewA.multV3DtoV3D(point2);
	var point2B = viewB.multV3DtoV3D(point2);
	var point2C = viewC.multV3DtoV3D(point2);


	console.log(" POINT IN ABSOLUTE FRAME OF REFERENCE: fwd_i(p_i) = p_abs");
	console.log("point2: "+point2);
	console.log("point2A: "+point2A);
	console.log("point2B: "+point2B);
	console.log("point2C: "+point2C);
	console.log("...............................");

	var point3 = new V3D(0,0,0);

	var point3A = viewA.multV3DtoV3D(point3);
		point3A_AB = transformAB.multV3DtoV3D(point3A);
		point3A_AC = transformAC.multV3DtoV3D(point3A);
	var point3B = viewB.multV3DtoV3D(point3);
		point3B_BC = transformBC.multV3DtoV3D(point3B);
	
	console.log(" POINTS VIA RELATIVE PATHS:");
	console.log("point3: "+point3);
	console.log("point3A: "+point3A);
	console.log("point3A_AB: (B) "+point3A_AB);
	console.log("point3A: "+point3A);
	console.log("point3A_AC: (C) "+point3A_AC);
	console.log("point3B: "+point3B);
	console.log("point3B_BC: (C) "+point3B_BC);

	console.log("...............................");


	//console.log("point1AB: "+point1AB);


	return;
	*/


	/*
	var handleEnterFrameFxn = function(e){
		// console.log(e)
	}

	var canvas = new Canvas(null,0,0,Canvas.STAGE_FIT_FILL, false,false, true);
	var stage = new Stage(canvas, 1000/20);
	var root = new DO();
	stage.addChild(root);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_CLICK,this._handleMouseClickFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_DOWN,this._handleMouseDownFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_UP,this._handleMouseUpFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_EXIT,this._handleMouseUpFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_MOVE,this._handleMouseMoveFxn,this);

	//this._canvas.addFunction(Canvas.EVENT_MOUSE_CLICK,this._handleMouseClickFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_TOUCH_START,this._handleMouseDownFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_TOUCH_END,this._handleMouseUpFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_TOUCH_MOVE,this._handleMouseMoveFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_WINDOW_RESIZE,this._handleCanvasResizeFxn,this);
	stage.addFunction(Stage.EVENT_ON_ENTER_FRAME,handleEnterFrameFxn,this);
	canvas.addListeners();
	stage.addListeners();
	stage.start();

	var renderer = new Render3D(new V2D(600,400));
	var cam3D = renderer.addCamera();
	root.addChild(renderer.display());
	
	var points = [];
	var s = 1;
	for(var i=0; i<100; ++i){
		var p = new V3D(Math.random()*s,Math.random()*s,Math.random()*s);
		points.push(p);
	}

	var info = V3D.infoFromArray(points);
	cam3D.position();
	cam3D.position();

	renderer.clear();
	renderer.renderPoints(points);


	return;
	*/
/*
	var angleX = Math.random()*Math.PI2;
	var angleY = Math.random()*Math.PI2;
	var angleZ = Math.random()*Math.PI2;
	// 
	var R, Q, transform;
	transform = new Matrix(4,4).identity();
	transform = Matrix.transform3DRotateX(transform, angleX);
	transform = Matrix.transform3DRotateY(transform, angleY);
	transform = Matrix.transform3DRotateZ(transform, angleZ);
	R = transform.getSubMatrix(0,0, 3,3);
	R = R3D.rotationFromApproximate(R);
	
	var rodrigues = R3D.rotationMatrixToEulerRodriguez(R);
	var transform = R3D.rotationEulerRodriguezToMatrix(rodrigues);
	var Q = transform.getSubMatrix(0,0, 3,3);
	var D = Matrix.sub(R,Q);
		D = Matrix.abs(D);
	console.log(R+"");
	console.log(Q+"");
	console.log(D+"");

	return;
*/


	/*
	var g = new Graph();
	var v = [];

	//for(var i=0; i<10; ++i){
	for(var i=0; i<7; ++i){
		var u = g.addVertex();
		v[i] = u;
	}
	g.addEdgeDuplex(v[0],v[1], 1); // 0
	g.addEdgeDuplex(v[0],v[6], 4); // 1
	g.addEdgeDuplex(v[1],v[2], 2); // 2
	g.addEdgeDuplex(v[1],v[3], 3); // 3
//g.addEdgeDuplex(v[2],v[5], 0); // TEST
	g.addEdgeDuplex(v[3],v[4], 1); // 4
	g.addEdgeDuplex(v[4],v[5], 1); // 5
	g.addEdgeDuplex(v[5],v[6], 2); // 6
	// g.addEdgeDuplex(v[7],v[8], 1); // 7
	// g.addEdgeDuplex(v[8],v[9], 2); // 8
	// g.addEdgeDuplex(v[],v[], );

	var sets = Graph._disjointSets(g);
	console.log(sets);

	var set = sets[0];

	var paths = Graph._minPaths(g, v[0]);
	
	console.log(paths);

	for(i=0; i<paths.length; ++i){
		var path = paths[i];
		var vertex = path["vertex"];
		var cost = path["cost"];
		var path = path["path"];
		console.log(vertex+" = "+cost+" @ len: "+path.length);
	}


	var minRoot = Graph._minRootPaths(g);
	console.log(minRoot);


	return;
	*/
	/*
	var t = new Tensor([3,3,3]);
	console.log(t);
	console.log(t+"");
	console.log("FR ");
	var a = [];
	for(var i=0; i<27; ++i){
		a[i] = i;
	}
	t.fromArray(a);
	console.log("TO ");
	console.log(t.toArray());
	console.log("GET ");
	console.log(t.get([0,1,2]));

	console.log("SET ");
	console.log(t.set([0,1,2], 99));

	console.log("SET ");
	console.log(t.set([2,2,2], 0));

	console.log("TO ");
	console.log(t.toArray());
	return;
	*/
/*
	var pointsA = [
				new V2D(86,208), // glasses corner left
				new V2D(190,180), // glasses corner right
				new V2D(172,107), // origin
				new V2D(22.5,166), // lighter button
				new V2D(361,183), // mouse eye
				new V2D(18,225), // bic corner left
				new V2D(37,216), // bic corner right
				new V2D(65,169), // cup 
				new V2D(226,87), // face BL
				new V2D(219,66), // glasses TL
				new V2D(250,72), // glasses TR
				new V2D(260,103), // elbow
				new V2D(216,154), // toe left
				new V2D(245,158), // toe right
				new V2D(202,127), // brick
				new V2D(240,248), // 12
				new V2D(332,249), // 16
				new V2D(145,203), // glasses center
				new V2D(172,68), // grid top
				new V2D(141,76), // grid TL
				new V2D(204,75), // grid TR
				new V2D(144,119), // grid BL
				new V2D(175,128), // grid bot
				new V2D(362,213), // U
				new V2D(326,176), // tail
				new V2D(190,173), // base left
				new V2D(265,178), // base right
				new V2D(372,181), // nose
				new V2D(129,88), // power top
				new V2D(132,141), // power bot
				new V2D(62,107), // cup
				new V2D(94,176), // glass tip left
				new V2D(131,166), // glass tip right
			];
var pointsB = [
				new V2D(87,192),
				new V2D(170,178),
				new V2D(212,46),
				new V2D(50,149),
				new V2D(278,241),
				new V2D(52,179), // left
				new V2D(64,172), // right//new V2D(18,225), // right
				new V2D(94,124), 
				new V2D(225,98), // face BL
				new V2D(221,80), // glasses TL
				new V2D(246,95), // glasses TR
				new V2D(250,121),
				new V2D(214,139), // tow left
				new V2D(237,150), // toe right
				new V2D(213,106), // brick
				new V2D(180,252), // 12
				new V2D(245,271), // 16
				new V2D(131,193), // glasses center
				new V2D(213,12), // grid top
				new V2D(177,26), // grid TL
				new V2D(239,33), // grid TR
				new V2D(180,61), // grid BL
				new V2D(202,83), // grid bot
				new V2D(282,251), // U
				new V2D(256,225), // tail
				new V2D(187,153), // base left
				new V2D(245,173), // base right
				new V2D(290,240), // nose
				new V2D(150,63), // power top
				new V2D(155,100), // power bot
				new V2D(85,92), // cup
				new V2D(113,138), // glass tip left
				new V2D(145,132), // glass tip right
			];
var pointsAin = pointsA;
var pointsBin = pointsB;

	var pointsA = [];
	var pointsB = [];
	for(i=0; i<pointsAin.length; ++i){
		pointsA[i] = new V3D(pointsAin[i].x,pointsAin[i].y,1.0);
		pointsB[i] = new V3D(pointsBin[i].x,pointsBin[i].y,1.0);
	}
	
	var pointsANorm = R3D.calculateNormalizedPoints([pointsA]);
	var pointsBNorm = R3D.calculateNormalizedPoints([pointsB]);
	var pA = pointsANorm.normalized[0];
	var pB = pointsBNorm.normalized[0];

	

	var Fnrm = R3D.fundamentalMatrix(pA,pB);
	var Floc = Fnrm.copy();
	Floc = Matrix.mult(Floc, pointsANorm.forward[0]);
	Floc = Matrix.mult(Matrix.transpose(pointsBNorm.forward[0]), Floc);

	console.log(Floc+"");


	var error = R3D._gdFun([pointsA,pointsB], Floc.toArray(), false);
	var averageError = error/pointsA.length;
	console.log("1 F AVG ERROR: "+error+" == "+averageError);
var errorA = averageError;


	
	
	var Fnext = Fnrm;
	//var Fnext = R3D.fundamentalMatrixNonlinearGD(Fnrm, pA, pB);
	//Fnext = R3D.forceRank2F(Fnext);

	for(i=0; i<3; ++i){
		//console.log("LM");
		Fnext = R3D.fundamentalMatrixNonlinearLM(Fnext, pA, pB);
		//console.log("GD");
		Fnext = R3D.fundamentalMatrixNonlinearGD(Fnext, pA, pB);
	}

//	Fnext = R3D.fundamentalMatrixNonlinearGD(Fnext, pA, pB);
// }catch(e){
// 	console.log("??? "+e);
// }
	//Fnext = R3D.forceRank2F(Fnext);

	// GD: 0.8771833241544938
	// LM: 0.9928658790461447
	// GD+LM: 0.87718
	// LM+GD: 0.876840
	// 2x.  : 0.8727416521415238
	// 10x. : 0.871342
	// 0.8702023724746977
	//Fnext = R3D.forceRank2F(Fnext);
	//  0.8711342044146368
	Floc = Fnext.copy();
	Floc = Matrix.mult(Floc, pointsANorm.forward[0]);
	Floc = Matrix.mult(Matrix.transpose(pointsBNorm.forward[0]), Floc);
	console.log(Floc+"");




	var error = R3D._gdFun([pointsA,pointsB], Floc.toArray(), false);
	var averageError = error/pointsA.length;
	console.log("2 F AVG ERROR: "+error+" == "+averageError);
var errorB = averageError;
	
	console.log(" DELTA ERROR: "+(errorB/errorA));
	return;
*/


/*
	console.log(Code.appendToPath("a","b","c") );
	console.log(Code.appendToPath("a","b") );
	console.log(Code.appendToPath("/","a") );
	console.log(Code.appendToPath("/","a/") );
	console.log(Code.appendToPath("/","/a/","/b/") );
	return;
*/
	//var client = new ClientFile();
	// http://localhost/ff/3DR/app/app.html
	/*
	var text = "test string to save\nto a file";
	var binary = Code.stringToBinary(text);
	console.log(text);
	console.log(binary);
	client.set("test.txt", binary);
	return;
	*/



// var client = new ClientFile();
// 	client.del("projects/0/MZT6OFNF/50.png");
// 	return;
	// var client = new ClientFile();
	// client.set("projects/0");
	// return;
	

// 	client.get("projects/test1.png");
// return;
	//client.get("images/background.php");
	//client.get("test.png");
	//client.get("test3.png");
	//client.get("test5.png");
	//client.get("/");
/*
	var base64 = "iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAaElEQVR4nO3VMQqAQBAEwVnx/18+c9esQSboDpcLCkFmkpy8OmedMjPr9se7a13KEkirB95NP8TXu/ovKJBWD5y4JCyBtHqgS0ITSKsHuiQ0gbR6oEtCE0irB7okNIG0eqBLQhNIqwc+4L9kRXekVq0AAAAASUVORK5CYII=";
	console.log(base64);
	var binary = Code.base64StringToBinary(base64);
	//console.log(binary);
	console.log(binary);
	console.log(Code.binaryToBase64String(binary));

	//client.set("upload.png",binary);
	//client.set("projects");
	client.set("projects/test1.png", binary);
*/
	//client.del("projects/test1.png");
	//client.del("/projects");

//	return;
/*
	var pointsA = [];
	var pointsB = [];
	for(var i=0; i<3; ++i){
		var p = new V2D( Code.randomFloat(-1,1), Code.randomFloat(-1,1) );
		pointsA.push(p);
		var p = new V2D( Code.randomFloat(-1,1), Code.randomFloat(-1,1) );
		pointsB.push(p);
	}
	
	var pointsA = [new V2D( 2, 3),new V2D(6,4),new V2D(3,6)];
	//var pointsB = [new V2D(-1,-1),new V2D(1,0),new V2D(2,3)];
	var pointsB = [new V2D(-1,-1),new V2D(1,0),new V2D(2,-3)];
	
	var m = R3D.affineMatrixExact(pointsA,pointsB);
	var n = R3D.affineMatrixExact(pointsB,pointsA);

	var pointsC = [];
	var pointsD = [];
	for(var i=0; i<pointsA.length; ++i){
		var pA = pointsA[i];
		var pB = pointsB[i];
		var pC = m.multV2DtoV2D(new V2D(), pA);
		var pD = n.multV2DtoV2D(new V2D(), pB);
		if(false){
		if(i==0){
			pA = new V2D(0,0);
			pB = pA;
		}else if(i==1){
			pA = new V2D(1,0);
			pB = pA;
		}else if(i==2){
			pA = new V2D(0,1);
			pB = pA;
		}
		}
		var diffA = V2D.distance(pA,pD);
		var diffB = V2D.distance(pB,pC);
		pointsC.push(pC);
		pointsD.push(pD);
		console.log(diffA+" | "+diffB);
	}
	console.log("A: "+pointsA+"");
	console.log("B: "+pointsB+"");
	console.log("C: "+pointsC+"");
	console.log("D: "+pointsD+"");

	return;
*/

	
	var app = new App3DR();
}
</script>
<body onload="pageLoadedFxn();" style="padding:0; margin:0; border:0;">
</body>
</html>
