<html>
<head>
<title>3DR</title>
<script src="../../code/FF.js"></script>
</head>
<script type="text/javascript">
function pageLoadedFxn(){
	var ff = new FF("../../code/",ffLoadedFxn);
}
function ffLoadedFxn(){
	(new ScriptLoader("./",["App3DR.js", "../SIFTDescriptor.js", "../R3D.js","../R3DDense.js","../R3DBA.js","../R3DDense.js","../Cam2D.js","../Cam3D.js","../Render3D.js","Stereopsis.js"],this,classesLoadedFxn)).load();
}
function checksFxn(offsets, twists, matrices, reference){
// reference = Matrix.inverse(reference);
	var edgesTranslate = [];
	for(var i=0; i<offsets.length; ++i){
		var offset = offsets[i];
		var indexA = offset["A"];
		var indexB = offset["B"];
		var translation = offset["translation"];
		// console.log(" "+i+" = "+translation+"");
		var error = offset["error"];
		edgesTranslate.push([indexA,indexB, translation, error]);
	}

	var edgesRotate = [];
	for(var i=0; i<twists.length; ++i){
		var twist = twists[i];
		var indexA = twist["A"];
		var indexB = twist["B"];
		var rotation = twist["rotation"];
		// console.log(" "+i,rotation);
		var error = offset["error"];
		edgesRotate.push([indexA,indexB, rotation, error]);
	}

	// USE MATRICES:
	for(var i=0; i<matrices.length; ++i){
		var matrixInfo = matrices[i];
		var indexA = matrixInfo["A"];
		var indexB = matrixInfo["B"];
		var matrix = matrixInfo["relative"];
		var error = matrixInfo["error"];
		var twist = Code.vectorTwistFromMatrix3D(matrix);
		// throw twist;
		var rotation = twist;
		var translation = twist["offset"];
		//
		edgesTranslate[i] = [indexA,indexB, translation, error];
		edgesRotate[i] = [indexA,indexB, rotation, error];
	}
	//
	// edgesRotate.push([indexA,indexB, {"direction":dir, "angle":angle}, error]);
	// console.log(edgesTranslate);
	// console.log(edgesRotate);
	// solve optimum position + orientation
	var result = R3D.optiumGraphLocation3D(edgesTranslate);
	// console.log(result)
	var locations = result["absolute"];
	for(var i=0; i<locations.length; ++i){
		var loc = locations[i];
	console.log(" "+i+" = "+loc+"");
loc = loc.copy();
// loc.x += 0;
// loc.y += 0;
// loc.z += 5;
		var d = new DO();
		d.graphics().setLine(1.0,0xFF0000FF);
		d.graphics().beginPath();
		d.graphics().drawCircle(0,0, 7);
		d.graphics().endPath();
		d.graphics().strokeLine();
		d.matrix().translate(OFFSET.x,OFFSET.y);
		d.matrix().translate(SCALE*loc.x,SCALE*loc.z);
		GLOBALSTAGE.addChild(d);
		// console.log(d)
	// console.log(" "+i+" = "+V3D.add(locations[i], new V3D(0,0,5))+"");
	// locations[i].scale(-1);
	}
	var result = R3D.optiumGraphAngle3D(edgesRotate);
	var rotations = result["absolute"];
	for(var i=0; i<rotations.length; ++i){
		// console.log(rotations[i]);
		var direction = rotations[i]["direction"];
		// var angle = V3D.angle(V3D.DIRZ,direction);
		var angle = V3D.angle(V3D.DIRZ,direction);
			// angle += Math.PI;
		// console.log(" "+i+" = "+Code.degrees(angle)+"");
		// console.log(" "+i+" = "+rotations[i]+"");
		// console.log(" "+i+" = "+V3D.add(locations[i], new V3D(0,0,5))+"");
	}
	// console.log(rotations);
	// // turn twists into transforms
	var transforms = [];
	for(var i=0; i<locations.length; ++i){
	var location = locations[i];
		// location = location["translation"];
	var rotation = rotations[i];
	// pre unmultiply location?
			// ?
			// location.scale(-1);
	// POSE
	var transform = Code.Matrix3DFromVectorTwist(location, rotation);
	// console.log(transform);
	// Matrix3DFromVectorTwist
	// var transform = Code.Matrix3DFromVectorTwist(location, rotation);
	// EXTRINSIC
	var extrinsic = Matrix.inverse(transform);
	// var extrinsic = transform;
	// OFFSET
		// transform = Matrix.mult(reference,extrinsic);
		transform = Matrix.mult(extrinsic,reference);
	console.log(" "+i+": ");
	console.log(transform+"");
	transforms[i] = transform;

		drawCameraFromExtrinsic(transform, 0xFF009900);
	}
	// return {"absolute":transforms};
	throw "?";
}
function defineVars(){
	SCALE = 50.0;
	OFFSET = new V2D(150,150);
}
function drawWorldOrigin(){
	var scale = SCALE;
	var offset = OFFSET;

	var d = new DO();
	d.graphics().setLine(1.0,0xFF000000);
	d.graphics().beginPath();
	d.graphics().moveTo(-15,0);
	d.graphics().lineTo(15,0);
	d.graphics().moveTo(0,-15);
	d.graphics().lineTo(0,15);
	d.graphics().endPath();
	d.graphics().strokeLine();
	GLOBALSTAGE.addChild(d);
	d.matrix().translate(offset.x,offset.y);

}
function drawCameraFromExtrinsic(transform, color){
	color = color!==undefined ? color : 0xFFFF0000;
	var scale = SCALE;
	var offset = OFFSET;

	var inverse = Matrix.inverse(transform);

	var matrix = inverse;
	var center = matrix.multV3DtoV3D(new V3D(0,0,0));
console.log("CANERA CENTER: "+center);
	var direction = matrix.multV3DtoV3D(new V3D(0,0,1));
	// var angle = 0;
	var angle = V3D.angle(V3D.DIRZ,direction);
	// angle += -Math.PI*0.5; // start at +Z
	// var angle = V3D.angle(new V3D(0,0,-1),direction);

	var d = new DO();
	d.graphics().setLine(1.0,color);
	d.graphics().beginPath();
	d.graphics().drawPolygon([new V2D(0,0), new V2D(10,15), new V2D(-10,15)]);
	d.graphics().endPath();
	d.graphics().strokeLine();

	d.graphics().setLine(null);
	d.graphics().setFill(0xFFFF00FF);
	d.graphics().beginPath();
	d.graphics().drawCircle(0,0, 5);
	d.graphics().endPath();
	d.graphics().fill();
	d.graphics().strokeLine();

	d.matrix().rotate(angle);
	d.matrix().translate(center.x*scale,center.z*scale);
	d.matrix().translate(offset.x,offset.y);
	GLOBALSTAGE.addChild(d);
}
function classesLoadedFxn2(){

	// GLOBAL STAGE:
	// AVERAGING 3D POINTS
	this._canvas = new Canvas(null,0,0,Canvas.STAGE_FIT_FILL, false,false);
	this._stage = new Stage(this._canvas, 1000/20);
	this._root = new DO();
	this._stage.addChild(this._root);
	this._canvas.addListeners();
	this._stage.addListeners();
	this._stage.start();
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_CLICK,this.handleMouseClickFxn,this);
	GLOBALSTAGE = this._stage;

		defineVars();


	var matrix = null;
	var transforms = [];
	var errorAbs = [];
	var errorRel = [];
		// A
		matrix = new Matrix(4,4).identity();
		matrix = Matrix.transform3DRotateX(matrix, Code.radians(5.0));
		matrix = Matrix.transform3DRotateZ(matrix, Code.radians(10.0));
		matrix = Matrix.transform3DTranslate(matrix, 0,0,5);
		matrix = Matrix.transform3DRotateY(matrix, Code.radians(0.0));
		transforms.push(matrix);
		errorAbs.push(0.0);
		// B
		matrix = new Matrix(4,4).identity();
		matrix = Matrix.transform3DRotateX(matrix, Code.radians(-5.0));
		matrix = Matrix.transform3DRotateZ(matrix, Code.radians(-10.0));
		matrix = Matrix.transform3DTranslate(matrix, 1,0,5);
		matrix = Matrix.transform3DRotateY(matrix, Code.radians(5.0));
		transforms.push(matrix);
		errorAbs.push(0.0);
		// C
		matrix = new Matrix(4,4).identity();
		matrix = Matrix.transform3DRotateX(matrix, Code.radians(0.0));
		matrix = Matrix.transform3DRotateZ(matrix, Code.radians(0.0));
		matrix = Matrix.transform3DTranslate(matrix, -1,0,3);
		matrix = Matrix.transform3DRotateY(matrix, Code.radians(10.0));
		transforms.push(matrix);
		errorAbs.push(0.0);
		// RELATIVE ERRORS
		// errorRel.push(0.0001); // 0-1
		// errorRel.push(0.0001); // 0-2
		// errorRel.push(0.0001); // 1-2
		// errorRel.push(0.1); // 0-1
		// errorRel.push(0.1); // 0-2
		// errorRel.push(0.1); // 1-2
		errorRel.push(1.0); // 0-1
		errorRel.push(1.0); // 0-2
		errorRel.push(1.0); // 1-2

var relatives = [];
// 0 - 0
var m01 = new Matrix(4,4).fromArray([0.9852452788551778,-0.057938378546280554,0.1610431146774397,-0.878320738094192,0.0688663699850334,0.9956270002867375,-0.06312130690279863,-0.11158775005596615,-0.15668172700946204,0.07328042434006983,0.9849268073465518,0.45994459909786123,0,0,0,1]);
// 0 - 1
var m02 = new Matrix(4,4).fromArray([0.9459623368113048,-0.0478518292225626,0.3207264563059149,-0.9468183777412855,0.09048378346300445,0.9887191904003704,-0.11936099641112435,-0.05263257999152773,-0.31139676020266394,0.14193155031243412,0.9396209303549989,0.31688483672826967,0,0,0,1]);
// 1 - 0
var m12 = new Matrix(4,4).fromArray([0.9894350488503838,-0.01395407209761812,0.14430373515031894,-0.9954390393443785,0.019856107274747736,0.9990206402764957,-0.039541058476399674,-0.04161944827421032,-0.14361065110336566,0.041988619570483894,0.9887431095670061,0.08518822847671698,0,0,0,1]);

var errors = [2.369151155554159, 0.45721548825616115, 0.07950081671120096];
// m01 = Matrix.inverse(m01);
// m02 = Matrix.inverse(m02);
// m12 = Matrix.inverse(m12);

relatives.push(m01,m02,m12);

var m0 = new Matrix(4,4).identity();
var m1 = Matrix.mult(m01,m0);
// var m2 = Matrix.mult(m02,m0);
var m2 = Matrix.mult(m12,m1);
transforms = [m0,m1,m2];



		// SET TO EXTRINSIC?:
		for(var i=0; i<transforms.length; ++i){
			var transform = transforms[i];
			var inverse = R3D.inverseCameraMatrix(transform);
			transforms[i] = inverse;
		}

		// SET TO EXTRINSIC?:
		for(var i=0; i<relatives.length; ++i){
			var relative = relatives[i];
			var inverse = R3D.inverseCameraMatrix(relative);
			// relatives[i] = inverse;
		}
// relatives = null;


		// DRAW
		drawWorldOrigin();
		for(var i=0; i<transforms.length; ++i){
			var transform = transforms[i];
			drawCameraFromExtrinsic(transform, 0xFFFF0000);
		}
		// ...

	for(var i=0; i<transforms.length; ++i){
		var tA = transforms[i];
		console.log(" "+i+": .....................");
		console.log(tA+"");
		// console.log("inv:");
		// console.log(Matrix.inverse(tA)+"");
		// console.log(R3D.relativeTransformMatrix(Matrix.inverse(transforms[0]),Matrix.inverse(tA))+"");
		// console.log(R3D.relativeTransformMatrix(Matrix.inverse(tA),Matrix.inverse(transforms[0]))+"");
		// console.log(R3D.relativeTransformMatrix(transforms[0],tA)+"");
		// console.log(R3D.relativeTransformMatrix(tA,transforms[0])+"");
	}
// console.log("...");
console.log("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
	var relativePairs = [];
	var errorPairs = [];
	var e = 0;
var checksT = [];
var checksR = [];
var checksM = [];
var index = 0;
	for(var i=0; i<transforms.length; ++i){
		var tA = transforms[i];
		var arrayTrans = [];
		var arrayError = [];
		relativePairs.push(arrayTrans);
		errorPairs.push(arrayError);
		for(var j=i+1; j<transforms.length; ++j, ++index){
// console.log(" "+i+" - "+j+" ... ");
			var tB = transforms[j];
			var tAinv = Matrix.inverse(tA);
			var tBinv = Matrix.inverse(tB);
			// var identity = new Matrix(4,4).identity();
			// var aToB = R3D.relativeTransformMatrix(tA,tB);
			// console.log(aToB+"");
			// var twistA = ;
			// var aToB = tB;
		// var aToB = R3D.relativeTransformMatrix(tA,tB);
		// invA = R3D.inverseCameraMatrix(absA);
			// var absB = tB;
			// var invA = R3D.inverseCameraMatrix(tA);
			// aToB = Matrix.mult(invA,absB);
			// aToB = R3D.relativeTransformMatrix(tA,tB);
		// console.log(aToB+"");
		// console.log(Matrix.inverse(aToB)+"");

		// R3D.inverseCameraMatrix = function(P){
		// 	// return Matrix.inverse(P);
		// 	// throw "NO ...."; // THIS SEEMS TO BE WRONG
		//
		// 	var R = P.getSubMatrix(0,0,3,3);
		// 	var t = P.getSubMatrix(0,3,3,1);
		// 	t.scale(-1);
		// //	console.log(R+"")
		// 	//R = Matrix.transpose(R); // inverse
		// 	R = Matrix.inverse(R);
		// 	P = R.copy().appendColFromArray(t.toArray()).appendRowFromArray([0,0,0,1]);
		// 	return P;
		// }
		// var orgA = tA.multV3DtoV3D(new V3D(0,0,0));
		// var orgB = tB.multV3DtoV3D(new V3D(0,0,0));
		// console.log(" ABS: "+orgA+" & "+orgB);
		// var orgA = tAinv.multV3DtoV3D(new V3D(0,0,0));
		// var orgB = tBinv.multV3DtoV3D(new V3D(0,0,0));
		// var aToB = V3D.sub(orgB,orgA);
		// console.log(" diff inv => "+aToB);

		// var twistA = Code.vectorTwistFromMatrix3D(tA);
		// var twistB = Code.vectorTwistFromMatrix3D(tB);
		// var twA = twistA;
		// var twB = twistB;
		var twistAinv = Code.vectorTwistFromMatrix3D(tAinv);
		var twistBinv = Code.vectorTwistFromMatrix3D(tBinv);
		// var twistAB = Code.diffTwistVector3D(twistA, twistB);
		// var twistABinv = Code.diffTwistVector3D(twistAinv, twistBinv);

var twA = twistAinv;
var twB = twistBinv;
var tO = V3D.sub(twB["offset"],twA["offset"]);
var tD = Code.diffTwistVector3D(twA, twB);
// var rel = R3D.relativeTransformMatrix(tA,tB);
// FROM EXTRINSIC TO CAMERA
var rel = R3D.relativeTransformMatrix(tAinv,tBinv);
var error = 1.0;
if(relatives && relatives.length>0){
	rel = relatives[index];
	error = errors[index];
	// rel = Matrix.inverse(rel);
}

// tO.scale(-1);
checksT.push({"A":i, "B":j, "translation": tO, "error":error});
checksR.push({"A":i, "B":j, "rotation": tD, "error":error});
checksM.push({"A":i, "B":j, "relative": rel, "error":error});

console.log("T"+i+"-"+j+" = "+tO+" ");
// console.log(" = ");
// console.log(""+aToB);
// console.log(orgA+" -> "+orgB+" = "+V3D.sub(orgB,orgA));

// NEED IN TERMS OF RELATIVE TRANSFORM FROM 0 .... NOT INVERSE MADNESS

// tA = Matrix.transform3DTranslate(tA,orgA.copy().scale(-1));
// tB = Matrix.transform3DTranslate(tB,orgB.copy().scale(-1));

// tA = tAinv;
// tB = tBinv;
/*
var twist;
	twist = Code.vectorTwistFromMatrix3D(tA);
var twistA = twist;
var dirA = twist["direction"];
var angleA = twist["angle"];
var offsetA = twist["offset"];

twist = Code.vectorTwistFromMatrix3D(tB);
var twistB = twist;
var dirB = twist["direction"];
var angleB = twist["angle"];
var offsetB = twist["offset"];
var offsetAB = V3D.sub(offsetB,offsetA);
// var twistAB = Code.diffTwistVector3D(twistB, twistA);
var twistAB = Code.diffTwistVector3D(twistA, twistB);
var matrixAB = Code.Matrix3DFromVectorTwist(offsetAB, twistAB);
// var matrixAB = Code.Matrix3DFromVectorTwist(new V3D(0,0,0), twistAB);
// 	matrixAB.set(0,3, offsetAB.x);
// 	matrixAB.set(1,3, offsetAB.y);
// 	matrixAB.set(2,3, offsetAB.z);
// console.log(offsetAB);
// console.log(twistAB);
// console.log(matrixAB+"\n");
aToB = matrixAB;
// matrixAB = Matrix.inverse(matrixAB);


// aToB = R3D.relativeTransformMatrix(tAinv,tBinv);






			var error = errorRel[e];
			// ADD ERROR:
				var p = new V3D().random(error,error,error);
				// angle
				// Matrix.transform3DRotate(matrix,vector,angle);

				// position
				// aToB = Matrix.transform3DTranslate(aToB, p.x,p.y,p.z);
			arrayTrans.push(aToB);
			arrayError.push(error);
			++e;
*/
		}
	}

checksFxn(checksT,checksR, checksM ,transforms[0]);

throw "...";

	// console.log(relativePairs);
	// console.log(errorPairs);
/*
	// points
	var pointCount = 100;
	var points3D = [];
	var pointScale = 1.0;
	for(var i=0; i<pointCount; ++i){
		var point = new V3D();
		point.random(pointScale,pointScale,pointScale);
		points3D.push(point);
	}
	// K
	var imageWidth = 400;
	var imageHeight = 300;
	var f = 1000;
	var fx = f;
	var fy = f;
	var cx = 0.5;
	var cy = 0.5;
	var s = 0.0;
	var K = new Matrix(3,3);
		K.set(0,0, fx);
		K.set(0,1, s);
		K.set(0,2, cx*imageWidth);
		K.set(1,0, 0.0);
		K.set(1,1, fy);
		K.set(1,2, cy*imageHeight);
		K.set(2,0, 0.0);
		K.set(2,1, 0.0);
		K.set(2,2, 1.0);
	// project

	for(var i=0; i<transforms.length; ++i){
		var t = transforms[i];
		for(var j=0; j<points3D.length; ++j){
			var p3D = points3D[j];
			var p2D = ;
		}
	}


	var relativeAtoB = R3D.relativeTransformMatrix(transformA,transformB);
	var e = 0;
	for(var i=0; i<transforms.length; ++i){
		var tA = transforms[i];
		for(var j=i+1; j<transforms.length; ++j){
			var tB = transforms[j];
			var identity = new Matrix(4,4).identity();
			var aTob = R3D.relativeTransformMatrix(tA,tB);
			var error = errors[e];
			++e;
		}
	}
*/


/*
make absolute points
make absolute errors
make relative errors
project points to each camera with separate abs error
for each pair: find relative matrix ; add relative error by adding additional rotation/translation
find R3D optimized orientations
=>
compare known absolute (move 0th camera to 0,0,0) & relatives with found

*/

// 	var errorAB = transformRMean + 1.0*transformRSigma;
// // console.log(transformA+"");
// // console.log(transformB+"");
// // console.log(relativeAtoB+"");
// 	var indexA = tableViewIDToIndex[viewA.id()+""];
// 	var indexB = tableViewIDToIndex[viewB.id()+""];
// 	var indexMin = Math.min(indexA,indexB);
// 	var indexMax = Math.max(indexA,indexB);
// 	indexA = indexMin;
// 	indexB = indexMax-indexMin-1;
// 	relativePairs[indexA][indexB] = relativeAtoB;
// 	errorPairs[indexA][indexB] = errorAB;
// }
// get result
// console.log("before");
// var relativePairs = [];
// var errorPairs = [];
var result = R3D.absoluteOrientationsFromRelativeOrientations(relativePairs, errorPairs);
// console.log(result);
var absolutes = result["absolute"];
// reference will be the 0th matrix
var trans0 = transforms[0];
var pred0 = absolutes[0];
var rel;
console.log(" > > > > > > > ");

// for(var i=0; i<absolutes.length; ++i){
// 	absolutes[i] = Matrix.inverse(absolutes[i]);
// }
for(var i=0; i<transforms.length; ++i){
	console.log("      "+i);
	var tKnown = transforms[i];
		// tKnown = R3D.relativeTransformMatrix(tKnown,trans0);
		tKnown = R3D.relativeTransformMatrix(trans0,tKnown);
		// tKnown = Matrix.mult(tKnown,pred0);
		// tKnown = Matrix.mult(pred0,tKnown);
	console.log(tKnown+"");
	//
	var orgA = tKnown.multV3DtoV3D(new V3D(0,0,0));
	var dirA = tKnown.multV3DtoV3D(new V3D(0,0,1));
		dirA.sub(orgA);

	var tPredict = absolutes[i];
	// tPredict = R3D.relativeTransformMatrix(tPredict,pred0);
	tPredict = R3D.relativeTransformMatrix(pred0,tPredict);
	console.log(tPredict+"");
	//
	var orgB = tPredict.multV3DtoV3D(new V3D(0,0,0));
	var dirB = tPredict.multV3DtoV3D(new V3D(0,0,1));
		dirB.sub(orgB);

// console.log(orgA+" . ");
// orgA.x = tKnown.get(0,3);
// orgA.y = tKnown.get(1,3);
// orgA.z = tKnown.get(2,3);
// console.log(orgA+" ? ");

	var orgDiff = V3D.sub(orgB,orgA);
	var dirDiff = V3D.angle(dirA,dirB);


console.log(" "+i+" DIFF: "+orgDiff.length()+" @ "+Code.degrees(dirDiff));

	var twist;
		twist = Code.vectorTwistFromMatrix3D(tKnown);
	var twistA = twist;
	var dirA = twist["direction"];
	var angleA = twist["angle"];
	var offsetA = twist["offset"];
		twist = Code.vectorTwistFromMatrix3D(tPredict);
	var twistB = twist;
	var dirB = twist["direction"];
	var angleB = twist["angle"];
	var offsetB = twist["offset"];

	var offsetAB = V3D.sub(offsetB,offsetA);
	var twistAB = Code.diffTwistVector3D(twistB, twistA);

	// console.log(offsetAB+" | "+twistAB["angle"]);

}



	throw "...";

}






function classesLoadedFxn(){


/*
	var cameraA = new Matrix(4,4).identity();
	var cameraB = new Matrix(4,4).identity();
		cameraB = Matrix.transform3DRotateX(cameraB, Code.radians(-10));
		cameraB = Matrix.transform3DRotateY(cameraB, Code.radians(45));
		cameraB = Matrix.transform3DRotateZ(cameraB, Code.radians(20));
		cameraB = Matrix.transform3DTranslate(cameraB, 1,2,3);

	var cameraC = new Matrix(4,4).identity();
		cameraC = Matrix.transform3DRotateX(cameraC, Code.radians(10));
		cameraC = Matrix.transform3DRotateY(cameraC, Code.radians(25));
		cameraC = Matrix.transform3DRotateZ(cameraC, Code.radians(60));
		cameraC = Matrix.transform3DTranslate(cameraB, -1,-1,1);

	// TRUE:
	var extrinsicA = R3D.extrinsicMatrixFromCameraMatrix(cameraA);
	var extrinsicB = R3D.extrinsicMatrixFromCameraMatrix(cameraB);
	var extrinsicC = R3D.extrinsicMatrixFromCameraMatrix(cameraC);
	var cameraA2 = R3D.cameraMatrixFromExtrinsicMatrix(extrinsicA);
	var cameraB2 = R3D.cameraMatrixFromExtrinsicMatrix(extrinsicB);
	var cameraC2 = R3D.cameraMatrixFromExtrinsicMatrix(extrinsicC);

	// TRUE:
	// var extrinsicA = Matrix.inverse(cameraA);
	// var extrinsicB = Matrix.inverse(cameraB);
	// var extrinsicC = Matrix.inverse(cameraC);
	// var cameraA2 = Matrix.inverse(extrinsicA);
	// var cameraB2 = Matrix.inverse(extrinsicB);
	// var cameraC2 = Matrix.inverse(extrinsicC);


console.log(cameraA+"");
console.log(extrinsicA+"");
console.log(cameraA2+"");
console.log(" ... ");
console.log(cameraB+"");
console.log(extrinsicB+"");
console.log(cameraB2+"");
console.log(" ... ");
console.log(cameraC+"");
console.log(extrinsicC+"");
console.log(cameraC2+"");


// cameraA = extrinsicA;
// cameraB = extrinsicB;
// cameraC = extrinsicC;

	// RELATIVE
	var cameraBtoC = R3D.componentwiseRelativeCameraMatrix(cameraB,cameraC);
	var cameraCtoB = R3D.componentwiseRelativeCameraMatrix(cameraC,cameraB);

	// CORRECT
	var cameraBtoC = R3D.relativeTransformMatrix2(cameraB,cameraC);
	var cameraCtoB = R3D.relativeTransformMatrix2(cameraC,cameraB);

	// WRONG:
	// var cameraBtoC = R3D.relativeTransformMatrix(cameraB,cameraC);
	// var cameraCtoB = R3D.relativeTransformMatrix(cameraC,cameraB);








console.log(" OFFSET ");
	// NOT EQUAL:
	// console.log(R3D.componentwiseRelativeCameraMatrix(cameraA,cameraB)+"");
	// console.log(Matrix.inverse(cameraB)+"");

	// NOT WORK:
	// var cameraBtoC = R3D.relativeTransformMatrix(cameraB,cameraC);
	// var cameraCtoB = R3D.relativeTransformMatrix(cameraC,cameraB);

	var estimatedCFromB = Matrix.mult(cameraBtoC,cameraB);
	var estimatedBFromC = Matrix.mult(cameraCtoB,cameraC);

	console.log("C: "+cameraC+"");
	console.log("C: "+estimatedCFromB+"");
	console.log(" ... ");
	console.log("B: "+cameraB+"");
	console.log("B: "+estimatedBFromC+"");



	return

*/


	/*
		this IS right:
		var relativeAtoB = Matrix.mult(invA,absB);

		why does this LOOK right here:
		var relativeAtoB = Matrix.mult(absB,invA);
	*/




	// R3D.cameraMatrixFromExtrinsicMatrix = function(extrinsic){
	// R3D.extrinsicMatrixFromCameraMatrix = function(camera){


	// R3D.inverseCameraMatrix(camera);

	// R3D.relativeTransformMatrix = function(absA,invA,absB,invB){



// want best affine WITHOUT TRANSLATION

// R3D.stereoMatchAverageAffine(imageMatrixA,imageMatrixB,matches);


	var app = new App3DR();
		return;


	// GLOBAL STAGE:
	// AVERAGING 3D POINTS
	this._canvas = new Canvas(null,0,0,Canvas.STAGE_FIT_FILL, false,false);
	this._stage = new Stage(this._canvas, 1000/20);
	this._root = new DO();
	this._stage.addChild(this._root);
	this._canvas.addListeners();
	this._stage.addListeners();
	this._stage.start();
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_CLICK,this.handleMouseClickFxn,this);
	GLOBALSTAGE = this._stage;


/*

	throw "KD TREE";
*/

/*
Matrix.transform2DTranslate = function(a,tX,tY){
	var b = Matrix._transformTemp2D.setFromArray([1.0,0.0,tX, 0.0,1.0,tY, 0.0,0.0,1.0]);
	return Matrix.mult(b,a);
}
Matrix.transform2DScale = function(a,sX,sY){
	sY = sY!==undefined?sY:sX;
	var b = Matrix._transformTemp2D.setFromArray([sX,0.0,0.0, 0.0,sY,0.0, 0.0,0.0,1.0]);
	return Matrix.mult(b,a);
}
Matrix.transform2DRotate = function(a,ang){
	var b = Matrix._transformTemp2D.setFromArray([Math.cos(ang),-Math.sin(ang),0.0, Math.sin(ang),Math.cos(ang),0.0, 0.0,0.0,1.0]);
	return Matrix.mult(b,a);
}
Matrix.transform2DSkewX = function(a,ang, isAngle){ // give an angle
	if(isAngle){
		ang = Math.tan(ang);
	}
	var b = Matrix._transformTemp2D.setFromArray([1.0,ang,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0]);
	return Matrix.mult(b,a);
}
Matrix.transform2DSkewY
*/
var affine = new Matrix(3,3).identity();
affine = Matrix.transform2DScale(affine, 1.5,2.0);
affine = Matrix.transform2DRotate(affine, Code.radians(45));
affine = Matrix.transform2DTranslate(affine, 2,1);

console.log("START:");
console.log(affine+"");
console.log( R3D.infoFromAffine2D(affine) );

// var error = 0.0;
// var error = 0.10;
var error = 1.0;
// var error = 5.0;
var pointCount = 10;
var outlierCount = 3;

var pointsA = [];
var pointsB = [];
for(var i=0; i<pointCount; ++i){
	var a = new V2D();
	a.x = Math.random()*100;
	a.y = Math.random()*100;
	var b = affine.multV2DtoV2D(a);
	b.x += Code.randomFloat(-error,error);
	b.y += Code.randomFloat(-error,error);
if(i>pointCount-outlierCount-1){
	// b.x += Code.randomFloat(-10,10);
	// b.y += Code.randomFloat(-10,10);
	// b.x += 2*error + 112;
	// b.y += 2*error + 12;
	// b.x += 2*error;
	// b.y += 2*error;
	// b.x += Code.randomFloat(-10,10);
	// b.y += Code.randomFloat(-10,10);
	b.x += Code.randomFloat(-2*error,2*error);
	b.y += Code.randomFloat(-2*error,2*error);
	console.log("outlier: "+b);
}
	pointsA.push(a);
	pointsB.push(b);

}

// var matrix = R3D.affineMatrixLinear(pointsA,pointsB);
// console.log(matrix);


// var affine = R3D.ransacAffine(pointsA,pointsB, error*1.0 );
var affine = R3D.ransacAffineIterate(pointsA,pointsB,);
// console.log(affine);


console.log(affine);
matrix = affine["affine"];
console.log(" END :");
console.log(""+matrix);
console.log( R3D.infoFromAffine2D(matrix) );
// console.log(""+Matrix.inverse(matrix));


// DRAW:
var OFFX = 200;
var OFFY = 100;
for(var i=0; i<pointCount; ++i){
	var a = pointsA[i];
	var b = pointsB[i];
	var c = matrix.multV2DtoV2D(a);

	var d = new DO();
	d.graphics().setLine(2.0,0xFFFF0000);
	d.graphics().beginPath();
	d.graphics().drawCircle(a.x,a.y, 3.0);
	d.graphics().strokeLine();
	d.graphics().endPath();
if(i>pointCount-outlierCount-1){
	d.graphics().setLine(2.0,0xFFFF00FF);
}else{
	d.graphics().setLine(2.0,0xFF006699);
}
	d.graphics().beginPath();
	d.graphics().drawCircle(b.x,b.y, 4.0);
	d.graphics().strokeLine();
	d.graphics().endPath();

	d.graphics().setLine(2.0,0xFF00CC00);
	d.graphics().beginPath();
	d.graphics().drawCircle(c.x,c.y, 5.0);
	d.graphics().strokeLine();
	d.graphics().endPath();

	d.matrix().translate(OFFX,OFFY);
	//d.matrix().translate(location.x*SCA,location.y*SCA);

	GLOBALSTAGE.addChild(d);
}



return;



/*
abs rotation/orientation of view A & B [quaternion,rodrigues,matrix,rotor,twist]
absA
absB

rel orientation of edge AB [quaternion]
relAB

*/


	// throw "rotation errors";


/*


	// var b0 = new Bivector();

	// var r0 = Rotor.fromTwist( Math.radians(10.0), V3D.DIRZ, new V3D(1,1,1).norm() );

	var twistAngle = Code.radians(20.0);
	var twistA = new V3D(0,0,1).norm();
	var twistB = new V3D(1,1,1).norm();
	var rotor = Rotor.fromTwist(twistAngle,twistA,twistB);
	var twist = rotor.toTwist(rotor);
	console.log(twist["direction"]+" @ "+Code.degrees(twist["angle"]));
	var start = new V3D(0,0,1).norm();
	var end = new V3D(1,1,1).norm();
	var result = rotor.rotateV3D(start);
	console.log("FROM : "+start+" => "+result);

	var inv = rotor.copy().reverse();
	var result = inv.rotateV3D(end);
	console.log("FROM : "+result+" <= "+end);

	// var iden = Rotor.mul(rotor,inv);
	console.log(rotor,inv);
	var iden = rotor.rotateRotor(inv);
	// var iden = inv.rotateRotor(rotor);
	console.log(iden+"")
	var result = iden.rotateV3D(start);
	console.log("FROM : "+start+" ? "+result);

	throw "THIS SHOULD BE IDENTITY";

	throw "BIVECTOR";
*/



/*
var matrix;


// transform3DRotateX

	matrix = new Matrix(4,4).identity();
	matrix = Matrix.transform3DRotateX(matrix, Code.radians(50));
	matrix = Matrix.transform3DRotateY(matrix, Code.radians(30));
	matrix = Matrix.transform3DRotateZ(matrix, Code.radians(10));
	matrix = Matrix.transform3DTranslate(matrix, new V3D(1,2,3));
	// matrix.set(0,3, 1);
	// matrix.set(1,3, 2);
	// matrix.set(2,3, 3);
var transformA = matrix;

	matrix = new Matrix(4,4).identity();
	matrix = Matrix.transform3DRotateX(matrix, Code.radians(20));
	matrix = Matrix.transform3DRotateY(matrix, Code.radians(-30));
	matrix = Matrix.transform3DRotateZ(matrix, Code.radians(-10));
	matrix = Matrix.transform3DTranslate(matrix, new V3D(1,-1,1));
	// matrix.set(0,3, 1);
	// matrix.set(1,3, -1);
	// matrix.set(2,3, 1);
var transformB = matrix;


	matrix = new Matrix(4,4).identity();
	matrix = Matrix.transform3DRotateX(matrix, Code.radians(-20));
	matrix = Matrix.transform3DRotateY(matrix, Code.radians(30));
	matrix = Matrix.transform3DRotateZ(matrix, Code.radians(20));
	matrix = Matrix.transform3DTranslate(matrix, new V3D(-1,0,2));
	// matrix.set(0,3, 1);
	// matrix.set(1,3, -1);
	// matrix.set(2,3, 1);
var transformC = matrix;

matrix = new Matrix(4,4).identity();
matrix = Matrix.transform3DRotateX(matrix, Code.radians(30));
matrix = Matrix.transform3DRotateY(matrix, Code.radians(10));
matrix = Matrix.transform3DRotateZ(matrix, Code.radians(10));
matrix = Matrix.transform3DTranslate(matrix, new V3D(2,3,4));
// matrix.set(0,3, 1);
// matrix.set(1,3, -1);
// matrix.set(2,3, 1);
var transformD = matrix;

// transformA = Matrix.inverse(transformA);
// transformB = Matrix.inverse(transformB);

console.log("A:\n"+transformA+"");
console.log("B:\n"+transformB+"");


// RELATIVE:

// var inverseA = R3D.inverseCameraMatrix(transformA);
// var inverseB = R3D.inverseCameraMatrix(transformB);
// var inverseA = Matrix.inverse(transformA);
// var inverseB = Matrix.inverse(transformB);
var absolutes = [transformA,transformB,transformC,transformD];


// for(var i=0; i<absolutes.length; ++i){
// 	var tA = absolutes[i];
// 	var invA = Matrix.inverse(tA);
// 	absolutes[i] = invA;
// }


var edges = [];
for(var i=0; i<absolutes.length; ++i){
	var tA = absolutes[i];
	var translation = tA.multV3DtoV3D(new V3D(0,0,0));
		console.log("CAMERA TRANSLATION: "+translation);
	var invA = Matrix.inverse(tA);
	for(var j=i+1; j<absolutes.length; ++j){
		var tB = absolutes[j];
		var invB = Matrix.inverse(tB);


		// var rAB = Matrix.mult(invA,tB);
		//
		// var R = rAB.getSubMatrix(0,0,3,3);
		// var T = new V3D().fromArray(rAB.getSubMatrix(0,3,3,1).toArray());
		// // var T = tAB.getSubMatrix(0,3,3,1);
		// console.log(R+"")
		// console.log(T+"")
		// R = Matrix.transpose(R);
		// var C = R.multV3DtoV3D(T).scale(-1);
		// console.log(C+"")


		// var tA = Matrix.inverse(tA);
		// var tB = Matrix.inverse(tB);

		//var relativeAtoB = Matrix.mult(invA,absB);
// var mA = Matrix.mult(tB,invA);
// console.log(mA+"");

		var centerA = tA.multV3DtoV3D(new V3D(0,0,0));
		var centerB = tB.multV3DtoV3D(new V3D(0,0,0));
		var translation = V3D.sub(centerB,centerA);

		var rotationA = V4D.qFromMatrix(tA);
		var rotationB = V4D.qFromMatrix(tB);
		var reverseA = rotationA.copy().qInverse().qNorm();
		var quaternion = V4D.qMul(rotationB,reverseA);
		// var quaternion = V4D.qMul(reverseA,quaternion);
		// var quaternion = V4D.qMul(reverseA,rotationB);


		// var what = Matrix.mult(tB,invA);


		var iAB = R3D.relativeTransformMatrix(invA,invB);
		// var iAB = R3D.relativeTransformMatrix(tA,tB);


		var tAB = R3D.relativeTransformMatrix(tA,tB);


		// var what = Matrix.mult(tAB,invA);
		var what = Matrix.mult(invA,tAB);

		// console.log("A: "+( Matrix.mult(tAB,invA) ));
		// console.log("B: "+( Matrix.mult(tAB,invB) ));
		// console.log("C: "+( Matrix.mult(invA,tAB) ));
		// console.log("D: "+( Matrix.mult(invB,tAB) ));
		// console.log("A: "+( Matrix.mult(tAB,tA) ));
		// console.log("B: "+( Matrix.mult(tAB,tB) ));
		// console.log("C: "+( Matrix.mult(tA,tAB) ));
		// console.log("D: "+( Matrix.mult(tB,tAB) ));


		// var tAB = R3D.relativeTransformMatrix(tB,tA);
		console.log(i+"->"+j+":");
		// console.log("translation: "+translation);
		// console.log("rotation: "+quaternion);


		// checking:
		// relative quaternion->axis != rodrigues->matrix->axis
		var relTwist = Code.vectorTwistFromQuaternion(quaternion);
		var relQuat = Code.quaternionFromVectorTwist(relTwist);
		var relTwist2 = Code.vectorTwistFromQuaternion(relQuat);
		// console.log("   T1: "+relTwist["direction"]+" @ "+Code.degrees(relTwist["angle"]));
		// console.log("   T2: "+relTwist2["direction"]+" @ "+Code.degrees(relTwist2["angle"]));
		var relAxis = Code.axisFromQuaternion(relQuat);

		// var relMatrix = Code.Matrix3DFromVectorTwist(relTwist);
		// var relAxis = Code.axisFromMatrix3D(relMatrix);
		//
		var absMatA = V4D.qMatrix(rotationA, new Matrix(3,3));
		var absMatB = V4D.qMatrix(rotationB, new Matrix(3,3));
		var invMatA = Matrix.inverse(absMatA);
		// var absMatAB = Matrix.mult(invMatA,absMatB);
		var absMatAB = Matrix.mult(absMatB,invMatA);
		var absAxis = Code.axisFromMatrix3D(absMatAB);
		// quaternion.qInverse();
		// var absAxis = Code.axisFromQuaternion(quaternion);
		//
		console.log("   AXIS A: "+relAxis);
		console.log("   AXIS B: "+absAxis);



// var testB = V4D.qMul(quaternion,rotationA);
// 		console.log("B1: "+rotationB);
// 		console.log("B2: "+testB);

		// console.log(""+( Matrix.mult(tA,invB) ));
		// console.log(""+( Matrix.mult(invB,tA) ));
		// console.log(""+( Matrix.mult(invA,tB) ));
		// console.log(""+( Matrix.mult(tB,invA) ));


		var edge = [i,j, {"quaternion":quaternion, "translation":translation}, 1.0];
		edges.push(edge);
	}
}

// throw "..."
console.log("EDGES:");
console.log(edges);

R3D.optimumTransform3D(edges);






var matrix = transformAB;
var translation = matrix.multV3DtoV3D(new V3D(0,0,0));
console.log("CAMERA TRANSLATION: "+translation);
var rotation = V4D.qFromMatrix(matrix);
console.log("CAMERA ROTATION: "+rotation);



// AVERAGING:

var twist = Code.vectorTwistFromQuaternion(rotation);
console.log("TWIST:");
console.log(twist);
// averaging code here:


// BACK TO FINAL ABSOLUTE POSITION
var rotation = Code.quaternionFromVectorTwist(twist);
console.log("ABSOLUTE ROTATION: "+rotation);


// ERROR MINIMIZING
var matrix = V4D.qMatrix(rotation,new Matrix(3,3));
// console.log(matrix);
var rodrigues = R3D.rotationMatrixToEulerRodriguez(matrix);
console.log("RODRIGUES ROTATION: "+rodrigues);



// BACK TO ABSOLUTE POSITION:
var matrix = R3D.rotationEulerRodriguezToMatrix(new Matrix(3,3), rodrigues);
var rotation = V4D.qFromMatrix(matrix);
console.log("ABSOLUTE ROTATION: "+rotation);







// convert back:



console.log("TO ABSOULTE: ");

// var transform = new Matrix(4,4).identity();
var tra = translation.copy();
var transform = new Matrix(3,3);
V4D.qMatrix(rotation, transform);
console.log(transform+"")
transform.appendColFromArray([tra.x,tra.y,tra.z]);
transform.appendRowFromArray([0,0,0,1]);
console.log(transform+"")


*/



/*
// separate into translation & rotation
TRANSLATION: x,y,z
ROTATION: quaternion

// separate into averaging variables:
TRANSLATION: x,y,z
ROTATION: quaternion => twist => quaternion

// separate into optimizing absolute variables
TRANSLATION: x,y,z
ROTATION: quaternion => rodrigues

// error metrics:
TRANSLATION: x,y,z & X,Y,Z
quaternion (REL) => x-y-z
rodrigues (ABS) => X-Y-Z
	error = angle(X,x) + angle(Y,y) + angle(Z,z) +




throw "ERROR METRIXING";

*/


	// var array = [1,2,3,4,5];//,6,7,8,9,10,11,12];
	// var info = Code.runningInfos(array, 7);
	// var means = info["mean"];
	// var sigmas = info["sigma"];
	// console.log(array);
	// console.log(means);
	// console.log(sigmas);
	// Code.printMatlabArray(array,"d");
	// Code.printMatlabArray(means,"a");
	// Code.printMatlabArray(sigmas,"s");
	// return;
/*
	var array = [];
	var count = 1000;
	for(var i=0; i<count; ++i){
		var x = (i-count*0.5)*0.01; //
		var y = x*x*x*0.001 + -x*x*0.10 + x*0.25 + 1.25;
		array[i] = Math.random()*1.0 + y;
	}
	var windowSize = Math.min(11,array.length*0.1 | 0);
	windowSize = 21;
	console.log(array);
	var info = Code.runningInfos(array, windowSize);
	var means = info["mean"];
	var sigmas = info["sigma"];
	console.log(array);
	console.log(means);
	console.log(sigmas);

	//var sigma = Code.runningStddev(array, windowSize);

	// Code.runningStddev(array, windowSize);

	Code.printMatlabArray(array,"d");
	Code.printMatlabArray(means,"a");
	Code.printMatlabArray(sigmas,"s");

	return;
*/
	/*
	var grid = new Grid2D();
	grid.setFromSizeAndCellSize(100,80, 10,10);
	console.log(grid);
	console.log(grid+"");

	var p;

	// p = new V2D(50,50);

	grid.insertObject(new V2D(50,50));
	console.log(grid+"");


	var n = grid.neighbor9ObjectsForPoint(40,40);
	console.log(n);

	var n = grid.neighbor9ObjectsForPoint(1,1);
	console.log(n);

	throw "...";
	*/


	/*
	// position relative
	var A = new Matrix(4,4).identity();
	A = Matrix.transform3DRotateZ(A, Code.radians(45));
	A = Matrix.transform3DRotateX(A, Code.radians(15));
	// matrix = Matrix.transform3DRotateY(matrix, Code.radians(-15));
	// matrix = Matrix.transform3DRotateZ(matrix, Code.radians(-5));
	// matrix = Matrix.transform3DRotateY(matrix, Code.radians(-10));
	// matrix = Matrix.transform3DRotateX(matrix, Code.radians(-20));
	A = Matrix.transform3DTranslate(A, 1,2,3);
	console.log(A+"");

	var invA = Matrix.inverse(A);
	console.log(invA+"");

	var P = new V3D(1,2,3);
	console.log("P: "+P+"");

	var Pa = A.multV3DtoV3D(P);
	console.log("Pa: "+Pa+"");

	var Pw = invA.multV3DtoV3D(Pa);
	console.log("Pw: "+Pw+"");


		// var relativeAtoB = Matrix.mult(invA,absB);




	return;
	*/
/*


	// AFFINE AVERAGE TESTING:
	//
	var o = new V2D(0,0);
	var x = new V2D(1,0);
	var y = new V2D(0,1);
	var u, a, b;
	// A:
	u = new V2D(0,0);
	a = new V2D(1,0).norm().scale(2.0).add(u);
	b = new V2D(0,1).norm().scale(2.0).add(u);
	var affineA = R3D.affineMatrixExact([o,x,y],[u,a,b]);
	// B:
	// u = new V2D(40,-5);
	// a = new V2D(-1,0).norm().scale(1.0).add(u);
	// b = new V2D(0,1).norm().scale(2.0).add(u);
	// var affineB = R3D.affineMatrixExact([o,x,y],[u,a,b]);
	// u = new V2D(40,-5);
	// a = new V2D(1,1).norm().scale(2.0).add(u);
	// b = new V2D(4,-1).norm().scale(3.0).add(u);
	// var affineB = R3D.affineMatrixExact([o,x,y],[u,a,b]);

	// u = new V2D(40,-5);
	// a = new V2D(1,-1).norm().scale(2.0).add(u);
	// b = new V2D(1,1).norm().scale(3.0).add(u);
	// var affineB = R3D.affineMatrixExact([o,x,y],[u,a,b]);

	u = new V2D(40,5);
	a = new V2D(1,1).norm().scale(2.0).add(u);
	b = new V2D(0,1).norm().scale(2.0).add(u);
	var affineB = R3D.affineMatrixExact([o,x,y],[u,a,b]);

	// var ps = [0.9,0.1];
	// var ps = [0.75,0.25];
	var ps = [0.5,0.5];
	// var ps = [0.25,0.75];
	// var ps = [0.1,0.9];
	var affineC = Code.averageAffineMatrices([affineA,affineB], ps);

	//
	var s = 50;
	var square = [];
		square.push(new V2D(-s,-s));
		square.push(new V2D( s,-s));
		square.push(new V2D( s, s));
		square.push(new V2D(-s, s));

	var identity = new Matrix(3,3).identity();
	var trans = [identity,affineA,affineB,affineC];
	var colors = [0xFF000000,0x99FF0000,0x990000FF,0x9900CC00];
	var OFFY = 200;
	var OFFX = 200;
	for(var t=0; t<trans.length; ++t){
		var mat = trans[t];
		console.log(mat+"");
		var col = colors[t];
		// draw
		var d = new DO();
		d.graphics().setLine(1.0,col);
		d.graphics().beginPath();

		for(var k=0; k<square.length; ++k){
			var squ = square[k];
			var p = mat.multV2DtoV2D(squ);
			// console.log(p+"");
			if(k==0){
				d.graphics().moveTo(p.x,p.y + Math.random()*5);
			}else{
				d.graphics().lineTo(p.x,p.y + Math.random()*5);
			}
		}
		d.graphics().endPath();
		d.graphics().strokeLine();
		d.matrix().translate(OFFX,OFFY);
		GLOBALSTAGE.addChild(d);
	}

	// compare
	var sim = Stereopsis.affineSimilar(affineA,affineB);
	console.log("sim: "+sim);

	// show:
	throw "affined";
*/

/*
	// rotation averaging
	var matrix = new Matrix(4,4).identity();
	matrix = Matrix.transform3DRotateZ(matrix, Code.radians(45));
	matrix = Matrix.transform3DRotateX(matrix, Code.radians(15));
	matrix = Matrix.transform3DRotateY(matrix, Code.radians(-15));
	matrix = Matrix.transform3DRotateZ(matrix, Code.radians(-5));
	matrix = Matrix.transform3DRotateY(matrix, Code.radians(-10));
	matrix = Matrix.transform3DRotateX(matrix, Code.radians(-20));
	matrix = Matrix.transform3DTranslate(matrix, 1,2,3);
	console.log(matrix+"");
	var twist = Code.vectorTwistFromMatrix3D(matrix);
	console.log(twist);
	var angle = twist["angle"];
	var direction = twist["direction"];
	var location = twist["offset"];
	console.log(angle);
	console.log(direction);
	console.log(location);

	var trans = Code.Matrix3DFromVectorTwist(location, twist);

	console.log(trans);

	var a = new V3D(0,0,1);
	var b = trans.multV3DtoV3D(a);
	var c = matrix.multV3DtoV3D(a);
	console.log(a,b,c);
	var diff = V3D.sub(b,c);
	console.log(diff+"");





	throw "?";
*/
/*
	var vectors = [];
		vectors.push(new V2D(1,0).rotate(Code.radians(10.0)));
		vectors.push(new V2D(1,0).rotate(Code.radians(20.0)));
		vectors.push(new V2D(1,0).rotate(Code.radians(-30.0)));
		// vectors.push(new V2D(1,0).rotate(Code.radians(-15.0)));
	var avg2 = Code.averageAngleVector2D(vectors);
	var angle = V2D.angleDirection(V2D.DIRX,avg2);
	console.log(avg2+"");
	console.log(Code.degrees(angle)+"");


	vectors = [];
		vectors.push(new V3D(1,0).rotate( new V3D(0,0,1), Code.radians(10.0)));
		vectors.push(new V3D(1,0).rotate( new V3D(0,0,1), Code.radians(20.0)));
		vectors.push(new V3D(1,0).rotate( new V3D(0,0,1), Code.radians(-30.0)));
		//console.log(vectors+"")
		// vectors.push(new V2D(1,0).rotate(Code.radians(-15.0)));
	var avg3 = Code.averageAngleVector3D(vectors);
	var angle = V2D.angleDirection(V3D.DIRX,avg3);
	console.log(avg3+"");
	console.log(Code.degrees(angle)+"");

	return;
*/
	// AVERAGING 2D POINTS ITERITIVELY
// 	var points = [];
// 		points.push(new V2D(0,0));
// 		points.push(new V2D(2,0));
// 		points.push(new V2D(1,3));
// 	var avg = V2D.meanFromArray(points);
// 	console.log(avg+"");
// 	var weight = 1;
// 	var total = points[0].copy();
// 	for(var i=1; i<points.length; ++i){
// 		var point = points[i];
// 		var dir = V2D.sub(point,total);
// 		weight += 1;
// 		total.add( dir.scale(1.0/weight) );
// 	}
// 	console.log(total+" ? ");
// return;






//
// a = 1;
// b = 0;
// c = 1;
// d = 0;
// w = a*i + b*j + c*k + d


/*
// qA = new V4D().fromArray([-0.002,-0.550,0.183, -0.815]);

qA = new V4D().fromArray([3,4,3, 1]);
qA.qNorm();
console.log("qA:");
console.log(qA+"");
console.log(qA.qLength()+"");
console.log(qA.qLengthSquare()+"");

console.log("qA^-1:");
qAInv = qA.copy().qInverse();
qA.qNorm();
console.log(qAInv+"");

console.log("qB:");
qB = new V4D().fromArray([4,-1,-1, 2]);
qB.qNorm();
console.log(qB+"");

console.log("qAB:");
qAB = V4D.qMul(qB,qAInv);
qAB.qNorm();
console.log(qAB+"");

console.log("qC:");
qC = V4D.qMul(qAB,qA);
console.log(qC+"");
qC.qNorm();
console.log(qC+"");




throw "?"
*/


/*
// 3D:
var qA = V4D.qIdentity().qRotateDir(new V3D(1,0,1).norm(), Code.radians(-20.0));
var qB = V4D.qIdentity().qRotateDir(new V3D(0,-1,1).norm(), Code.radians(60.0));
var qC = V4D.qIdentity().qRotateDir(new V3D(1,1,-1).norm(), Code.radians(40.0));
// console.log("len "+qA.qLength());
// console.log("len "+qB.qLength());
// console.log("len "+qC.qLength());
qA.qNorm();
qB.qNorm();
qC.qNorm();
// console.log("len 2 "+qA.qLength());
// console.log("len 2 "+qB.qLength());
// console.log("len 2 "+qC.qLength());

var qAInv = qA.copy();
	qAInv.qInverse();
	qAInv.qNorm();
var qAB = V4D.qMul(qB,qAInv);
	qAB.qNorm();
var tB = V4D.qMul(qAB,qA);
	tB.qNorm();
console.log("qA: "+qA);
console.log("qA^-1: "+qAInv);
console.log("qAB: "+qAB);
console.log("qB: "+qB+" ?");
console.log("tB: "+tB+" ?");


console.log("len "+qA.qLength());
console.log("len "+qAInv.qLength());
console.log("len "+qB.qLength());
console.log("len "+qAB.qLength());

var p = new V3D(0,0,1);
var p1 = qB.qRotatePoint(p);
var p2 = tB.qRotatePoint(p);
console.log(p1+"");
console.log(p2+"");
*/

/*
var absA = new V3D(1,0,1).norm();
var absB = new V3D(1,1,1).norm();

var cross = V3D.cross(absA,absB);
// cross.norm();
var angle = V3D.angle(absA,absB);
// cross.length(angle);
console.log("A: "+absA);
console.log("B: "+absB);
console.log("C: "+cross+" @ "+Code.degrees(angle));
console.log(V3D.dot(cross,absA),V3D.dot(cross,absB),cross.length());
var q = new V4D().qRotateDir(cross, angle);

console.log("q: "+q);
var p = new V3D().copy(absA);
console.log("p1: "+p);
p = q.qRotatePoint(p);
console.log("p2: "+p);
		throw "IS THE RELATIVE CORRECT";
*/

// var qA = V4D.qIdentity().qRotateDir(new V3D(1,0,0), Code.radians(10.0));
// var qB = V4D.qIdentity().qRotateDir(new V3D(1,1,0), Code.radians(20.0));
// var qC = V4D.qIdentity().qRotateDir(new V3D(1,0,-1), Code.radians(40.0));
//
// var q1 = [qA,qB,qC];
// var q2 = [qC,qB,qA];
// var q3 = [qC,qA,qB];
// var qs = [q1,q2,q3];
// console.log(qs);
// for(var i=0; i<qs.length; ++i){
// 	var list = qs[i];
// 	var sum = V4D.qIdentity();
// 	for(var j=0; j<list.length; ++j){
// 		var q = list[j];
// 		sum = V4D.qMul(sum,q);
// 		sum.qNorm();
// 	}
// 	console.log(sum+"?");
// }
// throw "?";


/*

var tA = {"direction":new V3D(1,2,3).norm(), "angle":Code.radians(10.0)};
var tB = {"direction":new V3D(1,-2,1).norm(), "angle":Code.radians(20.0)};
// var tC = {"direction":new V3D(0,2,-3).norm(), "angle":Code.radians(40.0)};

console.log("A: "+tA["direction"]+" @ "+Code.degrees(tA["angle"]));
console.log("B: "+tB["direction"]+" @ "+Code.degrees(tB["angle"]));

// tAInv = Code.twistInverse(tA);
// console.log(tAInv["direction"]+" @ "+tAInv["angle"]);

// tAB = Code.twistAdd(tAInv,tB);
// tAB = Code.twistAdd(tB,tAInv);
var tAB = Code.twistRelative(tA,tB);
console.log("AB:"+tAB["direction"]+" @ "+Code.degrees(tAB["angle"]));

var tC = Code.twistAdd(tA,tAB);
console.log("C: "+tC["direction"]+" @ "+Code.degrees(tC["angle"]));


throw "INVERSE FAILS ........"

*/


/*
var t1 = [tA,tB,tC];
var t2 = [tC,tB,tA];
var t3 = [tC,tA,tB];
var t = [t1,t2,t3];

for(var i=0; i<t.length; ++i){
	var list = t[i];
	var sum = Code.twistIdentity();
	// console.log(list);
	for(var j=0; j<list.length; ++j){
		var twist = list[j];
		// console.log(twist);
		sum = Code.addTwistVector3D(sum,twist);
	}
	console.log(sum["direction"]+"?");
}
*/
// throw "?";


	var m0 = new Matrix(4,4).identity();
		m0 = Matrix.transform3DRotateZ(m0, Code.radians(-50.0));
		m0 = Matrix.transform3DRotateX(m0, Code.radians( 20.0));
		m0 = Matrix.transform3DRotateY(m0, Code.radians(-20.0));
		m0 = Matrix.transform3DRotateZ(m0, Code.radians(120.0));
	var m1 = new Matrix(4,4).identity();
		m1 = Matrix.transform3DRotateZ(m1, Code.radians(-10.0));
		m1 = Matrix.transform3DRotateX(m1, Code.radians(-20.0));
		m1 = Matrix.transform3DRotateY(m1, Code.radians( 20.0));
		m1 = Matrix.transform3DRotateZ(m1, Code.radians(-40.0));
	var m2 = new Matrix(4,4).identity();
		m2 = Matrix.transform3DRotateZ(m2, Code.radians( 20.0));
		m2 = Matrix.transform3DRotateX(m2, Code.radians(-50.0));
		m2 = Matrix.transform3DRotateY(m2, Code.radians(-10.0));
		m2 = Matrix.transform3DRotateZ(m2, Code.radians(-20.0));
	var m3 = new Matrix(4,4).identity();
		m3 = Matrix.transform3DRotateZ(m3, Code.radians(-20.0));
		m3 = Matrix.transform3DRotateX(m3, Code.radians(-10.0));
		m3 = Matrix.transform3DRotateY(m3, Code.radians(-90.0));
		m3 = Matrix.transform3DRotateZ(m3, Code.radians(-30.0));
	var m4 = new Matrix(4,4).identity();
		m4 = Matrix.transform3DRotateZ(m4, Code.radians(-20.0));
		m4 = Matrix.transform3DRotateX(m4, Code.radians( 10.0));
		m4 = Matrix.transform3DRotateY(m4, Code.radians( 20.0));
		m4 = Matrix.transform3DRotateZ(m4, Code.radians( 30.0));
	var m5 = new Matrix(4,4).identity();
		m5 = Matrix.transform3DRotateZ(m5, Code.radians( 10.0));
		m5 = Matrix.transform3DRotateX(m5, Code.radians(-10.0));
		m5 = Matrix.transform3DRotateY(m5, Code.radians(-20.0));
		m5 = Matrix.transform3DRotateZ(m5, Code.radians( 90.0));

	var points = [];
	points.push([new V3D(0, 1,1), V4D.qFromMatrix(m0) ]);
	points.push([new V3D(2, 1,0), V4D.qFromMatrix(m1) ]);
	points.push([new V3D(3, 0,0), V4D.qFromMatrix(m2) ]);
	points.push([new V3D(1, 0,1), V4D.qFromMatrix(m3) ]);
	// points.push([new V3D(4,2,3), V4D.qFromMatrix(m4) ]);
	// points.push([new V3D(1,2,-1), V4D.qFromMatrix(m5) ]);
		// points.push([new V3D(0,1,1), {"direction":new V3D(1,2,3).norm(), "angle":Code.radians(10.0)}]);
		// points.push([new V3D(2,1,0), {"direction":new V3D(1,1,-1).norm(), "angle":Code.radians(20.0)}]);
		// points.push([new V3D(3,0,0), {"direction":new V3D(0,-3,-3).norm(), "angle":Code.radians(-30.0)}]);
		// points.push([new V3D(5,2,0), {"direction":new V3D(2,1,1).norm(), "angle":Code.radians(40.0)}]);
		// points.push([new V3D(7,0,0), {"direction":new V3D(-2,2,2).norm(), "angle":Code.radians(-50.0)}]);
		// points.push([new V3D(1,3,0), {"direction":new V3D(-1,2,0).norm(), "angle":Code.radians(90.0)}]);
for(var i=0; i<points.length; ++i){
	console.log("ABS: "+i+": "+points[i][1]);
	var q = points[i][1];
	var t = Code.vectorTwistFromQuaternion(q);
	console.log("    "+t["direction"]+" @ "+Code.degrees(t["angle"]));
	var q2 = Code.quaternionFromVectorTwist(t);
	console.log("        "+q2);
	var t2 = Code.vectorTwistFromQuaternion(q2);
	console.log("  ? "+t2["direction"]+" @ "+Code.degrees(t2["angle"]));
	points[i][1] = q2;
}

	var edges = [];
		edges.push([0,1, 0.01]);
		edges.push([0,2, 0.01]);
			edges.push([0,3, 0.01]);
			edges.push([0,4, 0.05]);
			edges.push([0,5, 0.01]);
// edges.push([0,5, 0.5]);
// edges.push([0,5, 0.001]);
		edges.push([1,2, 0.01]);
		edges.push([1,3, 0.03]);
			edges.push([1,4, 0.02]);
			edges.push([1,5, 0.01]);

		edges.push([2,3, 0.1]);
			edges.push([2,4, 0.03]);
			edges.push([2,5, 0.02]);

		edges.push([3,4, 0.04]);
			edges.push([3,5, 0.05]);

		edges.push([4,5, 0.02]);

	var max = 3;
	for(var i=0; i<edges.length; ++i){
		if(edges[i][0]>max || edges[i][1]>max){
			Code.removeElementAt(edges,i);
			--i;
		}
	}
	var graph = new Graph();
	var vs = [];
	for(var i=0; i<points.length; ++i){
		var v = graph.addVertex();
		v.data([i,points[i],null]);
		vs[i] = v;
	}
	var es = [];
	// var relativeEdges = [];
	// var relativeLocations = [];
	var pairs = [];
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var a = edge[0];
		var b = edge[1];
		var error = edge[2];
			error = error;
		var w = 1.0/Math.max(error,1E-6);
		var va = vs[a];
		var vb = vs[b];
		var pa = points[a][0];
		var pb = points[b][0];
		var ra = points[a][1];
		var rb = points[b][1];
		var e = graph.addEdge(va,vb, w, Graph.Edge.DIRECTION_DUPLEX);
		var vector = V3D.sub(pb,pa);
		//
		var rainv = ra.copy().qInverse().qNorm();
		var rab = V4D.qMul(rb,rainv);
console.log("EDGE: "+a+"->"+b+" = "+rab);
var tt = Code.vectorTwistFromQuaternion(rab);
console.log("   "+ra+" && "+rb);
var ta = Code.vectorTwistFromQuaternion(ra);
var tb = Code.vectorTwistFromQuaternion(rb);
console.log("   "+ta["direction"]+" @ "+Code.degrees(ta["angle"])+" && "+tb["direction"]+" @ "+Code.degrees(tb["angle"]));
console.log("       TWIST: "+tt["direction"]+" @ "+Code.degrees(tt["angle"]));
		// var b = V4D.qMul(rab,ra);

		var errorAngle = error * 1.0;
		var errorLocation = error * 1.0;
		// var errorAngle = error * 3.0;
		// var errorLocation = error * 3.0;
		error = errorLocation;
		// location
		vector.add( Code.randomFloat(-errorLocation,errorLocation), Code.randomFloat(-errorLocation,errorLocation) , Code.randomFloat(-errorLocation,errorLocation) );
		// rotation
		var q = V4D.qIdentity().qRotateDir( new V3D().random(1.0).norm(), Code.randomFloat(-errorAngle,errorAngle) );
		rab = V4D.qMul(q,rab);
		// save
		e.data([va,vb,vector,rab,error]);
		es[i] = e;
		var transform = V4D.qMatrix(rab,new Matrix(3,3));
		transform.appendColFromArray(vector.toArray());
		transform.appendRowFromArray([0,0,0,1]);
		pairs[i] = [a,b,transform, error];
	}

	// initial estimation:
	var root = vs[0];
	var origin = points[0][0];
	var originQ = points[0][1];
	var locations = [];
	var rotations = [];
	locations.push(origin);
	rotations.push(originQ);
	for(var i=1; i<vs.length; ++i){
		var target = vs[i];
		var path = graph.minPath(root,target);
		var edges = path["edges"];
		var vertex = root;
		var location = origin.copy();
		var rotation = originQ.copy();
		var sigma = 0;
		for(var j=0; j<edges.length; ++j){
			var edge = edges[j];
			// console.log(edge.data()[0].data()[0]+" to "+edge.data()[1].data()[0]);
			var data = edge.data();
			var va = data[0];
			var vb = data[1];
			var dir = data[2];
			var qua = data[3];
			var error = data[4];
			// console.log("QUA: "+qua);
			sigma = sigma + error;
			if(vb==vertex){ // invert direction
				qua = qua.copy().qInverse().qNorm();
				dir = dir.copy().scale(-1);
			}
			//
			location.add(dir);
			console.log(qua,rotation)
			rotation = V4D.qMul(qua,rotation);
			vertex = edge.opposite(vertex);
		}
		locations.push(location);
		rotations.push(rotation);
		vertex.data()[2] = location;
		vertex.data()[3] = rotation;
	}
var locationsA = locations;
var rotationsA = rotations;
// console.log(locationsA);
// throw "?"

	var SCA = 100.0;
	var OFFX = 40;
	var OFFY = 60;
	// actual - GREEN
	for(var i=0; i<locations.length; ++i){
		var location = points[i][0];
		// var angle = points[i][1];
		var angle = 0; // TODO
		var rad = 25.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFF004400);
			d.graphics().setFill(0x6600FF00);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			// d.graphics().fill();
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);
	}

	// estimated (initial naive guess) - RED
	for(var i=0; i<locations.length; ++i){
		var location = locations[i];
		// var angle = rotations[i];
		var angle = 0; // TODO
		var rad = 28.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFFFF0000);
			d.graphics().setFill(0x66FF0000);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			// d.graphics().fill();
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);
	}

var result = R3D.optimumTransform3DFromRelativePairTransforms(pairs);
console.log(result);
var absolutes = result["absolute"];
// throw "?";
var locations = [];
var rotations = [];
for(var i=0; i<absolutes.length; ++i){
	var absolute = absolutes[i];
console.log(absolute)
	var location = absolute.multV3DtoV3D(new V3D(0,0,0));
	var rotation = V4D.qFromMatrix(absolute);
	rotations.push(rotation);
	locations.push(location);
}


	// INITIAL OFFSET FOR COMPARISON
	var root = points[0];
	var rootLocation = root[0];
	var rootQuaternion = root[1]; // ROOT FROM RESULT MIGHT NOT BE 0 ...

	// var tR = Code.vectorTwistFromQuaternion(rootQuaternion);
	// rootQuaternion = Code.quaternionFromVectorTwist(tR);

console.log(rootQuaternion+".....");

	// rootQuaternion = rootQuaternion.copy().qInverse();
	for(var i=0; i<rotations.length; ++i){
		var absolute = rotationsA[i];
		var rotation = rotations[i];
		// APPLY INVERSE TO SOURCE
		var original = V4D.qMul(rotation,V4D.qIdentity());
		var absolute = V4D.qMul(absolute,rootQuaternion.copy().qInverse());

		// APPLY CHANGE TO RESULT
		// var original = V4D.qMul(rotation,rootQuaternion);
		// var absolute = V4D.qMul(absolute,V4D.qIdentity());

		console.log("  "+i+"  "+rotation);
		// console.log("      =  "+Code.vectorTwistFromQuaternion(rotation)["direction"]);
		// console.log("      =  "+Code.vectorTwistFromQuaternion(rotations[i].copy().qInverse())["direction"]);
		console.log("   A  "+absolute);
		// console.log("    "+V4D.qMul(rootQuaternion,rotations[i]));
		console.log("   ?  "+original);
		// console.log("   ?  "+V4D.qMul(rotations[i].copy().qInverse(),rootQuaternion));
		// console.log("      O?  "+Code.vectorTwistFromQuaternion( V4D.qMul(rotation.copy().qInverse(),rootQuaternion) )["direction"]);
				var twist = Code.vectorTwistFromQuaternion(absolute);
			console.log("  t: "+twist["direction"]+" @ "+Code.degrees(twist["angle"]));
			twist = Code.vectorTwistFromQuaternion(original);
			console.log("  t: "+twist["direction"]+" @ "+Code.degrees(twist["angle"]));
		console.log("  ");
	}
	// FINAL ESTIMATION - BLUE
	for(var i=0; i<locations.length; ++i){
		var location = locations[i];
		var rotation = rotations[i];
		location = V3D.add(location, rootLocation);
		// rotation = V4D.qMul(rotation, rootQuaternion);
		var angle = 0; //
		var rad = 30.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFF0000CC);
			d.graphics().setFill(0x6600FF00);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);
	}
	for(var i=0; i<locations.length; ++i){
		// known
		var location = points[i][0];
		var rotation = points[i][1];
		// estimated
		var loc = locations[i];
		var rot = rotations[i];
		rotation = V4D.qMul(rotation, rootQuaternion.copy().qInverse());
		// location diff
		loc = loc.copy().add(rootLocation);
		var distance = V3D.distance(location,loc);
		// estimate error
		var axisA = Code.axisFromQuaternion(rotation);
		var axisB = Code.axisFromQuaternion(rot);
		var errorAxis = R3D._gdErrorAxisAngles3D(axisA[0],axisA[1],axisA[2], axisB[0],axisB[1],axisB[2]);
		var avgAngle = Math.sqrt(errorAxis);
		// var diffA = Code.degrees(diff["angle"]);
		// var diffDir = V3D.angle(diff["direction"],rot["direction"]);// V3D.dot(twist["direction"],rot["direction"]);
		// var diffB = V3D.angle(V3D.DIRZ,diff["direction"]);
		// diffB = Code.degrees(diffB);
		//console.log("TWIST: "+Code.degrees(diffDir)+" & "+Code.degrees(diffAng)+"   --- DISTANCE: "+distance);
		// @  dot: "+diffB+" deg
		console.log("ERROR:  ANGLE: "+Code.degrees(avgAngle)+"   DISTANCE: "+distance);
	}


// throw "TESTING";
// return;




/*
	var points = [];
		// points.push([new V2D(0,0), 0.0]);
		// points.push([new V2D(2,0), 0.0]);
		// points.push([new V2D(3,0), 0.0]);
		// points.push([new V2D(5,0), 0.0]);
		// points.push([new V2D(7,0), 0.0]);
		points.push([new V3D(0,0,0), Code.radians(0.0)]);
		points.push([new V3D(2,1,0), Code.radians(20.0)]);
		points.push([new V3D(3,0,0), Code.radians(30.0)]);
		points.push([new V3D(5,2,0), Code.radians(20.0)]);
		points.push([new V3D(7,0,0), Code.radians(40.0)]);
		points.push([new V3D(1,3,0), Code.radians(90.0)]);
	var edges = [];
		edges.push([0,1, 0.1]);
		edges.push([0,2, 0.5]);
			edges.push([0,3, 0.1]);
			edges.push([0,4, 0.5]);
			edges.push([0,5, 0.1]);
// edges.push([0,5, 0.5]);
// edges.push([0,5, 0.001]);

		edges.push([1,2, 0.5]);
		edges.push([1,3, 0.3]);
			edges.push([1,4, 0.2]);
			edges.push([1,5, 0.1]);

		edges.push([2,3, 0.5]);
			edges.push([2,4, 0.3]);
			edges.push([2,5, 0.2]);

		edges.push([3,4, 0.4]);
			edges.push([3,5, 0.5]);

		edges.push([4,5, 0.2]);



	var graph = new Graph();
	var vs = [];
	for(var i=0; i<points.length; ++i){
		var v = graph.addVertex();
		v.data([i,points[i],null, ]);
		vs[i] = v;
	}
	var es = [];
var relativeEdges = [];
var relativeLocations = [];
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var a = edge[0];
		var b = edge[1];
		var error = edge[2];
			error = error;
		var w = 1.0/Math.max(error,1E-6);
		var va = vs[a];
		var vb = vs[b];
		var pa = points[a][0];
		var pb = points[b][0];
		var ra = points[a][1];
		var rb = points[b][1];
		var e = graph.addEdge(va,vb, w, Graph.Edge.DIRECTION_DUPLEX);
		var vector = V3D.sub(pb,pa);
		var angle = Code.angleDirection(ra,rb);
var errorAngle = error * 3.0;
var errorLocation = error * 3.0;
// console.log("errorLocation: "+errorLocation);
// errorLocation *= 0.001;
		// var angle = Code.angleDifference(ra,rb);
		// console.log(Code.degrees(ra)+" & "+Code.degrees(rb)+" = "+Code.degrees(angle));
		var len = vector.length();
		len = 1.0;
		vector.add( Code.randomFloat(-errorLocation,errorLocation)*len, Code.randomFloat(-errorLocation,errorLocation)*len , Code.randomFloat(-errorLocation,errorLocation)*len*0 );
		angle += Code.randomFloat(-errorAngle,errorAngle)
		e.data([va,vb,vector,angle,error]);
		es[i] = e;
		//relativeEdges[i] = [a,b,angle,errorAngle];
			var twist = {"direction":new V3D(0,0,1),"angle":angle};
			relativeEdges[i] = [a,b,twist,errorAngle];
		relativeLocations[i] = [a,b,vector,errorLocation];
	}


	// initial estimation:
	var root = vs[0];
	var origin = new V3D(0,0,0);
	var locations = [];
	var rotations = [];
	locations.push(origin);
	rotations.push(0);
	for(var i=1; i<vs.length; ++i){
		var target = vs[i];
		var path = graph.minPath(root,target);
		var edges = path["edges"];
		var vertex = root;
		var location = origin.copy();
		var rotation = 0;
		var sigma = 0;
		for(var j=0; j<edges.length; ++j){
			var edge = edges[j];
			var data = edge.data();
			var va = data[0];
			var vb = data[1];
			var dir = data[2];
			var angle = data[3];
			var error = data[4];
			sigma = sigma + error;
			if(vb==vertex){ // invert direction
				angle = -angle;
				dir = dir.copy().scale(-1);
			}
			vertex = edge.opposite(vertex);
			location.add(dir);
			rotation += angle;
		}
		console.log("LOCATION: "+i+" = "+location+" @ "+Code.degrees(rotation));
		// console.log("LOCATION: "+i+" = "+location);
		rotation = Code.angleZeroTwoPi(rotation);
		locations.push(location);
		rotations.push(rotation);
		vertex.data()[2] = location;
		vertex.data()[3] = rotation;
	}

	var SCA = 100.0;
	var OFFX = 40;
	var OFFY = 60;
	// actual
	for(var i=0; i<locations.length; ++i){
		var location = points[i][0];
		var angle = points[i][1];
		var rad = 25.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFF004400);
			d.graphics().setFill(0x6600FF00);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			// d.graphics().fill();
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);
	}

	// estimated
	for(var i=0; i<locations.length; ++i){
		var location = locations[i];
		var angle = rotations[i];
		var rad = 28.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFFFF0000);
			d.graphics().setFill(0x66FF0000);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			// d.graphics().fill();
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);
	}

	var results = R3D.optiumGraphAngle2D(relativeEdges);
	console.log(results);
	rotations = results["absolute"];






	var results = R3D.optiumGraphLocation2D(relativeLocations);
	console.log(results);
	locations = results["absolute"];



	console.log("relativeLocations");
	console.log(relativeLocations);

	console.log("locations");
	console.log(locations);

	var result = R3D.optiumGraphLocation3D(relativeLocations);
	// var result = R3D.optimumGraphLocation3DLeastSquares(relativeLocations);
	console.log("result");
	console.log(result);
	locations = result["absolute"];
	console.log("locations");
	console.log(locations);


	var results = R3D.optiumGraphAngle3D(relativeEdges);
	console.log(results);
	rotations = results["absolute"];



	// SHOW AGAIN:
	for(var i=0; i<locations.length; ++i){
		var location = locations[i];
		var rot = rotations[i];
		console.log(rot);
		var angle = rot["angle"];
		var rad = 30.0;
		var d = new DO();
			d.graphics().setLine(1.0,0xFF0000CC);
			d.graphics().setFill(0x6600FF00);
			d.graphics().beginPath();
			d.graphics().drawCircle(0,0, rad);
			d.graphics().moveTo(0,0);
			d.graphics().lineTo(rad*Math.cos(angle),rad*Math.sin(angle));
			// d.graphics().fill();
			d.graphics().strokeLine();
			d.graphics().endPath();
		d.matrix().translate(OFFX,OFFY);
		d.matrix().translate(location.x*SCA,location.y*SCA);

		GLOBALSTAGE.addChild(d);

	}


throw "TESTING";
return;

*/

	// paths = graph.minPath(vs[0],vs[3]);
	// console.log(paths);

	/*
		graph use squared error as edge weights

		find root with minimized total error at leaves
			- get shortest paths to all vertexes & sum all paths

????

		calculate absolute positions from root

		iterate till convergence: (GD)
			relative = edge_ab
			calculated = (absB-absA) [inverse]

			error_t = distance from centers

			error_r = angle ?



			error += ^2 * sigma
			=> update absolute positions


	*/


	// var vertexes = [];
	// for(var i=0; i<4; ++i){
	// 	var v = graph.addVertex();
	// 	vertexes[i] = v;
	// }
	// var a = vertexes[0];
	// var b = vertexes[1];
	// var c = vertexes[2];
	// var d = vertexes[3];
	// a.data("A");
	// b.data("B");
	// c.data("C");
	// d.data("D");
	// var ab = graph.addEdge(a,b, 1, Graph.Edge.DIRECTION_DUPLEX);
	// var bc = graph.addEdge(a,b, 1, Graph.Edge.DIRECTION_DUPLEX);
	// var bd = graph.addEdge(a,b, 1, Graph.Edge.DIRECTION_DUPLEX);
	// var ab = graph.addEdge(a,b, 1, Graph.Edge.DIRECTION_DUPLEX);
	// 	ab.data(new V2D(2,0));
	// 	bc.data(new V2D(1,0));
	// 	bd.data(new V2D(1,0));
	// 	cd.data(new V2D(1,0));

/*
	error:
		| relAB - (absA-absB) |^2
*/

	// return;

/*
	var imageWidth = 500;
	var imageHeight = 350;
	var f = (imageWidth+imageHeight)*0.5;
	var fx = f;
	var fy = f;
	var s = 0;
	var cx = 0.5*imageWidth;
	var cy = 0.5*imageHeight;
	var distortion = null;
	var K = new Matrix(3,3).fromArray([fx,s,cx, 0,fy,cy, 0,0,1]);
	var Kinv = Matrix.inverse(K);
	var identity = new Matrix(4,4).identity();

	// actual point movement
		var mat = new Matrix(4,4).identity();
		mat = Matrix.transform3DTranslate(mat, -1,0,0);
			mat = Matrix.transform3DRotateY(mat, Code.radians(-10.0));
	var absA = mat;

		var mat = new Matrix(4,4).identity();
			mat = Matrix.transform3DTranslate(mat, 1,0,0);
			mat = Matrix.transform3DRotateY(mat, Code.radians(10.0));
	var absB = mat;

	// actual camera movement
	var invA = Matrix.inverse(absA);
	var invB = Matrix.inverse(absB);

	// point movement
	var transAB = Matrix.mult(absB,invA);
	// camera movement
	var transBA = Matrix.inverse(transAB);

	var Fab = R3D.fundamentalFromCamera(transAB, K, Kinv);
	var Fba = R3D.fundamentalInverse(Fab);//R3D.fundamentalFromCamera(transBA, K, Kinv);

	var point3D = new V3D(1,1,-20);

	var point2DA = R3D.projectPoint3DToCamera2DForward(point3D, absA, K, null);
	var point2DB = R3D.projectPoint3DToCamera2DForward(point3D, absB, K, null);

	// ORIGINAL:
	//var estimated3D = R3D.triangulatePointDLT(point2DA,point2DB, absA,absB, Kinv, Kinv);

	// REPLACE
	var estimated3D = R3D.triangulatePointDLT(point2DA,point2DB, identity,transAB, Kinv, Kinv);

var error = R3D.reprojectionError(estimated3D, point2DA,point2DB, identity, transAB, K, K);
console.log("reprojection error: "+error["error"]);

		invA.multV3DtoV3D(estimated3D,estimated3D);

	// NOT WORK:
	// var estimated3D = R3D.triangulatePointDLT(point2DA,point2DB, identity,transBA, Kinv, Kinv);
	// 	absA.multV3DtoV3D(estimated3D,estimated3D);


			//transAB.multV3DtoV3D(estimated3D,estimated3D);

	console.log("          ..."+estimated3D+" =?= "+point3D);





	// var rayA = R3D.projectPoint2DToCamera3DRay(point2DA, absA, Kinv, null);
	// var rayB = R3D.projectPoint2DToCamera3DRay(point2DB, absB, Kinv, null);
	var rayA = R3D.projectPoint2DToCamera3DRay(point2DA, invA, Kinv, null);
	var rayB = R3D.projectPoint2DToCamera3DRay(point2DB, invB, Kinv, null);

	var closest = Code.closestPointsLines3D(rayA["o"],rayA["d"], rayB["o"],rayB["d"]);
	var avg = V3D.avg(closest[0],closest[1]);
	console.log(avg+"");
	// console.log(avg.x/point3D.x,avg.y/point3D.y,avg.z/point3D.z);

console.log(Kinv+"")

var distance3D = V3D.distance(estimated3D,point3D);
console.log("distance3D: "+distance3D);
if(distance3D>1E-6){
	console.log(closest)
	console.log(" point2DA: "+point2DA);
	console.log(" point2DB: "+point2DB);
	console.log(" point3D: "+point3D);
	console.log(" estimated3D: "+estimated3D);

	throw "not match";
}




// NONLINEAR OPTIMIZING:
	points3D = [];
	points3D.push(new V3D(0,0,10));

	points3D.push(new V3D(0,-1,7));
	points3D.push(new V3D(-1,0,7));
	points3D.push(new V3D(-1,-1,7));

	points3D.push(new V3D(0,-10,10));
	points3D.push(new V3D(-10,0,10));
	points3D.push(new V3D(-10,-10,10));

	points3D.push(new V3D(1,0,12));
	points3D.push(new V3D(0,1,12));
	points3D.push(new V3D(1,1,12));

	points3D.push(new V3D(0,10,11));
	points3D.push(new V3D(10,0,11));
	points3D.push(new V3D(10,10,11));

	// var errorPixels = 2;
	var errorPixels = 1;
	// var errorPixels = 0;
	// var badCount = 0;
	// var badCount = 1;
	var badCount = Math.floor(points3D.length*0.5);


console.log("nonlinearness");
	cameras = [absA,absB];
	points2DA = [];
	points2DB = [];
	points2D = [points2DA,points2DB];
	for(var i=0; i<points3D.length; ++i){
		var point3D = points3D[i];
		var list = [];
		for(var j=0; j<cameras.length; ++j){
			var camAbs = cameras[j];
			var point2D = R3D.projectPoint3DToCamera2DForward(point3D, camAbs, K, null, true);
			console.log(i+" "+point2D);
			points2D[j].push(point2D);
			// console.log(points2D[j])
			if(point2D){
				point2D.add(Math.random()*errorPixels,Math.random()*errorPixels);
				// list.push(point2D);
			}
			list.push(point2D);
		}
	}
	console.log("MATCHES BEFORE: "+points2DA.length);
	// add bad points:
	for(var i=0; i<badCount; ++i){
		for(var j=0; j<cameras.length; ++j){
			points2D[j].push(new V2D(Math.random()*imageWidth,Math.random()*imageHeight) );
		}
	}
	console.log("MATCHES ERROR: "+points2DA.length);



	var F = null;
	var P = null;
	var Ka = K;
	var Kb = K;
	var KaInv = Matrix.inverse(Ka);
	var KbInv = Matrix.inverse(Kb);


	// TODO: WHERE DOES TRHESHOLD ERROR COME FROM ?


	var inlierPixelError = 2;
	var result = R3D.fundamentalRANSACFromPoints(points2DA,points2DB, inlierPixelError);
	// console.log(result);
	F = result["F"];
	console.log(F+"");

	var matches = result["matches"];
	points2DA = matches[0];
	points2DB = matches[1];
	console.log("MATCHES AFTER: "+points2DA.length);
	//F = R3D.fundamentalFromUnnormalized(points2DA,points2DB);

	// F = R3D.fundamentalMatrixNonlinear(F,points2DA,points2DB);
	// console.log(F+"");

	// TODO: RANSAC P drop points

	//P = R3D.transformFromFundamental(points2DA,points2DB, F, Ka, Kb, null, true);

	// TODO: WHERE DOES TRHESHOLD ERROR COME FROM ?
	result = R3D.cameraExtrinsicRANSACFromPointsAutomated(points2DA,points2DB,Ka,Kb,KaInv,KbInv);

	P = result["P"];
	console.log(P+"");


	console.log(P);

throw "yerp"

	var Pa = new Matrix(4,4).identity();
	var Pb = P;

	// NONLINEAR OPTIMIZING:
		var Ps = [Pa,Pb];
		var Ks = [Ka,Kb];
		var Is = [KaInv,KbInv];
		var points2D = [points2DA,points2DB];

		// TODO:
		var estimated3D = [];
		for(i=0; i<points2DA.length; ++i){
			var pA = points2DA[i];
			var pB = points2DB[i];
			var p3D = R3D.triangulatePointDLT(pA,pB, Pa,Pb, KaInv, KbInv);
			estimated3D.push(p3D);
		}
		// // points3D =  estimated
		// var estimated3D = R3D.triangulatePointDLT(pA,pB, cameraA,cameraB, KaInv, KbInv);
		// match.estimated3D(estimated3D);


		var result = R3D.BundleAdjustCameraExtrinsic(Ks, Is, Ps, points2D, estimated3D, 25);
		console.log(result);
		var extrinsics = result["extrinsics"];
		var absA = extrinsics[0];
		var absB = extrinsics[1];

		// var invA = Matrix.inverse(absA);
		// var relativeAtoB = Matrix.mult(invA,absB);
		// var absoluteB = Matrix.mult(Pa,relativeAtoB);
		// viewB.absoluteTransform(absoluteB);


	return;

*/


	/*
	console.log("test combining");


	var viewA = new Matrix(4,4).identity();
		viewA = Matrix.transform3DTranslate(viewA, 1,1,1);

	var viewB = new Matrix(4,4).identity();
		viewB = Matrix.transform3DTranslate(viewB, 1,2,3);
		viewB = Matrix.transform3DRotateY(viewB, Code.radians(30.0));
		viewB = Matrix.transform3DRotateX(viewB, Code.radians(15.0));

	var viewC = new Matrix(4,4).identity();
		viewC = Matrix.transform3DTranslate(viewC, -2,-2,-2);
		viewC = Matrix.transform3DRotateY(viewC, Code.radians(10.0));
		viewC = Matrix.transform3DRotateX(viewC, Code.radians(-10.0));

	var invA = Matrix.inverse(viewA);
	var invB = Matrix.inverse(viewB);
	var invC = Matrix.inverse(viewC);
	// var transformAB = Matrix.mult(invA,viewC);
	// var transformAC = Matrix.mult(invA,viewB);
	// var transformBC = Matrix.mult(invB,viewC);
	var transformAB = Matrix.mult(viewB,invA);
	var transformAC = Matrix.mult(viewC,invA);
	var transformBC = Matrix.mult(viewC,invB);

	// ?

	var point1 = new V3D(0,0,0);

	var point1A = invA.multV3DtoV3D(point1);
	var point1B = invB.multV3DtoV3D(point1);
	var point1C = invC.multV3DtoV3D(point1);

	console.log(" POINT IN RESPECTIVE FRAMES OF REFERENCE: inv_i(p_abs) = p_i");
	console.log("point1: "+point1);
	console.log("point1A: "+point1A);
	console.log("point1B: "+point1B);
	console.log("point1C: "+point1C);
	console.log("...............................");


	var point2 = new V3D(0,0,0);
	var point2A = viewA.multV3DtoV3D(point2);
	var point2B = viewB.multV3DtoV3D(point2);
	var point2C = viewC.multV3DtoV3D(point2);


	console.log(" POINT IN ABSOLUTE FRAME OF REFERENCE: fwd_i(p_i) = p_abs");
	console.log("point2: "+point2);
	console.log("point2A: "+point2A);
	console.log("point2B: "+point2B);
	console.log("point2C: "+point2C);
	console.log("...............................");

	var point3 = new V3D(0,0,0);

	var point3A = viewA.multV3DtoV3D(point3);
		point3A_AB = transformAB.multV3DtoV3D(point3A);
		point3A_AC = transformAC.multV3DtoV3D(point3A);
	var point3B = viewB.multV3DtoV3D(point3);
		point3B_BC = transformBC.multV3DtoV3D(point3B);

	console.log(" POINTS VIA RELATIVE PATHS:");
	console.log("point3: "+point3);
	console.log("point3A: "+point3A);
	console.log("point3A_AB: (B) "+point3A_AB);
	console.log("point3A: "+point3A);
	console.log("point3A_AC: (C) "+point3A_AC);
	console.log("point3B: "+point3B);
	console.log("point3B_BC: (C) "+point3B_BC);

	console.log("...............................");


	//console.log("point1AB: "+point1AB);


	return;
	*/


	/*
	var handleEnterFrameFxn = function(e){
		// console.log(e)
	}

	var canvas = new Canvas(null,0,0,Canvas.STAGE_FIT_FILL, false,false, true);
	var stage = new Stage(canvas, 1000/20);
	var root = new DO();
	stage.addChild(root);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_CLICK,this._handleMouseClickFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_DOWN,this._handleMouseDownFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_UP,this._handleMouseUpFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_EXIT,this._handleMouseUpFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_MOVE,this._handleMouseMoveFxn,this);

	//this._canvas.addFunction(Canvas.EVENT_MOUSE_CLICK,this._handleMouseClickFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_TOUCH_START,this._handleMouseDownFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_TOUCH_END,this._handleMouseUpFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_TOUCH_MOVE,this._handleMouseMoveFxn,this);
	// this._canvas.addFunction(Canvas.EVENT_WINDOW_RESIZE,this._handleCanvasResizeFxn,this);
	stage.addFunction(Stage.EVENT_ON_ENTER_FRAME,handleEnterFrameFxn,this);
	canvas.addListeners();
	stage.addListeners();
	stage.start();

	var renderer = new Render3D(new V2D(600,400));
	var cam3D = renderer.addCamera();
	root.addChild(renderer.display());

	var points = [];
	var s = 1;
	for(var i=0; i<100; ++i){
		var p = new V3D(Math.random()*s,Math.random()*s,Math.random()*s);
		points.push(p);
	}

	var info = V3D.infoFromArray(points);
	cam3D.position();
	cam3D.position();

	renderer.clear();
	renderer.renderPoints(points);


	return;
	*/
/*
	var angleX = Math.random()*Math.PI2;
	var angleY = Math.random()*Math.PI2;
	var angleZ = Math.random()*Math.PI2;
	//
	var R, Q, transform;
	transform = new Matrix(4,4).identity();
	transform = Matrix.transform3DRotateX(transform, angleX);
	transform = Matrix.transform3DRotateY(transform, angleY);
	transform = Matrix.transform3DRotateZ(transform, angleZ);
	R = transform.getSubMatrix(0,0, 3,3);
	R = R3D.rotationFromApproximate(R);

	var rodrigues = R3D.rotationMatrixToEulerRodriguez(R);
	var transform = R3D.rotationEulerRodriguezToMatrix(rodrigues);
	var Q = transform.getSubMatrix(0,0, 3,3);
	var D = Matrix.sub(R,Q);
		D = Matrix.abs(D);
	console.log(R+"");
	console.log(Q+"");
	console.log(D+"");

	return;
*/


	/*
	var g = new Graph();
	var v = [];

	//for(var i=0; i<10; ++i){
	for(var i=0; i<7; ++i){
		var u = g.addVertex();
		v[i] = u;
	}
	g.addEdgeDuplex(v[0],v[1], 1); // 0
	g.addEdgeDuplex(v[0],v[6], 4); // 1
	g.addEdgeDuplex(v[1],v[2], 2); // 2
	g.addEdgeDuplex(v[1],v[3], 3); // 3
//g.addEdgeDuplex(v[2],v[5], 0); // TEST
	g.addEdgeDuplex(v[3],v[4], 1); // 4
	g.addEdgeDuplex(v[4],v[5], 1); // 5
	g.addEdgeDuplex(v[5],v[6], 2); // 6
	// g.addEdgeDuplex(v[7],v[8], 1); // 7
	// g.addEdgeDuplex(v[8],v[9], 2); // 8
	// g.addEdgeDuplex(v[],v[], );

	var sets = Graph._disjointSets(g);
	console.log(sets);

	var set = sets[0];

	var paths = Graph._minPaths(g, v[0]);

	console.log(paths);

	for(i=0; i<paths.length; ++i){
		var path = paths[i];
		var vertex = path["vertex"];
		var cost = path["cost"];
		var path = path["path"];
		console.log(vertex+" = "+cost+" @ len: "+path.length);
	}


	var minRoot = Graph._minRootPaths(g);
	console.log(minRoot);


	return;
	*/
	/*
	var t = new Tensor([3,3,3]);
	console.log(t);
	console.log(t+"");
	console.log("FR ");
	var a = [];
	for(var i=0; i<27; ++i){
		a[i] = i;
	}
	t.fromArray(a);
	console.log("TO ");
	console.log(t.toArray());
	console.log("GET ");
	console.log(t.get([0,1,2]));

	console.log("SET ");
	console.log(t.set([0,1,2], 99));

	console.log("SET ");
	console.log(t.set([2,2,2], 0));

	console.log("TO ");
	console.log(t.toArray());
	return;
	*/
/*
	var pointsA = [
				new V2D(86,208), // glasses corner left
				new V2D(190,180), // glasses corner right
				new V2D(172,107), // origin
				new V2D(22.5,166), // lighter button
				new V2D(361,183), // mouse eye
				new V2D(18,225), // bic corner left
				new V2D(37,216), // bic corner right
				new V2D(65,169), // cup
				new V2D(226,87), // face BL
				new V2D(219,66), // glasses TL
				new V2D(250,72), // glasses TR
				new V2D(260,103), // elbow
				new V2D(216,154), // toe left
				new V2D(245,158), // toe right
				new V2D(202,127), // brick
				new V2D(240,248), // 12
				new V2D(332,249), // 16
				new V2D(145,203), // glasses center
				new V2D(172,68), // grid top
				new V2D(141,76), // grid TL
				new V2D(204,75), // grid TR
				new V2D(144,119), // grid BL
				new V2D(175,128), // grid bot
				new V2D(362,213), // U
				new V2D(326,176), // tail
				new V2D(190,173), // base left
				new V2D(265,178), // base right
				new V2D(372,181), // nose
				new V2D(129,88), // power top
				new V2D(132,141), // power bot
				new V2D(62,107), // cup
				new V2D(94,176), // glass tip left
				new V2D(131,166), // glass tip right
			];
var pointsB = [
				new V2D(87,192),
				new V2D(170,178),
				new V2D(212,46),
				new V2D(50,149),
				new V2D(278,241),
				new V2D(52,179), // left
				new V2D(64,172), // right//new V2D(18,225), // right
				new V2D(94,124),
				new V2D(225,98), // face BL
				new V2D(221,80), // glasses TL
				new V2D(246,95), // glasses TR
				new V2D(250,121),
				new V2D(214,139), // tow left
				new V2D(237,150), // toe right
				new V2D(213,106), // brick
				new V2D(180,252), // 12
				new V2D(245,271), // 16
				new V2D(131,193), // glasses center
				new V2D(213,12), // grid top
				new V2D(177,26), // grid TL
				new V2D(239,33), // grid TR
				new V2D(180,61), // grid BL
				new V2D(202,83), // grid bot
				new V2D(282,251), // U
				new V2D(256,225), // tail
				new V2D(187,153), // base left
				new V2D(245,173), // base right
				new V2D(290,240), // nose
				new V2D(150,63), // power top
				new V2D(155,100), // power bot
				new V2D(85,92), // cup
				new V2D(113,138), // glass tip left
				new V2D(145,132), // glass tip right
			];
var pointsAin = pointsA;
var pointsBin = pointsB;

	var pointsA = [];
	var pointsB = [];
	for(i=0; i<pointsAin.length; ++i){
		pointsA[i] = new V3D(pointsAin[i].x,pointsAin[i].y,1.0);
		pointsB[i] = new V3D(pointsBin[i].x,pointsBin[i].y,1.0);
	}

	var pointsANorm = R3D.calculateNormalizedPoints([pointsA]);
	var pointsBNorm = R3D.calculateNormalizedPoints([pointsB]);
	var pA = pointsANorm.normalized[0];
	var pB = pointsBNorm.normalized[0];



	var Fnrm = R3D.fundamentalMatrix(pA,pB);
	var Floc = Fnrm.copy();
	Floc = Matrix.mult(Floc, pointsANorm.forward[0]);
	Floc = Matrix.mult(Matrix.transpose(pointsBNorm.forward[0]), Floc);

	console.log(Floc+"");


	var error = R3D._gdFun([pointsA,pointsB], Floc.toArray(), false);
	var averageError = error/pointsA.length;
	console.log("1 F AVG ERROR: "+error+" == "+averageError);
var errorA = averageError;




	var Fnext = Fnrm;
	//var Fnext = R3D.fundamentalMatrixNonlinearGD(Fnrm, pA, pB);
	//Fnext = R3D.forceRank2F(Fnext);

	for(i=0; i<3; ++i){
		//console.log("LM");
		Fnext = R3D.fundamentalMatrixNonlinearLM(Fnext, pA, pB);
		//console.log("GD");
		Fnext = R3D.fundamentalMatrixNonlinearGD(Fnext, pA, pB);
	}

//	Fnext = R3D.fundamentalMatrixNonlinearGD(Fnext, pA, pB);
// }catch(e){
// 	console.log("??? "+e);
// }
	//Fnext = R3D.forceRank2F(Fnext);

	// GD: 0.8771833241544938
	// LM: 0.9928658790461447
	// GD+LM: 0.87718
	// LM+GD: 0.876840
	// 2x.  : 0.8727416521415238
	// 10x. : 0.871342
	// 0.8702023724746977
	//Fnext = R3D.forceRank2F(Fnext);
	//  0.8711342044146368
	Floc = Fnext.copy();
	Floc = Matrix.mult(Floc, pointsANorm.forward[0]);
	Floc = Matrix.mult(Matrix.transpose(pointsBNorm.forward[0]), Floc);
	console.log(Floc+"");




	var error = R3D._gdFun([pointsA,pointsB], Floc.toArray(), false);
	var averageError = error/pointsA.length;
	console.log("2 F AVG ERROR: "+error+" == "+averageError);
var errorB = averageError;

	console.log(" DELTA ERROR: "+(errorB/errorA));
	return;
*/


/*
	console.log(Code.appendToPath("a","b","c") );
	console.log(Code.appendToPath("a","b") );
	console.log(Code.appendToPath("/","a") );
	console.log(Code.appendToPath("/","a/") );
	console.log(Code.appendToPath("/","/a/","/b/") );
	return;
*/
	//var client = new ClientFile();
	// http://localhost/ff/3DR/app/app.html
	/*
	var text = "test string to save\nto a file";
	var binary = Code.stringToBinary(text);
	console.log(text);
	console.log(binary);
	client.set("test.txt", binary);
	return;
	*/



// var client = new ClientFile();
// 	client.del("projects/0/MZT6OFNF/50.png");
// 	return;
	// var client = new ClientFile();
	// client.set("projects/0");
	// return;


// 	client.get("projects/test1.png");
// return;
	//client.get("images/background.php");
	//client.get("test.png");
	//client.get("test3.png");
	//client.get("test5.png");
	//client.get("/");
/*
	var base64 = "iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAaElEQVR4nO3VMQqAQBAEwVnx/18+c9esQSboDpcLCkFmkpy8OmedMjPr9se7a13KEkirB95NP8TXu/ovKJBWD5y4JCyBtHqgS0ITSKsHuiQ0gbR6oEtCE0irB7okNIG0eqBLQhNIqwc+4L9kRXekVq0AAAAASUVORK5CYII=";
	console.log(base64);
	var binary = Code.base64StringToBinary(base64);
	//console.log(binary);
	console.log(binary);
	console.log(Code.binaryToBase64String(binary));

	//client.set("upload.png",binary);
	//client.set("projects");
	client.set("projects/test1.png", binary);
*/
	//client.del("projects/test1.png");
	//client.del("/projects");

//	return;
/*
	var pointsA = [];
	var pointsB = [];
	for(var i=0; i<3; ++i){
		var p = new V2D( Code.randomFloat(-1,1), Code.randomFloat(-1,1) );
		pointsA.push(p);
		var p = new V2D( Code.randomFloat(-1,1), Code.randomFloat(-1,1) );
		pointsB.push(p);
	}

	var pointsA = [new V2D( 2, 3),new V2D(6,4),new V2D(3,6)];
	//var pointsB = [new V2D(-1,-1),new V2D(1,0),new V2D(2,3)];
	var pointsB = [new V2D(-1,-1),new V2D(1,0),new V2D(2,-3)];

	var m = R3D.affineMatrixExact(pointsA,pointsB);
	var n = R3D.affineMatrixExact(pointsB,pointsA);

	var pointsC = [];
	var pointsD = [];
	for(var i=0; i<pointsA.length; ++i){
		var pA = pointsA[i];
		var pB = pointsB[i];
		var pC = m.multV2DtoV2D(new V2D(), pA);
		var pD = n.multV2DtoV2D(new V2D(), pB);
		if(false){
		if(i==0){
			pA = new V2D(0,0);
			pB = pA;
		}else if(i==1){
			pA = new V2D(1,0);
			pB = pA;
		}else if(i==2){
			pA = new V2D(0,1);
			pB = pA;
		}
		}
		var diffA = V2D.distance(pA,pD);
		var diffB = V2D.distance(pB,pC);
		pointsC.push(pC);
		pointsD.push(pD);
		console.log(diffA+" | "+diffB);
	}
	console.log("A: "+pointsA+"");
	console.log("B: "+pointsB+"");
	console.log("C: "+pointsC+"");
	console.log("D: "+pointsD+"");

	return;
*/


	// var app = new App3DR();
}
</script>
<body onload="pageLoadedFxn();" style="padding:0; margin:0; border:0;">
</body>
</html>
