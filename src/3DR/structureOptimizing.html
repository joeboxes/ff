<html>
<head>
<title>Structure (points) Optimizing: linear & nonlinear variations</title>
<script src="../code/FF.js"></script>
</head>
<script type="text/javascript">
function pageLoadedFxn(){
	console.log("pageLoadedFxn");
	var ff = new FF("../code/",ffLoadedFxn);
}
function ffLoadedFxn(){
	(new ScriptLoader("./",[],this,classesLoadedFxn)).load();
}
function classesLoadedFxn(){
	console.log("classesLoadedFxn");
	var test = new StructureTest();
}
</script>
<body onload="pageLoadedFxn();">
</body>
</html>
<script type="text/javascript">
function StructureTest(){
	// setup display
	this._canvas = new Canvas(null,1,1,Canvas.STAGE_FIT_FILL);
	this._stage = new Stage(this._canvas, (1/10)*1000);
	this._canvas.addListeners();
	this._stage.addListeners();
	this._stage.start();
	this._root = new DO();
	this._stage.root().addChild(this._root);
	GLOBALSTAGE = this._stage;
	this._stage.addListeners();

	this._keyboard = new Keyboard();
	this._keyboard.addListeners();

	

// this._stage.root().scale(2.0);
// this._root.matrix().scale(2.0);
	// load images
	// var imageList = ["caseStudy1-24.jpg","caseStudy1-26.jpg"];
// var imageList = ["caseStudy1-24.jpg"];
// var imageList = ["bench_A.png","bench_B.png"];
// var imageList = ["bench_D.png","bench_F.png"];
// var imageList = ["bt.000.png","bt.002.png"];
// var imageList = ["castle.000.jpg","castle.009.jpg"];
// var imageList = ["rabbit/1.jpg","rabbit/2.jpg"];
// var imageList = ["graffiti_1.png","graffiti_2.png"];
// var imageList = ["room1.png","room2.png"];
// var imageList = ["chapel00.png","chapel01.png"];
	// imageLoader = new ImageLoader("./images/",imageList, this,this.imagesLoadComplete,null);
	// imageLoader.load();

	this.syntheticDisplay();
}



StructureTest.prototype._pointOnSphere = function(e){
	var location = e["location"];
	var canvasSize = new V2D(this._canvas.width(),this._canvas.height());
	var sphereSizeMin = Math.min(canvasSize.x,canvasSize.y);
	// var center = new V2D(this._canvas.width()*0.5,this._canvas.height()*0.5);
	var center = canvasSize.copy().scale(0.5);
	// var location = Code.getMousePositionLocal(e);
	// var location = Code.getMousePositionAbsolute(e);
	var delta = V2D.sub(location,center);
	// console.log("-> "+delta);
	// console.log("-> "+location);
	// e = Code.getJSEvent(e);
	// return new V2D(e.offsetX,e.offsetY);
	var x = Math.min(delta.x/sphereSizeMin,1.0);
	var y = Math.min(-delta.y/sphereSizeMin,1.0);
	var z = Math.max(1.0 - x*x - y*y, 0.0);
	var pointOnSphere = new V3D(x,y,z);
	// console.log(pointOnSphere);
	return pointOnSphere;
}
StructureTest.prototype._updateInteractionPointOnSphere = function(){
	var a = this._interactionSphereStart;
	var b = this._interactionSphereEnd;
	// console.log(a,b);
	var cross = V3D.cross(a,b);
	if(cross.length()==0){
		return;
	}

	// return;
	var angle = V3D.angle(a,b);
	cross.norm();

	var world = this._world;
	var camera = world.camera();

	camera.rotation(this._interactionSphereCurrent);

	camera.rotate(cross, -angle);
	// camera.rotate( cross, angle );

	world.render();
}

StructureTest.prototype.onMouseDown = function(e){
	// console.log(e);
	// console.log("onMouseDown");

	this._interactionSphereStart = this._pointOnSphere(e);
	this._interactionSphereCurrent = this._world.camera().rotation().copy();
}
StructureTest.prototype.onMouseUp = function(e){
	// console.log("onMouseUp");
	this._interactionSphereEnd = this._pointOnSphere(e);
	this._updateInteractionPointOnSphere();
	this._interactionSphereStart = null;
	this._interactionSphereEnd = null;
}
StructureTest.prototype.onMouseMove = function(e){
	// console.log("onMouseMove");
	if(!this._interactionSphereStart){
		return;
	}
	this._interactionSphereEnd = this._pointOnSphere(e);
	this._updateInteractionPointOnSphere();
}


StructureTest.prototype.onMouseWheel = function(e){
	var scroll = e["scroll"];
	var dirX = scroll.x;
	var dirY = scroll.y;

	var world = this._world;
	var camera = world.camera();
	var pose = camera.orientation();


	// var matrix = camera.matrix();
	// 	matrix = matrix.copy().inverse();
	// 	pose = matrix.orientation();

	var o = pose["o"];
	var x = pose["x"];
	var y = pose["y"];
	var z = pose["z"];


	z = new V3D(0,0,1);

	// console.log(z);
	var offset = z.copy();
	offset.scale(0.01);
	if(dirY<0){
		offset.scale(-1);
	}
	camera.translate(offset);


	world.render();
}

StructureTest.prototype.onKeyDown = function(e){
	// console.log(e);
	var key = Code.getKeyCodeFromKeyboardEvent(e);
	// console.log(key);

	var world = this._world;
	var camera = world.camera();
	var pose = camera.orientation();

	var o = pose["o"];
	var x = pose["x"];
	var y = pose["y"];
	var z = pose["z"];



	x = new V3D(1,0,0);
	y = new V3D(0,1,0);

// console.log("X: "+x);

	var distanceSize = 0.1;

	// var offset = z.copy();
	// offset.scale(0.01);
	// if(dirY<0){
	// 	offset.scale(-1);
	// }
	// camera.translate(offset);


	var shouldRender = false;

	var offset = new V3D();

	if(key==Keyboard.KEY_LEFT){
		offset.add( x.copy().scale(-distanceSize) );
		shouldRender = true;
	}else if(key==Keyboard.KEY_RIGHT){
		offset.add( x.copy().scale(distanceSize) );
		shouldRender = true
	}else if(key==Keyboard.KEY_UP){
		offset.add( y.copy().scale(distanceSize) );
		shouldRender = true;
	}else if(key==Keyboard.KEY_DOWN){
		offset.add( y.copy().scale(-distanceSize) );
		shouldRender = true;
	}



	if(shouldRender){
		camera.translate(offset);
		world.render();
	}


	// this._keyboard

}
StructureTest.prototype.onKeyUp = function(e){
	// console.log(e);
	// Code.getKeyCodeFromKeyboardEvent
}



StructureTest.prototype.syntheticDisplay = function(){
	console.log("syntheticDisplay");


	// create 3D world
	var world = new D3D(this._stage);

	console.log(world);
	this._world = world;


	// this._canvas.addListener(Canvas.EVENT_MOUSE_MOVE);
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_DOWN, this.onMouseMove, this);
	this._canvas.addFunction(Canvas.EVENT_MOUSE_DOWN, this.onMouseDown, this);
	this._canvas.addFunction(Canvas.EVENT_MOUSE_UP, this.onMouseUp, this);
	this._canvas.addFunction(Canvas.EVENT_MOUSE_MOVE, this.onMouseMove, this);

	this._canvas.addFunction(Canvas.EVENT_MOUSE_WHEEL, this.onMouseWheel, this);


	this._keyboard.addFunction(Keyboard.EVENT_KEY_DOWN, this.onKeyDown, this);
	this._keyboard.addFunction(Keyboard.EVENT_KEY_UP, this.onKeyUp, this);




	
	/*
		Cam3D
		Line3D

	*/
	var canvas = this._stage.canvas();
	// console.log(canvas);
	// console.log(canvas.width());
	// console.log(canvas.height());

	var camera = new D3D.Cam3D();
	// setup K for screen:
	var cx = canvas.width()*0.5;
	var cy = canvas.height()*0.5;
	var fx = 1000;
	var fy = fx;
	var s = 0;
	camera.K(cx,cy, fx,fy, s);


	camera.identity();
	// camera.rotate( new V3D(0,0,1), Code.radians(45) );
	// camera.rotate( new V3D(0,1,0), Code.radians(45) );

	// camera.rotate( new V3D(0,0,1), Code.radians(30) );
	// camera.rotate( new V3D(0,1,0), Code.radians(30) );

	// camera.translate( new V3D(0,1,0) );
	// camera.translate( new V3D(0,0,1) );
camera.translate( new V3D(0,0,-1) );
	// camera.translate( new V3D(0,0,-2) );
	// camera.translate( new V3D(0,0,-10) );
	// camera.translate( new V3D(0,0,-100) );
	// camera.translate( new V3D(0,0,1000) );
	console.log(""+camera.matrix());
	
	
	world.camera(camera);
	

	// var counts = 10;
	var counts = 25;
	var size = 5.0;
	var color = 0xFFCC0033;
	// x
	color = 0xFFCC0033;
	for(var i=0; i<counts; ++i){
		var p = new V3D(1.0*i/(counts-1),0,0);
		var point = new D3D.Point3D(p,color, size);
		world.addObject(point);
	}
	// y
	color = 0xFF00CC33;
	for(var i=0; i<counts; ++i){
		var p = new V3D(0,1.0*i/(counts-1),0);
		var point = new D3D.Point3D(p,color, size);
		world.addObject(point);
	}
	// z
	color = 0xFF3300CC;
	for(var i=0; i<counts; ++i){
		var p = new V3D(0,0,1.0*i/(counts-1));
		var point = new D3D.Point3D(p,color, size);
		world.addObject(point);
	}
	// diag +
	color = 0xFF9933CC;
	for(var i=0; i<counts; ++i){
		var q = 1.0*i/(counts-1);
		var p = new V3D(q,q,q);
		var point = new D3D.Point3D(p,color, size);
		world.addObject(point);
	}
	// diag -
	color = 0xFF333333;
	for(var i=0; i<counts; ++i){
		var q = -1.0*i/(counts-1);
		var p = new V3D(q,q,q);
		var point = new D3D.Point3D(p,color, size);
		world.addObject(point);
	}



	var line = new D3D.Line3D( new V3D(1,0,0), new V3D(1,1,0), 0xFFFF0000, 5 );
	world.addObject(line);



	var createCamera = function(extrinsic, K, imageSize){ // matrix = asbolute ?
		var absolute = Matrix.inverse(extrinsic);
		console.log(absolute);
		// Matrix2D.inverse
		var Kinv = K.copy().inverse();
		// var Kinv = Matrix2D.inverse(K);
		// var Kinv = Matrix2D.inverse(K);
			// Kinv.inverse();
		console.log("K:\n"+K);
		console.log("Kinv:\n"+Kinv);

		var planeDistance = 0.25;
		var rayDistance = 2.0;
		// var pose = absolute.orientation();
		// var pose = absolute.orientation3D();
		var pose = extrinsic.orientation3D();

		var principlePoint = new V2D(K.get(0,2),K.get(1,2));
		console.log(principlePoint);


		// var ray = Code.projectPixelCameraRay(matrix,Kinv, 0,0);
		// imageSize.x,imageSize.y,
		// console.log(ray);
		// throw "...";
		//

		// console.log(pose);
		var o = pose["o"];
		var x = pose["x"];
		var y = pose["y"];
		var z = pose["z"];

		// console.log(o+"");

		// center point
		var point = new D3D.Point3D(o, 0x99000000, 9);
		world.addObject(point);
		var point = new D3D.Point3D(o, 0xFF000000, 5);
		world.addObject(point);

		// center ray
		// var line = new D3D.Line3D( o, V3D.add( o, z.copy().scale(rayDistance) ), 0xCC666666, 3 );
		// world.addObject(line);

		var rayA = Code.projectPixelCameraRay(extrinsic,Kinv, 0,0);
		var rayB = Code.projectPixelCameraRay(extrinsic,Kinv, imageSize.x-1,0);
		var rayC = Code.projectPixelCameraRay(extrinsic,Kinv, imageSize.x-1,imageSize.y-1);
		var rayD = Code.projectPixelCameraRay(extrinsic,Kinv, 0,imageSize.y-1);
		var rayO = Code.projectPixelCameraRay(extrinsic,Kinv, principlePoint.x,principlePoint.y);

		rayA = rayA["d"];
		rayB = rayB["d"];
		rayC = rayC["d"];
		rayD = rayD["d"];
		rayO = rayO["d"];

		// rayA.scale(planeDistance);
		// rayB.scale(planeDistance);
		// rayC.scale(planeDistance);
		// rayD.scale(planeDistance);

		// var frameA = V3D.add(o,rayA);
		// var frameB = V3D.add(o,rayB);
		// var frameC = V3D.add(o,rayC);
		// var frameD = V3D.add(o,rayD);

		var frameA = V3D.add(o,rayA.copy().scale(planeDistance));
		var frameB = V3D.add(o,rayB.copy().scale(planeDistance));
		var frameC = V3D.add(o,rayC.copy().scale(planeDistance));
		var frameD = V3D.add(o,rayD.copy().scale(planeDistance));
		var frameO = V3D.add(o,rayO.copy().scale(planeDistance));

		var extA = V3D.add(o,rayA.copy().scale(rayDistance));
		var extB = V3D.add(o,rayB.copy().scale(rayDistance));
		var extC = V3D.add(o,rayC.copy().scale(rayDistance));
		var extD = V3D.add(o,rayD.copy().scale(rayDistance));
		var extO = V3D.add(o,rayO.copy().scale(rayDistance));

		// frame X
		var line = new D3D.Line3D( frameA, frameB, 0xFFFF0000, 3 );
		world.addObject(line);
		// frame Y
		var line = new D3D.Line3D( frameA, frameD, 0xFF00FF00, 3 );
		world.addObject(line);

		// frame +x
		var line = new D3D.Line3D( frameD, frameC, 0xFF660000, 3 );
		world.addObject(line);
		// frame +y
		var line = new D3D.Line3D( frameB, frameC, 0xFF006600, 3 );
		world.addObject(line);

		// frustrum
		world.addObject( new D3D.Line3D( o, frameA, 0xCC333333, 3 ) );
		world.addObject( new D3D.Line3D( o, frameB, 0xCC333333, 3 ) );
		world.addObject( new D3D.Line3D( o, frameC, 0xCC333333, 3 ) );
		world.addObject( new D3D.Line3D( o, frameD, 0xCC333333, 3 ) );

		// extended - rays
		world.addObject( new D3D.Line3D( o, extA, 0x99000000, 1 ) );
		world.addObject( new D3D.Line3D( o, extB, 0x99000000, 1 ) );
		world.addObject( new D3D.Line3D( o, extC, 0x99000000, 1 ) );
		world.addObject( new D3D.Line3D( o, extD, 0x99000000, 1 ) );
		world.addObject( new D3D.Line3D( o, extO, 0xCC000000, 1 ) );

		var col = 0x33000000;
		var siz = 1;
		world.addObject(new D3D.Line3D( extA, extB, col, siz ));
		world.addObject(new D3D.Line3D( extB, extC, col, siz ));
		world.addObject(new D3D.Line3D( extC, extD, col, siz ));
		world.addObject(new D3D.Line3D( extD, extA, col, siz ));

		

		// 



		console.log("ADDED CAMERA");

	}






	var matrix = new Matrix3D();
		// matrix.rotateVector( (new V3D(1,1,1)).norm(), Code.radians(15) );
		// matrix.translate( new V3D(0.5,0.25,0.75) );

	/*
	var imageWidth = 600;
	var imageHeight = 400;
	// var imageWidth = 1980;
	// var imageHeight = 1080;
	var imageSize = new V2D(imageWidth,imageHeight);
	// var fx = 1.0;
	// var fy = 1.0;

	// var fx = 0.01;
	// var fy = 0.01;
	// var fx = 10.0;
	// var fy = 10.0;
	var fx = 1000.0;
	var fy = 1000.0;
	var s = 0.0;
	var cx = imageWidth*0.5;
	var cy = imageHeight*0.5;
	var K = new Matrix2D().fromArray([fx,s,0,fy, cx,cy]);




	*/


	// camera OISAO2RY
	var fx = 1.0000000000000013;
	var s = -0.00044971441422526773;
	var cx = 0.5008745771204777;
	//
	var fy = 1.1517148189968969;
	var cy = 0.48612810903892734;

	// scale up to image size
	// 4032 x 3024
	var viewImageSize = new V2D(2016,1512);

	var camK = new Matrix2D().fromArray([fx,s,0,fy, cx,cy]);
	camK = Matrix2D.toMatrix(camK);
	console.log("K1:\n"+camK);
	camK = R3D.cameraFromScaledImageSize(camK, viewImageSize);
	console.log("K2:\n"+camK);
	camK = Matrix2D.fromMatrix(camK);
	console.log("K3:\n"+camK);

	// Y9FK4HBT
	var viewAR = new Matrix(4,4).fromArray([0.9844029929497442, -0.0785810767369901, 0.15740318246605178, -0.45421483918303845, 0.08480028310419359, 0.9958452802999422, -0.033182671528646575, 0.061120609281615085, -0.15414168630527736, 0.046012955601490206, 0.9869767719960691, 0.052020171605282856, 0, 0, 0, 1]);

		// viewAR = Matrix.inverse(viewAR);

	// viewAR = Matrix3D.matrix3DFromMatrix(viewAR);

	// V4UUWLEB
	var viewBR = new Matrix(4,4).fromArray([0.999070859875698, 0.011492138463607625, -0.04153730492902325, -0.2150832521096602, -0.009623243041392905, 0.9989443985579598, 0.04491638657597404, -0.05713109143537567, 0.04200964342385772, -0.044474929378351215, 0.9981268308768135, -0.03879587323847487, 0, 0, 0, 1]);

		// viewBR = Matrix.inverse(viewBR);

	// viewBR = Matrix3D.matrix3DFromMatrix(viewBR);


	var patchA = {};

	patchA["p"] = new V3D(-0.4830266514067571, -0.36289802391457293, 1.2897683096548358);
	patchA["n"] = new V3D(0.19554935104854887, 0.16986673482227949, -0.9658704590706295);
	patchA["s"] =  0.002838671520686751;
	patchA["v"] = {};
	patchA["v"]["Y9FK4HBT"] = new V2D(0.12723214285714285, 0.1636904761904762);
	patchA["v"]["V4UUWLEB"] = new V2D(0.050247465833235215, 0.14351807603845876);


	// createCamera(matrix, camK, viewImageSize);
	createCamera(viewAR, camK, viewImageSize);
	createCamera(viewBR, camK, viewImageSize);




	// show patch:
	var normalSize = 0.1;
	world.addObject(new D3D.Point3D( patchA["p"].copy(), 0xFF3300CC, 9.0));
	world.addObject(new D3D.Line3D( patchA["p"].copy(), V3D.add(patchA["p"],patchA["n"].copy().scale(normalSize)) , 0xFF6600CC, 5.0));

	// show pixel

	// show ray

	// show midpoint

	// do DLT






	world.render();

	console.log("rendered");

	// create synthetic cameras


	// add display to world

}


StructureTest.prototype.imagesLoadComplete = function(imageInfo){
	console.log("imageInfo")

	var imageList = imageInfo.images;

	// var imageSourceA = imageList[0];
	// var imageFloatA = GLOBALSTAGE.getImageAsFloatRGB(imageSourceA);
	// var imageMatrixA = new ImageMat(imageFloatA["width"],imageFloatA["height"], imageFloatA["red"], imageFloatA["grn"], imageFloatA["blu"]);

	// var imageSourceB = imageList[1];
	// var imageFloatB = GLOBALSTAGE.getImageAsFloatRGB(imageSourceB);
	// var imageMatrixB = new ImageMat(imageFloatB["width"],imageFloatB["height"], imageFloatB["red"], imageFloatB["grn"], imageFloatB["blu"]);
	var matrixList = [];
	var i, j, list = [], d, x=0, y=0;


	x += 50;
	y += 50;
	for(i=0;i<imageList.length;++i){
		var img = imageList[i];
		var matrix = this._stage.getImageAsImageMat(img);
		matrixList[i] = matrix;

		//list[i] = img;
		d = new DOImage(img);
		//d.enableDragging();
		this._root.addChild(d);
		d.matrix().identity();
		d.matrix().translate(x,y);
		d.graphics().setLine(1.0,0xFFFF0000);
		d.graphics().beginPath();
		d.graphics().endPath();
		d.graphics().strokeLine();
		

		console.log(matrix);

		var gry = matrix.gry();
		var corners = R3D.harrisCornerDetection(gry, matrix.width(), matrix.height());


		// blur corner scopre
		var blurSigma = 1.0;
		corners = ImageMat.getBlurredImage(corners,matrix.width(), matrix.height(), blurSigma);


		// normalize to 01
		ImageMat.normalFloat01(corners);
		var info = Code.infoArray(corners);
		console.log(info);
		var min = info["min"];
		var max = info["max"];
		var mean = info["mean"];


		// var minimumScoreCorner = 0.001;
		// var minimumScoreCorner = mean; // too restrictive
		var minimumScoreCorner = mean*0.5;
		// var minimumScoreCorner = mean*0.1;

		// console.log(corners);

		// get distribution of corners ...


		// throw "...";

		var SDF = function(rect, data, cell){
			// console.log("SDF");

			var minimumRangeGray = 0.01;
			// var minimumRangeGray = 0.05;
			// var minimumRangeGray = 0.10;
			// var minimumRangeGray = 0.25;


			// var minimumScoreCorner = 0.001;
			
			var wid = matrix.width();
			var hei = matrix.height();
			var min = rect.min();
			var max = rect.max();
			// console.log(min+" - "+max);
			var staX = Math.ceil(min.x);
			var staY = Math.ceil(min.y);
			var endX = Math.floor(max.x);
			var endY = Math.floor(max.y);
				staX = Math.max(0,staX);
				staY = Math.max(0,staY);
				endX = Math.min(wid-1,endX);
				endY = Math.min(hei-1,endY);
			var countX = endX-staX;
			var countY = endY-staY;
			if(countX<=0 || countY<=0){
				return false;
			}


			// calculate gray range:
			var colMinY = null;
			var colMaxY = null;
			for(var i=staX;i<=endX; ++i){
				for(var j=staY;j<=endY; ++j){
					var index = j*wid + i;
					var color = gry[index];
					if(colMinY===null){
						colMinY = color;
						colMaxY = color;
					}
					colMinY = Math.min(colMinY, color);
					colMaxY = Math.max(colMaxY, color);
					// console.log(color);
					// throw "...";
				}
			}
			var rangeY = colMaxY - colMinY;
			// console.log("RANGE: "+rangeY);
			if(rangeY<minimumRangeGray){
				return false;
			}


			// calculate cornerness max
			var cornerMax = null;
			for(var i=staX;i<=endX; ++i){
				for(var j=staY;j<=endY; ++j){
					var index = j*wid + i;
					var value = corners[index];
					if(cornerMax===null){
						cornerMax = value;
					}
					cornerMax = Math.max(cornerMax, value);
					// console.log(color);
					// throw "...";
				}
			}
			if(cornerMax<minimumScoreCorner){
				return false;
			}


			return true;
			// throw "...";
		}

		var setWid = matrix.width();
		var setHei = matrix.height();
		var setX = 0;
		var setY = 0;
		if(setWid>setHei){
			setY -= (setWid-setHei)*0.5;
			setHei = setWid;
		}else{
			setX -= (setHei-setWid)*0.5;
			setWid = setHei;
		}
		var quad = new QuadLimit(SDF, setX,setY, setWid,setHei, 2);

		// quad.subDivide(4);
		quad.subDivide(5);


		d = new DO();
		d.matrix().translate(x,y);
		this._root.addChild(d);
		quad.debugDraw(d);


		//NEXT: 
		x += img.width;
		y += 0;
	}

}


function QuadLimit(shouldDivideFxn, locationX, locationY, width, height, initialSubdivisions){
	this._shouldDivideFxn = shouldDivideFxn; // x,y,w,h rect
	this._root = new QuadLimit.Cell();
	this.setSize(width, height);
	this.setLocation(locationX, locationY);
	if(initialSubdivisions){
		console.log("subdivide");
		this.subDivide(initialSubdivisions, false);
	}
}
QuadLimit.prototype.setSize = function(width, height){
	this._root.size(width, height);
}
QuadLimit.prototype.setLocation = function(x, y){
	this._root.location(x, y);
}
QuadLimit.prototype.subDivide = function(count, check){
	count = Code.valueOrDefault(count, 1);
	check = Code.valueOrDefault(check, true);
	console.log("subDivide: "+count);
	var shouldSplit = true;
	for(var k=0; k<count; ++k){
		var leaves = this._root.leaves();
		console.log(leaves);
		for(var i=0; i<leaves.length; ++i){
			var leaf = leaves[i];
			if(check){
				// console.log(leaf);
				shouldSplit = this._shouldDivideFxn(leaf.rect(), leaf.data(), leaf);
				// console.log("shouldSplit: "+shouldSplit);
				// throw "..."
			}
			if(shouldSplit){
				var newLeaves = leaf.split();
			}
		}
	}
}

QuadLimit.prototype.debugDraw = function(d){
	console.log("debugDraw");
	d.graphics().clear();
	this._root.debugDraw(d);
}

QuadLimit.Cell = function(x,y, width, height){
	this._x = x;
	this._y = y;
	this._width = width;
	this._height = height;
	this._children = [];
	this._data = null;
	this.data({});
}
QuadLimit.Cell.prototype.rect = function(){
	var rect = new Rect(this._x,this._y,this._width,this._height);
	return rect;
}
QuadLimit.Cell.prototype.data = function(data){
	if(data!==undefined){
		this._data = data;
	}
	return this._data;
}
QuadLimit.Cell.prototype.leaves = function(array){
	if(!array){
		array = [];
	}
	if(this.isLeaf()){
		array.push(this);
	}else{
		var children = this._children;
		for(var i=0; i<children.length; ++i){
			var child = children[i];
			child.leaves(array);
		}
	}
	return array;
}
QuadLimit.Cell.prototype.isLeaf = function(){
	return this._children.length == 0;
}
QuadLimit.Cell.prototype.location = function(x, y){
	this.clear();
	this._x = x;
	this._y = y;
}
QuadLimit.Cell.prototype.size = function(width, height){
	this.clear();
	this._width = width;
	this._height = height;
}
QuadLimit.Cell.prototype.split = function(array){
	if(!array){
		array = [];
	}
	if(this.isLeaf()){
		var wid = this._width*0.5;
		var hei = this._height*0.5;
		for(var j=0; j<2; ++j){
			var y = this._y + hei*j;
			for(var i=0; i<2; ++i){
				var x = this._x + wid*i;
				var child = new QuadLimit.Cell(x,y,wid,hei);
				this._children.push(child);
				array.push(child);
			}
		}
		return array;
	}
	return null;
}
QuadLimit.Cell.prototype.clear = function(){
	var children = this._children;
	for(var i=0; i<children.length; ++i){
		var child = children[i];
		child.clear();
		child.kill();
	}
	Code.emptyArray(children);
}
QuadLimit.Cell.prototype.kill = function(){
	this._x = null;
	this._y = null;
	this._width = null;
	this._height = null;
	this._children = null;
}
QuadLimit.Cell.prototype.debugDraw = function(d){
	// console.log("debugDraw",this._x,this._y, this._width, this._height);
	d.graphics().setLine(1.0,0xCCFF0000);
	d.graphics().beginPath();
	d.graphics().drawRect(this._x,this._y, this._width, this._height);
	d.graphics().strokeLine();
	d.graphics().endPath();
	// and repeat for kids
	var children = this._children;
	for(var i=0; i<children.length; ++i){
		var child = children[i];
		child.debugDraw(d);
	}
}

</script>






















<!-- ... -->