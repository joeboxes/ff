// Dense.js

function Dense(){
	this._canvas = new Canvas(null,0,0,Canvas.STAGE_FIT_FILL, false,false);
	this._stage = new Stage(this._canvas, 1000/20);
	this._root = new DO();
	this._stage.addChild(this._root);
	this._canvas.addListeners();
	this._stage.addListeners();
	this._stage.start();
	// this._canvas.addFunction(Canvas.EVENT_MOUSE_CLICK,this.handleMouseClickFxn,this);
	this._keyboard = new Keyboard();
	// this._keyboard.addFunction(Keyboard.EVENT_KEY_UP,this.handleKeyboardUp,this);
	// this._keyboard.addFunction(Keyboard.EVENT_KEY_DOWN,this._handleKeyboardDown,this);
	// this._keyboard.addFunction(Keyboard.EVENT_KEY_STILL_DOWN,this.handleKeyboardStill,this);
	// this._keyboard.addListeners();
	// this._ticker = new Ticker(1);
	// this._ticker.addFunction(Ticker.EVENT_TICK, this.handleTickerFxn, this);
	// this._tickCount = 0;
	
	var imageList = ["caseStudy1-0.jpg", "caseStudy1-9.jpg"];
	//var imageList = ["zoom_03.png","zoom_scale.png"];
	var imageLoader = new ImageLoader("./images/",imageList, this,this.handleImagesLoaded,null);
	imageLoader.load();
}

Dense.prototype.handleImagesLoaded = function(imageInfo){
	var imageList = imageInfo.images;
	var fileList = imageInfo.files;
	var i, j, k, list = [];
	var x = 0;
	var y = 0;
	var images = [];
	for(i=0;i<imageList.length;++i){
		var file = fileList[i];
		var img = imageList[i];
		images[i] = img;
	// 	var d = new DOImage(img);
	// 	this._root.addChild(d);
	// 	d.graphics().alpha(0.25);
	// 	//d.graphics().alpha(1.0);
	// 	//d.graphics().alpha(0.0);
	// 	d.matrix().translate(x,y);
	// 	x += img.width;
	}

	GLOBALSTAGE = this._stage;

	var imageSourceA = images[0];
	var imageFloatA = GLOBALSTAGE.getImageAsFloatRGB(imageSourceA);
	var imageMatrixA = new ImageMat(imageFloatA["width"],imageFloatA["height"], imageFloatA["red"], imageFloatA["grn"], imageFloatA["blu"]);

	var imageSourceB = images[1];
	var imageFloatB = GLOBALSTAGE.getImageAsFloatRGB(imageSourceB);
	var imageMatrixB = new ImageMat(imageFloatB["width"],imageFloatB["height"], imageFloatB["red"], imageFloatB["grn"], imageFloatB["blu"]);

	var pointsA = [
//				new V2D(86,208), // glasses corner left
//				new V2D(190,180), // glasses corner right
				new V2D(172,107), // origin
				new V2D(22.5,166), // lighter button
				new V2D(361,183), // mouse eye
				new V2D(18,225), // bic corner left
				//new V2D(37,216), // bic corner right
				//new V2D(65,169), // cup 
				new V2D(226,87), // face BL
				new V2D(219,66), // glasses TL
				new V2D(250,72), // glasses TR
				new V2D(260,103), // elbow
				new V2D(216,154), // toe left
				new V2D(245,158), // toe right
				new V2D(202,127), // brick
				new V2D(240,248), // 12
				new V2D(332,249), // 16
				new V2D(145,203), // glasses center
				new V2D(172,68), // grid top
				new V2D(141,76), // grid TL
				new V2D(204,75), // grid TR
				new V2D(144,119), // grid BL
				new V2D(175,128), // grid bot
				new V2D(362,213), // U
				new V2D(326,176), // tail
				new V2D(190,173), // base left
				new V2D(265,178), // base right
				new V2D(372,181), // nose
				new V2D(129,88), // power top
				new V2D(132,141), // power bot
				new V2D(62,107), // cup
				new V2D(94,176), // glass tip left
				new V2D(131,166), // glass tip right
			];
var pointsB = [
//				new V2D(87,192),
//				new V2D(170,178),
				new V2D(212,46),
				new V2D(50,149),
				new V2D(278,241),
				new V2D(52,179), // left
				//new V2D(64,172), // bic right
				//new V2D(94,124), 
				new V2D(225,98), // face BL
				new V2D(221,80), // glasses TL
				new V2D(246,95), // glasses TR
				new V2D(250,121),
				new V2D(214,139), // tow left
				new V2D(237,150), // toe right
				new V2D(213,106), // brick
				new V2D(180,252), // 12
				new V2D(245,271), // 16
				new V2D(131,193), // glasses center
				new V2D(213,12), // grid top
				new V2D(177,26), // grid TL
				new V2D(239,33), // grid TR
				new V2D(180,61), // grid BL
				new V2D(202,83), // grid bot
				new V2D(282,251), // U
				new V2D(256,225), // tail
				new V2D(187,153), // base left
				new V2D(245,173), // base right
				new V2D(290,240), // nose
				new V2D(150,63), // power top
				new V2D(155,100), // power bot
				new V2D(85,92), // cup
				new V2D(113,138), // glass tip left
				new V2D(145,132), // glass tip right
			];



var pointsA = [];pointsA.push(new V3D(235.97865315636457,115.28420955717579,10,4.791087469183674));
pointsA.push(new V3D(349.1873946962186,149.64341003974414,52.631578947368425,1.7817229431532593));
pointsA.push(new V3D(321.46916984800936,204.43217874215344,34.78260869565217,1.8929534330187712));
pointsA.push(new V3D(165.48633845818364,215.37408300864996,22.988505747126435,1.1738956140813133));
pointsA.push(new V3D(91.80050161333462,94.64614565415127,52.631578947368425,1.6602117246169041));
pointsA.push(new V3D(202.26052365089205,94.50698384242526,10,3.2281802009891054));
pointsA.push(new V3D(152.248207079803,163.510066044146,80,0.07891211073282796));
pointsA.push(new V3D(220.81054860136655,124.4152795547132,22.988505747126435,3.4098322137652533));
pointsA.push(new V3D(114.99044138782446,195.51990980540643,34.78260869565217,4.610217710326026));
pointsA.push(new V3D(22.548593548995772,189.93092423033775,52.631578947368425,2.9101301066277836));
pointsA.push(new V3D(162.7408497601167,211.99013833485827,80,4.677096910042213));
pointsA.push(new V3D(29.342788282565824,188.3754829340657,15.151515151515152,6.051788335203838));
pointsA.push(new V3D(26.05423390101039,179.75703326479106,80,3.019364820360263));
pointsA.push(new V3D(243.18820338125477,84.17637424000638,34.78260869565217,1.8009346112463547));
pointsA.push(new V3D(25.118104605708382,212.07569810042781,34.78260869565217,2.9310733078743647));
pointsA.push(new V3D(337.46339769392404,209.45664259762134,34.78260869565217,1.6980827177447617));
pointsA.push(new V3D(84.7401668417853,177.07878451013593,52.631578947368425,1.6451401268182346));
pointsA.push(new V3D(25.574022634259308,169.35707460341027,15.151515151515152,6.066560704448113));
pointsA.push(new V3D(46.109949197534974,154.03228572422123,80,6.168475995001458));
pointsA.push(new V3D(34.06280070649173,206.46533272257852,22.988505747126435,6.164838052268838));
pointsA.push(new V3D(237.6085127514801,249.9853135388256,15.151515151515152,1.606906071410669));
pointsA.push(new V3D(371.17826704733864,180.79656747211067,10,0.7620321091935295));
pointsA.push(new V3D(355.271201192769,215.13772100761184,22.988505747126435,4.621523410161858));
pointsA.push(new V3D(361.0365027098586,170.82357593044392,10,1.658062789394613));
pointsA.push(new V3D(146.36161273584557,202.08320989658262,34.78260869565217,4.694853207316037));
pointsA.push(new V3D(170.60747190323085,37.4831755271552,52.631578947368425,3.0770484571029986));
pointsA.push(new V3D(83.33256285722935,202.18227867525246,22.988505747126435,4.456671432678633));
pointsA.push(new V3D(234.44867339052072,105.18737294100605,52.631578947368425,1.6321061016256948));
pointsA.push(new V3D(317.9401665685683,122.65396894397892,22.988505747126435,4.626154766468166));
pointsA.push(new V3D(349.2331192784495,150.1294284505964,34.78260869565217,1.7760761123842472));
pointsA.push(new V3D(317.9401665685683,122.65396894397892,22.988505747126435,4.626154766468166));
pointsA.push(new V3D(149.6174496883365,95.82127445426296,15.151515151515152,3.0521293289380407));
pointsA.push(new V3D(355.36806597429086,171.86669902450566,10,1.6580450164658285));
pointsA.push(new V3D(149.65515456189314,82.71181954398814,34.78260869565217,0.006387544760250302));
pointsA.push(new V3D(355.36806597429086,171.86669902450566,10,1.6580450164658285));
pointsA.push(new V3D(208.36331302240788,148.25438040055224,52.631578947368425,3.410515897379478));
pointsA.push(new V3D(83.11049831601099,179.13922998672712,34.78260869565217,0.09141429161990992));
pointsA.push(new V3D(142.94519180545748,84.77166426687313,15.151515151515152,3.05320829129857));
pointsA.push(new V3D(83.11049831601099,179.13922998672712,34.78260869565217,0.09141429161990992));
pointsA.push(new V3D(379.12397889608775,246.51262830333184,52.631578947368425,4.631982828621801));
pointsA.push(new V3D(180.5742361394635,97.49064328194207,34.78260869565217,0.09672030699516175));
pointsA.push(new V3D(150.8815812969212,82.65980850234898,15.151515151515152,6.209524677167653));
pointsA.push(new V3D(180.5742361394635,97.49064328194207,34.78260869565217,0.09672030699516175));
pointsA.push(new V3D(241.4281427267721,87.8511764488757,10,4.599737187926458));
pointsA.push(new V3D(350.18644010340756,214.70229944537522,22.988505747126435,1.6533583382506598));
pointsA.push(new V3D(35.80376937259355,214.79386904071163,22.988505747126435,3.054401604710393));
pointsA.push(new V3D(350.18644010340756,214.70229944537522,22.988505747126435,1.6533583382506598));
pointsA.push(new V3D(208.34707165070844,149.35174437824915,34.78260869565217,3.4456100561173315));
pointsA.push(new V3D(357.9204283617969,192.56233248049665,52.631578947368425,1.6826911657541228));
pointsA.push(new V3D(87.37915848691564,157.70894571314776,52.631578947368425,3.057057097712546));
pointsA.push(new V3D(357.9204283617969,192.56233248049665,52.631578947368425,1.6826911657541228));
pointsA.push(new V3D(104.52343484847772,134.3859202367008,52.631578947368425,3.1879966864049134));
pointsA.push(new V3D(198.51563244195353,246.8024165080292,52.631578947368425,4.624831029977409));
pointsA.push(new V3D(310.2485194920464,248.37157822327862,52.631578947368425,4.624817479719281));
pointsA.push(new V3D(198.51563244195353,246.8024165080292,52.631578947368425,4.624831029977409));
pointsA.push(new V3D(169.45050653940217,102.28788497786175,80,4.765174568013));
pointsA.push(new V3D(243.79275601310212,124.96957763890364,22.988505747126435,6.212358393697885));
pointsA.push(new V3D(178.8150488046791,86.54607992275487,52.631578947368425,4.666338000021442));
pointsA.push(new V3D(243.79275601310212,124.96957763890364,22.988505747126435,6.212358393697885));
pointsA.push(new V3D(311.6360764257801,248.74959299399598,34.78260869565217,4.626833047699156));
pointsA.push(new V3D(178.68174094620605,78.22845957330304,34.78260869565217,3.04842900680889));
pointsA.push(new V3D(331.267279484234,175.19507116106064,15.151515151515152,5.117869700634158));
pointsA.push(new V3D(178.68174094620605,78.22845957330304,34.78260869565217,3.04842900680889));
pointsA.push(new V3D(151.31947153105466,92.68484991048902,22.988505747126435,6.2557713916244));
pointsA.push(new V3D(289.45795590099374,249.9778839852766,15.151515151515152,1.5766165403088976));
pointsA.push(new V3D(133.4019588175492,164.33262186458836,80,4.621860110501879));
pointsA.push(new V3D(289.45795590099374,249.9778839852766,15.151515151515152,1.5766165403088976));
pointsA.push(new V3D(233.25322327496315,176.01008908243364,52.631578947368425,1.6545618529031585));
pointsA.push(new V3D(230.5005857514285,249.91492357207596,52.631578947368425,4.626975287722724));
pointsA.push(new V3D(29.557525159977228,99.22339761599726,34.78260869565217,1.6483589330757598));
pointsA.push(new V3D(230.5005857514285,249.91492357207596,52.631578947368425,4.626975287722724));
pointsA.push(new V3D(144.14366645326336,192.80163437345558,34.78260869565217,4.6315800361023545));
pointsA.push(new V3D(184.46320861932492,118.17315037302848,22.988505747126435,4.80217408098593));
pointsA.push(new V3D(171.13000475015755,94.724567171262,15.151515151515152,0.0759976444513849));
pointsA.push(new V3D(184.46320861932492,118.17315037302848,22.988505747126435,4.80217408098593));
pointsA.push(new V3D(156.17947551192884,83.04231537627548,22.988505747126435,3.0495737108442165));
pointsA.push(new V3D(252.6458539195748,96.56536430483223,34.78260869565217,4.325427892672325));
pointsA.push(new V3D(91.46934271060212,101.00093679892653,22.988505747126435,3.2142568779827845));
pointsA.push(new V3D(252.6458539195748,96.56536430483223,34.78260869565217,4.325427892672325));
pointsA.push(new V3D(148.82300319136212,84.77463641673027,22.988505747126435,6.200899751832448));
pointsA.push(new V3D(221.33785718432958,98.62244693511182,15.151515151515152,0.23975079506442962));
pointsA.push(new V3D(170.48093413244422,78.36202844714514,22.988505747126435,4.791036665305837));
pointsA.push(new V3D(221.33785718432958,98.62244693511182,15.151515151515152,0.23975079506442962));
pointsA.push(new V3D(147.76709923933933,81.28850574017764,80,1.658185689928045));
pointsA.push(new V3D(27.909355730393415,182.7037289526936,15.151515151515152,6.077613576620642));
pointsA.push(new V3D(337.2793593513602,247.77922975741427,34.78260869565217,4.628547097878854));
pointsA.push(new V3D(27.909355730393415,182.7037289526936,15.151515151515152,6.077613576620642));
pointsA.push(new V3D(265.23918483533805,250.66520251942723,52.631578947368425,4.625792648658811));
pointsA.push(new V3D(239.89827390896568,87.24176614303143,34.78260869565217,1.6782098756006565));
pointsA.push(new V3D(153.58323107681616,76.12258943950506,34.78260869565217,6.198400338154773));
pointsA.push(new V3D(239.89827390896568,87.24176614303143,34.78260869565217,1.6782098756006565));
pointsA.push(new V3D(142.9863092512552,84.09043080382459,34.78260869565217,6.22182545372727));
pointsA.push(new V3D(193.69629675873398,248.37307722895758,15.151515151515152,4.634570169151452));
pointsA.push(new V3D(323.54245058674417,247.31045173840818,52.631578947368425,4.624270070860512));
pointsA.push(new V3D(193.69629675873398,248.37307722895758,15.151515151515152,4.634570169151452));
pointsA.push(new V3D(132.06119866211472,165.41220804597143,22.988505747126435,1.467704373952833));
pointsA.push(new V3D(199.54664509216727,109.73580006912019,52.631578947368425,6.2003151014039295));
pointsA.push(new V3D(182.79845567555176,123.74884172156726,15.151515151515152,4.808445882092923));
pointsA.push(new V3D(199.54664509216727,109.73580006912019,52.631578947368425,6.2003151014039295));
pointsA.push(new V3D(238.12296311883588,155.10879148782075,80,1.6390169148979428));
pointsA.push(new V3D(39.550066324354894,125.91054274905666,52.631578947368425,5.857974323488414));
pointsA.push(new V3D(129.22433540692725,88.26306594482544,52.631578947368425,6.175561112016098));
pointsA.push(new V3D(39.550066324354894,125.91054274905666,52.631578947368425,5.857974323488414));
pointsA.push(new V3D(31.854190970017076,104.62782532309186,22.988505747126435,3.0769995564131905));
pointsA.push(new V3D(68.81939951675571,256.64277459705175,15.151515151515152,4.776674758150661));
pointsA.push(new V3D(173.44763050128066,50.76776839430154,22.988505747126435,3.062710434830976));
pointsA.push(new V3D(68.81939951675571,256.64277459705175,15.151515151515152,4.776674758150661));
pointsA.push(new V3D(188.17014277113648,72.1041376144453,22.988505747126435,3.0720180756913607));
pointsA.push(new V3D(218.98528681155577,176.05665604004275,52.631578947368425,1.6231412898024058));
pointsA.push(new V3D(358.0505595433886,247.0557862970743,34.78260869565217,4.6324973122229265));
pointsA.push(new V3D(218.98528681155577,176.05665604004275,52.631578947368425,1.6231412898024058));
pointsA.push(new V3D(323.8128642940907,143.4073359015493,34.78260869565217,1.8795570378363222));
pointsA.push(new V3D(317.228504319661,185.09279608250017,22.988505747126435,1.4948050546999452));
pointsA.push(new V3D(151.681278137583,92.77455300811715,15.151515151515152,3.0476377370693566));
pointsA.push(new V3D(317.228504319661,185.09279608250017,22.988505747126435,1.4948050546999452));
pointsA.push(new V3D(179.70111342507772,106.55639634608593,34.78260869565217,6.2328391382894495));
pointsA.push(new V3D(325.0955365721035,174.6389603915935,22.988505747126435,4.995942866619982));
pointsA.push(new V3D(83.40718167949814,202.51133394140678,15.151515151515152,4.466259019992081));
pointsA.push(new V3D(325.0955365721035,174.6389603915935,22.988505747126435,4.995942866619982));
pointsA.push(new V3D(133.1250072967179,144.58505411543007,52.631578947368425,3.049079299549765));
pointsA.push(new V3D(295.1230080489371,181.98725898893096,80,4.628701917334387));
pointsA.push(new V3D(214.9837218598598,152.35183244284016,52.631578947368425,3.408890196091012));
pointsA.push(new V3D(295.1230080489371,181.98725898893096,80,4.628701917334387));
pointsA.push(new V3D(370.83688637302646,127.31891928411854,34.78260869565217,5.008634602955414));
pointsA.push(new V3D(244.63713036613964,156.48790765998345,22.988505747126435,1.626088599289825));
pointsA.push(new V3D(258.3203210263075,250.42012225050985,52.631578947368425,4.626037347067953));
pointsA.push(new V3D(244.63713036613964,156.48790765998345,22.988505747126435,1.626088599289825));
pointsA.push(new V3D(260.47761586597494,177.04924363076444,34.78260869565217,4.62499088598075));
pointsA.push(new V3D(164.20948302769898,119.91055587725899,80,1.4682943135038602));
pointsA.push(new V3D(241.85153617509764,100.73175340910161,15.151515151515152,3.2170338686469395));
pointsA.push(new V3D(164.20948302769898,119.91055587725899,80,1.4682943135038602));
pointsA.push(new V3D(288.49075728696545,248.97132130638673,34.78260869565217,4.6299578386871225));
pointsA.push(new V3D(247.0890701280959,81.66696988233568,34.78260869565217,1.8138743489601998));
pointsA.push(new V3D(153.94720448807365,116.92306486629144,34.78260869565217,4.794650327717067));
pointsA.push(new V3D(247.0890701280959,81.66696988233568,34.78260869565217,1.8138743489601998));
pointsA.push(new V3D(156.5029879413396,93.03343537335911,22.988505747126435,0.056212439597597065));
pointsA.push(new V3D(184.15435326597284,116.02198325428408,22.988505747126435,4.802656737401066));
pointsA.push(new V3D(361.431004455645,194.1487648582581,15.151515151515152,1.4619735986106028));
pointsA.push(new V3D(184.15435326597284,116.02198325428408,22.988505747126435,4.802656737401066));
pointsA.push(new V3D(93.78623424726054,175.00977944137955,15.151515151515152,1.657879859419812));
pointsA.push(new V3D(165.1055198302545,78.1556852395378,22.988505747126435,6.235796450687891));
pointsA.push(new V3D(234.7268513245218,109.81440505896062,15.151515151515152,4.79434021942455));
pointsA.push(new V3D(165.1055198302545,78.1556852395378,22.988505747126435,6.235796450687891));
pointsA.push(new V3D(248.0038492955725,82.3834830678632,15.151515151515152,3.358112533491835));
pointsA.push(new V3D(351.20981928424726,198.1659337756366,52.631578947368425,1.8311261698636532));
pointsA.push(new V3D(132.98457426538977,197.64787407752965,34.78260869565217,4.624618387731624));
pointsA.push(new V3D(351.20981928424726,198.1659337756366,52.631578947368425,1.8311261698636532));
pointsA.push(new V3D(346.2657655807549,179.10795450736478,34.78260869565217,5.116212820948579));
pointsA.push(new V3D(155.88388295268237,92.23838946878524,34.78260869565217,6.211373012993803));
pointsA.push(new V3D(336.63642555536853,246.91475097532935,52.631578947368425,4.624960436189779));
pointsA.push(new V3D(155.88388295268237,92.23838946878524,34.78260869565217,6.211373012993803));
pointsA.push(new V3D(282.5595202985235,249.25731794633754,34.78260869565217,4.626551617865865));
pointsA.push(new V3D(243.957749932759,249.2436869356228,52.631578947368425,4.63184488995001));
pointsA.push(new V3D(137.82069848567667,249.5372129161002,52.631578947368425,1.486923548529559));
pointsA.push(new V3D(243.957749932759,249.2436869356228,52.631578947368425,4.63184488995001));
pointsA.push(new V3D(183.07621746375932,121.78917540653757,52.631578947368425,4.6243809360960055));
pointsA.push(new V3D(193.02095342730368,84.6132325643624,52.631578947368425,1.5448608244400144));
pointsA.push(new V3D(170.69110850644566,94.67496711008238,34.78260869565217,4.776092501807996));
pointsA.push(new V3D(193.02095342730368,84.6132325643624,52.631578947368425,1.5448608244400144));
pointsA.push(new V3D(93.17075796371299,180.21006798896522,15.151515151515152,4.633591697536583));
pointsA.push(new V3D(156.82458478286932,93.25900110492613,15.151515151515152,3.0441357498774937));
pointsA.push(new V3D(44.404804257070765,88.88326885376337,52.631578947368425,1.5372257668384306));
pointsA.push(new V3D(156.82458478286932,93.25900110492613,15.151515151515152,3.0441357498774937));
pointsA.push(new V3D(29.200976900367447,99.83309996927001,22.988505747126435,3.0547960579260414));
pointsA.push(new V3D(188.05335186211738,92.13420833041008,15.151515151515152,0.08971327253403455));
pointsA.push(new V3D(80.99772280721645,211.32386245073909,15.151515151515152,4.64030829719507));
pointsA.push(new V3D(188.05335186211738,92.13420833041008,15.151515151515152,0.08971327253403455));
pointsA.push(new V3D(148.24562452261037,82.44047323183817,52.631578947368425,6.214844477404745));
pointsA.push(new V3D(368.3748985911079,126.17776283515067,52.631578947368425,1.6325346099110778));
pointsA.push(new V3D(68.2009272223667,255.30122456181508,34.78260869565217,1.4935313295640213));
pointsA.push(new V3D(368.3748985911079,126.17776283515067,52.631578947368425,1.6325346099110778));
pointsA.push(new V3D(47.794885118221266,155.12147622465778,34.78260869565217,4.799513213410056));
pointsA.push(new V3D(323.5987645194026,173.91970737266976,52.631578947368425,4.873968027842638));
pointsA.push(new V3D(147.6884367055304,118.98609640777542,15.151515151515152,1.1470774406161064));
pointsA.push(new V3D(323.5987645194026,173.91970737266976,52.631578947368425,4.873968027842638));
pointsA.push(new V3D(227.86778366568066,150.08090325332915,52.631578947368425,4.641775025945273));
pointsA.push(new V3D(85.49721047188268,206.37934041883173,34.78260869565217,4.470904401149627));
pointsA.push(new V3D(186.61544387006876,98.28995520610759,52.631578947368425,4.835202126665331));
pointsA.push(new V3D(85.49721047188268,206.37934041883173,34.78260869565217,4.470904401149627));
pointsA.push(new V3D(178.34630658095074,120.97412596717966,22.988505747126435,4.804283725313731));
pointsA.push(new V3D(187.98080914037885,91.06336187084584,22.988505747126435,0.09973426064361708));
pointsA.push(new V3D(150.3799016156924,84.22917615156844,15.151515151515152,6.206777176811768));
pointsA.push(new V3D(187.98080914037885,91.06336187084584,22.988505747126435,0.09973426064361708));
pointsA.push(new V3D(177.22208221364625,115.78549413170705,22.988505747126435,4.794667564038232));
pointsA.push(new V3D(288.7370857131046,248.85387759280704,22.988505747126435,4.6257799865126525));
pointsA.push(new V3D(93.41858857253554,174.88191972071698,22.988505747126435,4.6136310945567445));
pointsA.push(new V3D(288.7370857131046,248.85387759280704,22.988505747126435,4.6257799865126525));
pointsA.push(new V3D(166.4590052514226,123.46095588842634,34.78260869565217,4.7968501110967665));
pointsA.push(new V3D(368.711214278275,179.40821158297172,34.78260869565217,4.658231770918412));
pointsA.push(new V3D(157.64585429510507,72.10875624223243,34.78260869565217,6.188452623615027));
pointsA.push(new V3D(368.711214278275,179.40821158297172,34.78260869565217,4.658231770918412));
pointsA.push(new V3D(123.2421532766973,228.439851011765,34.78260869565217,1.3184330195508172));
pointsA.push(new V3D(170.38735093123265,121.42940129748614,22.988505747126435,4.800065005875774));
pointsA.push(new V3D(187.4205190056747,160.57608350437076,34.78260869565217,1.6572168720509233));
pointsA.push(new V3D(170.38735093123265,121.42940129748614,22.988505747126435,4.800065005875774));
pointsA.push(new V3D(149.49564248003733,103.12431801951647,34.78260869565217,6.215611029891952));
pointsA.push(new V3D(252.26577130208017,95.98640330349721,22.988505747126435,3.221028610293195));
pointsA.push(new V3D(196.8466877019858,137.49453143959502,34.78260869565217,0.08726646259971647));
pointsA.push(new V3D(252.26577130208017,95.98640330349721,22.988505747126435,3.221028610293195));
pointsA.push(new V3D(357.78146772271725,171.00224484058043,52.631578947368425,1.6783253008177685));
pointsA.push(new V3D(184.36896758766824,118.32252252299045,15.151515151515152,4.830486941949628));
pointsA.push(new V3D(36.735475218375356,116.87505409412857,80,5.857624182475469));
pointsA.push(new V3D(184.36896758766824,118.32252252299045,15.151515151515152,4.830486941949628));
pointsA.push(new V3D(133.54646939831022,218.25950299902436,52.631578947368425,4.685831577297629));
pointsA.push(new V3D(249.57157701611817,71.20862892084693,22.988505747126435,1.8094006327596692));
pointsA.push(new V3D(311.1765921529134,133.78569730100915,22.988505747126435,2.1785458441121195));
pointsA.push(new V3D(249.57157701611817,71.20862892084693,22.988505747126435,1.8094006327596692));
pointsA.push(new V3D(180.69903829391683,91.72765506245608,34.78260869565217,0.08447968873354537));
pointsA.push(new V3D(219.479516392135,67.13025846621719,22.988505747126435,1.6449139573445455));
pointsA.push(new V3D(163.76573023265433,73.0582801673038,52.631578947368425,6.176378295505745));
pointsA.push(new V3D(219.479516392135,67.13025846621719,22.988505747126435,1.6449139573445455));
pointsA.push(new V3D(195.31793037472752,104.63014796853338,22.988505747126435,3.053674606649211));
pointsA.push(new V3D(48.2344425734583,155.5284560055886,22.988505747126435,1.1614369870626589));
pointsA.push(new V3D(344.5862498428423,178.31573482505897,52.631578947368425,1.6792633637990955));
pointsA.push(new V3D(48.2344425734583,155.5284560055886,22.988505747126435,1.1614369870626589));
pointsA.push(new V3D(172.42087778833124,106.13478690298922,22.988505747126435,3.214655056934266));
pointsA.push(new V3D(157.45194149160363,72.02990501656078,15.151515151515152,3.0487574577893946));
pointsA.push(new V3D(188.4124654484976,103.02252578322351,34.78260869565217,0.09624057594227728));
pointsA.push(new V3D(157.45194149160363,72.02990501656078,15.151515151515152,3.0487574577893946));
pointsA.push(new V3D(161.59120983523317,247.6376691155569,52.631578947368425,1.5052597977589435));
pointsA.push(new V3D(144.2381267299047,79.44916619266958,34.78260869565217,6.201685122811361));
pointsA.push(new V3D(172.20475886476268,42.29067699456399,22.988505747126435,3.0603209464573355));
pointsA.push(new V3D(314.97030066706725,123.07594302947187,22.988505747126435,2.715048463571876));
pointsA.push(new V3D(161.71876608775025,122.06338191506974,15.151515151515152,1.8320869613300448));
pointsA.push(new V3D(314.97030066706725,123.07594302947187,22.988505747126435,2.715048463571876));
pointsA.push(new V3D(115.65292281478847,249.58693760248417,52.631578947368425,1.484498545267937));
pointsA.push(new V3D(45.09685539277825,142.41693198724587,52.631578947368425,5.869147147961676));
pointsA.push(new V3D(179.4609862660174,77.02237677242422,52.631578947368425,3.03499727641404));
pointsA.push(new V3D(45.09685539277825,142.41693198724587,52.631578947368425,5.869147147961676));
pointsA.push(new V3D(80.46701419536879,202.22945730044992,34.78260869565217,4.468459840937234));
pointsA.push(new V3D(214.12932166583946,138.89863040335632,34.78260869565217,3.8997620604328285));
pointsA.push(new V3D(324.55042192658163,143.9647265295187,22.988505747126435,1.9385944521085183));
pointsA.push(new V3D(214.12932166583946,138.89863040335632,34.78260869565217,3.8997620604328285));
pointsA.push(new V3D(251.57294873081472,63.33097291944441,22.988505747126435,1.7979390629021048));
pointsA.push(new V3D(194.26528238783715,84.13131734747384,22.988505747126435,0.07541728381754544));
pointsA.push(new V3D(197.4001052385264,137.14485348129722,52.631578947368425,3.4032860675027754));
pointsA.push(new V3D(194.26528238783715,84.13131734747384,22.988505747126435,0.07541728381754544));
pointsA.push(new V3D(26.41773798459191,174.99193638867348,22.988505747126435,6.144220287580092));
pointsA.push(new V3D(242.2884435862101,93.73132797740134,15.151515151515152,4.611493647090114));
pointsA.push(new V3D(165.37740790056796,249.309405119505,34.78260869565217,4.629320651829615));
pointsA.push(new V3D(242.2884435862101,93.73132797740134,15.151515151515152,4.611493647090114));
pointsA.push(new V3D(250.36155864957678,86.88080265247552,22.988505747126435,3.359303444178423));
pointsA.push(new V3D(291.6474225291683,135.40827220731146,34.78260869565217,4.800659751837883));
pointsA.push(new V3D(166.36177189560289,120.70107232621893,22.988505747126435,4.805320857772595));
pointsA.push(new V3D(291.6474225291683,135.40827220731146,34.78260869565217,4.800659751837883));
pointsA.push(new V3D(187.20978944018998,111.09065472012229,80,4.613407915208191));
pointsA.push(new V3D(358.7673704828616,170.53513862468952,34.78260869565217,6.189533588631395));
pointsA.push(new V3D(190.93762491024492,249.9324249430953,22.988505747126435,4.675412535732637));
pointsA.push(new V3D(358.7673704828616,170.53513862468952,34.78260869565217,6.189533588631395));
pointsA.push(new V3D(189.1813388125412,184.00144035371295,22.988505747126435,0.09214970071129511));


var pointsB = [];pointsB.push(new V3D(241.43332651169382,115.0340077164595,15.151515151515152,4.612834095113614));
pointsB.push(new V3D(274.4327133684092,225.08924055504897,22.988505747126435,2.056363839981923));
pointsB.push(new V3D(266.06549295194156,232.36356500830325,52.631578947368425,2.220545390137664));
pointsB.push(new V3D(145.63148456709047,197.7265953263278,22.988505747126435,1.3887705872438156));
pointsB.push(new V3D(112.63524128622002,67.71256520254352,80,1.6380443496097583));
pointsB.push(new V3D(235.69883615381605,49.75284342721537,10,3.236706431360336));
pointsB.push(new V3D(154.41156641992126,137.3345764481484,34.78260869565217,0.08682198431155345));
pointsB.push(new V3D(253.23596248984677,84.1885485062044,22.988505747126435,6.166167918988316));
pointsB.push(new V3D(96.54812771018283,201.9857697701129,22.988505747126435,1.6820117888004211));
pointsB.push(new V3D(28.528911047145243,210.89660144569692,52.631578947368425,1.736267064485859));
pointsB.push(new V3D(164.41133664578695,179.95646986547294,80,1.649449913747831));
pointsB.push(new V3D(55.16053166656809,156.77541109401838,22.988505747126435,5.814259218692633));
pointsB.push(new V3D(28.144240815732722,210.44513276208582,34.78260869565217,1.7858019398588922));
pointsB.push(new V3D(167.52153220672866,188.7535446084907,22.988505747126435,4.79401280468171));
pointsB.push(new V3D(43.028770344443004,214.60778674148582,34.78260869565217,1.8200804537943098));
pointsB.push(new V3D(280.0328311599747,236.89423952954226,22.988505747126435,1.818009091667021));
pointsB.push(new V3D(95.32777720338164,151.07131502367483,52.631578947368425,1.5197138676831918));
pointsB.push(new V3D(64.42927427695976,111.3300441261391,34.78260869565217,1.1517768123090664));
pointsB.push(new V3D(77.96594872681274,104.54666731389506,34.78260869565217,5.674423939114671));
pointsB.push(new V3D(60.221795305856865,164.23002567488592,22.988505747126435,5.84600072313059));
pointsB.push(new V3D(184.56063302878889,253.92036482124823,15.151515151515152,1.812037102940407));
pointsB.push(new V3D(278.62627290366373,243.93859487083756,15.151515151515152,1.4259223853807041));
pointsB.push(new V3D(285.3683068843323,239.15672555778602,34.78260869565217,1.6354087579243446));
pointsB.push(new V3D(315.06433499521285,211.09119068061048,34.78260869565217,3.2288591161895095));
pointsB.push(new V3D(127.69457828555959,193.64219233063704,22.988505747126435,4.649765855400715));
pointsB.push(new V3D(84.14131367986671,225.31404574228898,52.631578947368425,1.826556092886744));
pointsB.push(new V3D(87.60941710297695,186.84557938921208,22.988505747126435,4.641761104545919));
pointsB.push(new V3D(235.3780395237717,111.94664122707084,52.631578947368425,1.9940599258998633));
pointsB.push(new V3D(272.68506560881025,174.72366040686376,22.988505747126435,4.533313454005589));
pointsB.push(new V3D(270.65129075470946,222.89645176818382,22.988505747126435,2.2776424138061424));
pointsB.push(new V3D(272.68506560881025,174.72366040686376,22.988505747126435,4.533313454005589));
pointsB.push(new V3D(186.58708187950367,41.13765244972811,15.151515151515152,3.062453562207711));
pointsB.push(new V3D(270.93257326155384,233.30055311839348,22.988505747126435,2.060151686600131));
pointsB.push(new V3D(187.8802519446864,28.740279398998517,34.78260869565217,6.2121960139276435));
pointsB.push(new V3D(270.93257326155384,233.30055311839348,22.988505747126435,2.060151686600131));
pointsB.push(new V3D(208.8194258254529,132.30591162367966,34.78260869565217,3.6100738009737583));
pointsB.push(new V3D(101.70802307401749,144.5414758635202,34.78260869565217,0.09216851567404166));
pointsB.push(new V3D(179.19385327662027,32.59900627866903,15.151515151515152,3.062260728397644));
pointsB.push(new V3D(101.70802307401749,144.5414758635202,34.78260869565217,0.09216851567404166));
pointsB.push(new V3D(281.44094472860695,281.58827533500767,34.78260869565217,4.632604512165834));
pointsB.push(new V3D(217.14230078671247,49.42984708220393,22.988505747126435,3.1577735837007666));
pointsB.push(new V3D(188.4742557414665,29.05821474660615,15.151515151515152,6.220235475191111));
pointsB.push(new V3D(217.14230078671247,49.42984708220393,22.988505747126435,3.1577735837007666));
pointsB.push(new V3D(245.019822589006,94.06424625864392,10,3.4062247493486257));
pointsB.push(new V3D(276.7852399277431,249.30028892702265,15.151515151515152,4.62148400889371));
pointsB.push(new V3D(64.45815946068755,171.04889082428127,15.151515151515152,3.054493327054757));
pointsB.push(new V3D(276.7852399277431,249.30028892702265,15.151515151515152,4.62148400889371));
pointsB.push(new V3D(208.92458567893524,132.48884209890034,22.988505747126435,4.086684084323397));
pointsB.push(new V3D(277.66718442770093,242.58934031206132,34.78260869565217,2.0356623291106177));
pointsB.push(new V3D(112.90969966757328,117.09540585711419,52.631578947368425,3.037425128358225));
pointsB.push(new V3D(277.66718442770093,242.58934031206132,34.78260869565217,2.0356623291106177));
pointsB.push(new V3D(133.7117907940567,82.1020559523993,52.631578947368425,3.038973200879406));
pointsB.push(new V3D(152.82239890421695,244.67932912204094,52.631578947368425,4.642900421118919));
pointsB.push(new V3D(230.44981890351514,267.0382014641973,34.78260869565217,4.62317414548376));
pointsB.push(new V3D(152.82239890421695,244.67932912204094,52.631578947368425,4.642900421118919));
pointsB.push(new V3D(207.91700055365868,46.04533421927324,80,4.797096048134965));
pointsB.push(new V3D(248.9440384479691,111.19481207851251,22.988505747126435,5.880424060417181));
pointsB.push(new V3D(217.76830515894736,31.921367621042183,52.631578947368425,4.638496034095371));
pointsB.push(new V3D(248.9440384479691,111.19481207851251,22.988505747126435,5.880424060417181));
pointsB.push(new V3D(230.95378731783026,267.53177110213073,22.988505747126435,4.628161377465467));
pointsB.push(new V3D(219.71227204718593,27.5574901198766,22.988505747126435,3.2206141977556415));
pointsB.push(new V3D(265.78947901971554,219.14320187489196,22.988505747126435,2.4467478314385582));
pointsB.push(new V3D(219.71227204718593,27.5574901198766,22.988505747126435,3.2206141977556415));
pointsB.push(new V3D(197.1775198483065,25.02460298462341,22.988505747126435,6.266630864577664));
pointsB.push(new V3D(255.10337990255033,225.00727576731302,22.988505747126435,5.495213585711221));
pointsB.push(new V3D(145.4079262056513,132.09032912588484,80,4.626078429211739));
pointsB.push(new V3D(255.10337990255033,225.00727576731302,22.988505747126435,5.495213585711221));
pointsB.push(new V3D(218.23213242279667,163.33529562945606,52.631578947368425,1.9548138503454662));
pointsB.push(new V3D(174.55997359549966,250.8358976823593,34.78260869565217,4.6442492332007514));
pointsB.push(new V3D(63.814652145655145,75.72928837048313,80,1.6452345751583597));
pointsB.push(new V3D(174.55997359549966,250.8358976823593,34.78260869565217,4.6442492332007514));
pointsB.push(new V3D(129.3652552632267,187.29571846723258,22.988505747126435,4.7698555712343325));
pointsB.push(new V3D(227.84587116316953,51.203717120365944,22.988505747126435,2.4852451208598776));
pointsB.push(new V3D(211.77664611166315,35.22697527605041,15.151515151515152,0.08210915509529691));
pointsB.push(new V3D(227.84587116316953,51.203717120365944,22.988505747126435,2.4852451208598776));
pointsB.push(new V3D(194.59651935820764,28.799419579447704,22.988505747126435,3.0089719987796832));
pointsB.push(new V3D(248.72826689567896,110.76274670210408,34.78260869565217,4.438088491463683));
pointsB.push(new V3D(113.63528537381113,80.81474370257418,22.988505747126435,3.3234868358400336));
pointsB.push(new V3D(248.72826689567896,110.76274670210408,34.78260869565217,4.438088491463683));
pointsB.push(new V3D(186.12520638640837,32.15914029452661,22.988505747126435,6.201832768932594));
pointsB.push(new V3D(165.97336388040353,178.39144735073404,22.988505747126435,4.4483685894391725));
pointsB.push(new V3D(212.14533109976063,21.102601662885956,22.988505747126435,4.786632266907452));
pointsB.push(new V3D(165.97336388040353,178.39144735073404,22.988505747126435,4.4483685894391725));
pointsB.push(new V3D(186.06188870736358,29.42694045693559,52.631578947368425,1.6524688774883562));
pointsB.push(new V3D(55.36779943812813,157.03827402586234,15.151515151515152,5.822662010512528));
pointsB.push(new V3D(249.32886929243753,272.4887652436235,22.988505747126435,4.632559702490989));
pointsB.push(new V3D(55.36779943812813,157.03827402586234,15.151515151515152,5.822662010512528));
pointsB.push(new V3D(197.3937628572243,256.1107787125596,52.631578947368425,4.639865821044294));
pointsB.push(new V3D(238.70866211189465,102.12739635164164,15.151515151515152,1.6772208719784831));
pointsB.push(new V3D(191.3078964176934,23.02913725986216,34.78260869565217,6.2178652161923385));
pointsB.push(new V3D(238.70866211189465,102.12739635164164,15.151515151515152,1.6772208719784831));
pointsB.push(new V3D(179.25348522340528,31.751199804958638,34.78260869565217,6.218130777292262));
pointsB.push(new V3D(218.3348460227072,155.91722069419012,34.78260869565217,1.891988768071152));
pointsB.push(new V3D(238.77116486743182,269.1343507336963,34.78260869565217,4.6229193385589475));
pointsB.push(new V3D(218.3348460227072,155.91722069419012,34.78260869565217,1.891988768071152));
pointsB.push(new V3D(145.01114446221152,132.1631771791629,22.988505747126435,1.6699946274051558));
pointsB.push(new V3D(230.1437063889223,56.85877265891333,34.78260869565217,6.198838852157871));
pointsB.push(new V3D(209.65074982775883,77.82157730420658,22.988505747126435,4.798159337765308));
pointsB.push(new V3D(230.1437063889223,56.85877265891333,34.78260869565217,6.198838852157871));
pointsB.push(new V3D(231.06418480459712,146.04088985936355,80,1.9819482124410956));
pointsB.push(new V3D(68.30915292679627,110.05019218728228,34.78260869565217,1.1576165226975685));
pointsB.push(new V3D(152.74774889812423,61.56968610553412,34.78260869565217,6.207076185481917));
pointsB.push(new V3D(68.30915292679627,110.05019218728228,34.78260869565217,1.1576165226975685));
pointsB.push(new V3D(64.08591699641948,79.7520396702673,34.78260869565217,3.2335174997865868));
pointsB.push(new V3D(178.59778493344686,26.272434552646512,34.78260869565217,1.6577182795480687));
pointsB.push(new V3D(84.43519759578231,225.61225933633548,34.78260869565217,1.7868453046070174));
pointsB.push(new V3D(178.59778493344686,26.272434552646512,34.78260869565217,1.6577182795480687));
pointsB.push(new V3D(226.76627479536626,24.16981195724059,22.988505747126435,3.2529713615797133));
pointsB.push(new V3D(217.93858213251042,155.4736654059414,52.631578947368425,1.944936743486145));
pointsB.push(new V3D(264.295885750173,277.15981176737733,34.78260869565217,4.638281979470205));
pointsB.push(new V3D(217.93858213251042,155.4736654059414,52.631578947368425,1.944936743486145));
pointsB.push(new V3D(258.64695759974,209.9468030708407,22.988505747126435,2.5973654318361206));
pointsB.push(new V3D(254.81001681976716,225.17975009400348,34.78260869565217,2.3817799946845724));
pointsB.push(new V3D(188.73680263792986,37.76735395554441,15.151515151515152,3.0554622818794734));
pointsB.push(new V3D(254.81001681976716,225.17975009400348,34.78260869565217,2.3817799946845724));
pointsB.push(new V3D(217.005855003775,49.85754596159699,34.78260869565217,6.228156329113908));
pointsB.push(new V3D(256.12181712633566,224.7351771709503,10,5.501460434430396));
pointsB.push(new V3D(87.4268576565928,187.5925620665418,10,4.786119796120563));
pointsB.push(new V3D(256.12181712633566,224.7351771709503,10,5.501460434430396));
pointsB.push(new V3D(160.08011838354665,102.63662682349691,52.631578947368425,3.04575825652602));
pointsB.push(new V3D(361.8886451243399,96.22591747199117,80,5.441741510255115));
pointsB.push(new V3D(212.65855833740312,136.5075830752102,52.631578947368425,3.716536086303452));
pointsB.push(new V3D(361.8886451243399,96.22591747199117,80,5.441741510255115));
pointsB.push(new V3D(280.0874072719437,226.8589180963679,22.988505747126435,1.9843997867209549));
pointsB.push(new V3D(347.6913508319068,23.340251863535087,80,5.367483155499965));
pointsB.push(new V3D(193.08660027127897,256.2022822113311,34.78260869565217,4.646162420088685));
pointsB.push(new V3D(347.6913508319068,23.340251863535087,80,5.367483155499965));
pointsB.push(new V3D(241.5047457722596,171.28129261075415,52.631578947368425,4.6258153678249325));
pointsB.push(new V3D(194.28264875296176,73.12246102538764,52.631578947368425,1.3300388095344942));
pointsB.push(new V3D(242.75144024814898,101.11902160143332,10,3.4753373178850366));
pointsB.push(new V3D(194.28264875296176,73.12246102538764,52.631578947368425,1.3300388095344942));
pointsB.push(new V3D(214.61485159876875,262.6817462949367,22.988505747126435,4.633799153243476));
pointsB.push(new V3D(242.22254925513278,100.60862370421636,22.988505747126435,1.8456773353207219));
pointsB.push(new V3D(186.20795497998813,62.66335228022752,52.631578947368425,4.788775197480201));
pointsB.push(new V3D(242.22254925513278,100.60862370421636,22.988505747126435,1.8456773353207219));
pointsB.push(new V3D(203.2410030816456,24.80510264876305,22.988505747126435,0.046353849524039745));
pointsB.push(new V3D(214.44710316636403,60.89832083350025,22.988505747126435,4.459295354023368));
pointsB.push(new V3D(273.7424501806664,245.5096872624708,10,2.176260785750544));
pointsB.push(new V3D(214.44710316636403,60.89832083350025,22.988505747126435,4.459295354023368));
pointsB.push(new V3D(112.2191587495311,137.97417083616926,22.988505747126435,1.6557454503492595));
pointsB.push(new V3D(205.10653603137303,21.417545289132224,34.78260869565217,0.02564098861567752));
pointsB.push(new V3D(239.34337067594598,109.50003255329787,15.151515151515152,4.5953277469324645));
pointsB.push(new V3D(205.10653603137303,21.417545289132224,34.78260869565217,0.02564098861567752));
pointsB.push(new V3D(242.5431892671627,100.93403458948794,15.151515151515152,3.3843807250891405));
pointsB.push(new V3D(273.0406530590867,244.7297693215255,22.988505747126435,2.1181468117792512));
pointsB.push(new V3D(121.52356992011741,190.04376032601493,22.988505747126435,4.666425239423203));
pointsB.push(new V3D(273.0406530590867,244.7297693215255,22.988505747126435,2.1181468117792512));
pointsB.push(new V3D(268.78265340571403,235.03286839219345,15.151515151515152,5.4663373119370675));
pointsB.push(new V3D(196.77896722412402,24.662456296291207,34.78260869565217,1.1289573542808435));
pointsB.push(new V3D(248.81416344239707,272.17366962340475,34.78260869565217,4.631409633371374));
pointsB.push(new V3D(196.77896722412402,24.662456296291207,34.78260869565217,1.1289573542808435));
pointsB.push(new V3D(212.70042621701117,261.0373115519148,52.631578947368425,4.628450926541339));
pointsB.push(new V3D(183.88206827067793,253.26647962005953,34.78260869565217,4.649084837256409));
pointsB.push(new V3D(115.2771979340208,233.62117572852037,34.78260869565217,4.637506164777126));
pointsB.push(new V3D(183.88206827067793,253.26647962005953,34.78260869565217,4.649084837256409));
pointsB.push(new V3D(209.44476072561508,77.26818221131268,34.78260869565217,4.660459744622222));
pointsB.push(new V3D(226.2397593164009,34.889457854963354,34.78260869565217,1.979061919118894));
pointsB.push(new V3D(211.50048701976226,35.52827854942362,22.988505747126435,4.794075632506391));
pointsB.push(new V3D(226.2397593164009,34.889457854963354,34.78260869565217,1.979061919118894));
pointsB.push(new V3D(111.51026559818769,142.2051129583629,15.151515151515152,4.250625217615345));
pointsB.push(new V3D(194.46753313976654,37.553781507784166,22.988505747126435,3.069899051673601));
pointsB.push(new V3D(76.00658975974007,58.79358713661925,80,1.6541033712574702));
pointsB.push(new V3D(194.46753313976654,37.553781507784166,22.988505747126435,3.069899051673601));
pointsB.push(new V3D(63.00748656662638,76.04772415927741,34.78260869565217,3.2317607987605523));
pointsB.push(new V3D(230.0255074829661,34.53881988551862,15.151515151515152,3.2090540103462044));
pointsB.push(new V3D(84.4407840386581,192.16408437692297,15.151515151515152,4.795026620729893));
pointsB.push(new V3D(230.0255074829661,34.53881988551862,15.151515151515152,3.2090540103462044));
pointsB.push(new V3D(186.01076143960148,29.06010284766221,80,6.1919482859119785));
pointsB.push(new V3D(257.83340440218325,237.05987238448748,22.988505747126435,5.4849228760020825));
pointsB.push(new V3D(72.29431572060875,222.67326897534662,34.78260869565217,1.7699172930233495));
pointsB.push(new V3D(257.83340440218325,237.05987238448748,22.988505747126435,5.4849228760020825));
pointsB.push(new V3D(52.091377890942844,176.76133079445663,22.988505747126435,0.08678346718265732));
pointsB.push(new V3D(255.8884167069213,224.69630056434622,15.151515151515152,5.500907151247925));
pointsB.push(new V3D(181.40228099109157,62.97074973691869,22.988505747126435,1.1523811121102954));
pointsB.push(new V3D(255.8884167069213,224.69630056434622,15.151515151515152,5.500907151247925));
pointsB.push(new V3D(225.3188366366638,136.8493848702306,52.631578947368425,4.683061978419743));
pointsB.push(new V3D(87.01833322630792,190.65912920649848,22.988505747126435,4.652657821575439));
pointsB.push(new V3D(224.17287110711385,47.37493369547874,34.78260869565217,4.813068360454131));
pointsB.push(new V3D(87.01833322630792,190.65912920649848,22.988505747126435,4.652657821575439));
pointsB.push(new V3D(210.04927381796108,72.45970315748212,34.78260869565217,4.787207160182012));
pointsB.push(new V3D(225.24692661531938,42.065814439403916,15.151515151515152,0.16296730357111205));
pointsB.push(new V3D(186.23028377326224,41.32451849894096,22.988505747126435,1.1568572644189816));
pointsB.push(new V3D(225.24692661531938,42.065814439403916,15.151515151515152,0.16296730357111205));
pointsB.push(new V3D(222.12952503305613,44.85463547830702,22.988505747126435,3.120974839901538));
pointsB.push(new V3D(253.97144873612976,229.44899065951788,34.78260869565217,2.3322308068712885));
pointsB.push(new V3D(112.47942715693159,137.83634149964794,15.151515151515152,4.26412039587573));
pointsB.push(new V3D(253.97144873612976,229.44899065951788,34.78260869565217,2.3322308068712885));
pointsB.push(new V3D(195.1098538423715,74.88770846145587,34.78260869565217,4.796007766981147));
pointsB.push(new V3D(285.960161523017,240.14440189313652,15.151515151515152,4.666235590134837));
pointsB.push(new V3D(194.64606060218733,19.443440318046115,34.78260869565217,6.190998310216703));
pointsB.push(new V3D(285.960161523017,240.14440189313652,15.151515151515152,4.666235590134837));
pointsB.push(new V3D(118.95840966639982,202.21701825706972,22.988505747126435,1.4704745635302694));
pointsB.push(new V3D(200.42004275994162,71.59115484998736,34.78260869565217,4.800027211834075));
pointsB.push(new V3D(189.99931846853912,140.90820317387096,52.631578947368425,1.6725237301284681));
pointsB.push(new V3D(200.42004275994162,71.59115484998736,34.78260869565217,4.800027211834075));
pointsB.push(new V3D(186.20330132502446,46.49188028997092,34.78260869565217,6.199453521370897));
pointsB.push(new V3D(315.2636109348518,19.927291974691926,80,6.213526315204685));
pointsB.push(new V3D(213.89491525676294,100.7159874321753,34.78260869565217,0.08160624746495011));
pointsB.push(new V3D(315.2636109348518,19.927291974691926,80,6.213526315204685));
pointsB.push(new V3D(276.9295776047307,234.6027964692714,34.78260869565217,2.082373280645057));
pointsB.push(new V3D(214.08803781530764,69.22626109898262,22.988505747126435,4.783338321910495));
pointsB.push(new V3D(70.35874466687115,88.26317288661747,34.78260869565217,5.6557680049235834));
pointsB.push(new V3D(214.08803781530764,69.22626109898262,22.988505747126435,4.783338321910495));
pointsB.push(new V3D(124.07747061232432,198.21199432956232,22.988505747126435,4.778347408576871));
pointsB.push(new V3D(243.4615326518556,94.31347620264859,34.78260869565217,2.0016506760236608));
pointsB.push(new V3D(272.4846477628357,174.29066489527187,34.78260869565217,3.9365662679329896));
pointsB.push(new V3D(243.4615326518556,94.31347620264859,34.78260869565217,2.0016506760236608));
pointsB.push(new V3D(219.66541287244758,37.77711550322713,22.988505747126435,0.09183445927058657));
pointsB.push(new V3D(226.21584690789808,71.80800312652819,15.151515151515152,3.7686134016845694));
pointsB.push(new V3D(203.23857955452706,15.743164519029332,34.78260869565217,6.1973820106802435));
pointsB.push(new V3D(226.21584690789808,71.80800312652819,15.151515151515152,3.7686134016845694));
pointsB.push(new V3D(229.8190098105492,56.22739350539827,15.151515151515152,3.1736126270840863));
pointsB.push(new V3D(52.554426941717615,175.9355898965038,34.78260869565217,3.0536979794573105));
pointsB.push(new V3D(267.62253991353623,233.65452530186627,34.78260869565217,2.1814675471882947));
pointsB.push(new V3D(52.554426941717615,175.9355898965038,34.78260869565217,3.0536979794573105));
pointsB.push(new V3D(212.14926383214578,46.02680607434627,22.988505747126435,3.062612700247697));
pointsB.push(new V3D(195.03491696410856,28.727440562047278,15.151515151515152,4.316234553015761));
pointsB.push(new V3D(218.42105263157893,55.26315789473684,52.631578947368425,1.5337674223908853));
pointsB.push(new V3D(195.03491696410856,28.727440562047278,15.151515151515152,4.316234553015761));
pointsB.push(new V3D(131.94888412081173,237.9050599015586,22.988505747126435,1.8320123892738633));
pointsB.push(new V3D(181.34713079588926,27.19584848178188,34.78260869565217,6.211278959491956));
pointsB.push(new V3D(180.26093658195586,57.24568127017296,22.988505747126435,1.1424123792935863));
pointsB.push(new V3D(265.145987410867,175.39197420676658,80,2.738171729165077));
pointsB.push(new V3D(191.59618313456923,71.01938203141486,15.151515151515152,2.3659546401220055));
pointsB.push(new V3D(265.145987410867,175.39197420676658,80,2.738171729165077));
pointsB.push(new V3D(100.30352727052852,230.8672342951023,52.631578947368425,1.7867809422884025));
pointsB.push(new V3D(49.45008976345402,172.67042068981945,15.151515151515152,2.5477250753692577));
pointsB.push(new V3D(199.0244000066711,51.10628844915693,52.631578947368425,1.4719826377098695));
pointsB.push(new V3D(49.45008976345402,172.67042068981945,15.151515151515152,2.5477250753692577));
pointsB.push(new V3D(87.81378009516507,186.31637286606133,34.78260869565217,4.637562897227491));
pointsB.push(new V3D(226.7834215937807,115.5252020194584,10,4.79751056105525));
pointsB.push(new V3D(294.99111467416276,175.85366442607906,34.78260869565217,5.278250083016119));
pointsB.push(new V3D(226.7834215937807,115.5252020194584,10,4.79751056105525));
pointsB.push(new V3D(250.56954444610975,77.26121874297625,52.631578947368425,2.005509257524052));
pointsB.push(new V3D(218.4746161395446,64.94810513434734,15.151515151515152,1.116620440142059));
pointsB.push(new V3D(206.91270788023743,115.61177087889612,34.78260869565217,3.624529164939201));
pointsB.push(new V3D(218.4746161395446,64.94810513434734,15.151515151515152,1.116620440142059));
pointsB.push(new V3D(53.56327893445759,153.02865293190453,15.151515151515152,5.7894349878431175));
pointsB.push(new V3D(237.85530667686393,106.83265705534721,15.151515151515152,4.635559499223594));
pointsB.push(new V3D(130.53943213317194,237.6182170172962,34.78260869565217,4.63898106499767));
pointsB.push(new V3D(237.85530667686393,106.83265705534721,15.151515151515152,4.635559499223594));
pointsB.push(new V3D(247.48714724080762,101.70638589055469,15.151515151515152,3.377112710953799));
pointsB.push(new V3D(355.05780780583956,68.38336154155382,80,5.44868238457952));
pointsB.push(new V3D(196.57313173480654,70.91181900481176,34.78260869565217,4.794863374527062));
pointsB.push(new V3D(355.05780780583956,68.38336154155382,80,5.44868238457952));
pointsB.push(new V3D(214.5204856903145,65.29608811545803,52.631578947368425,4.807690821201589));
pointsB.push(new V3D(312.68701339627466,209.98307486764367,80,1.6403995284325885));
pointsB.push(new V3D(329.7140286958257,27.503975599268987,80,5.3958292185829695));
pointsB.push(new V3D(312.68701339627466,209.98307486764367,80,1.6403995284325885));
pointsB.push(new V3D(169.018031830852,181.79481938523045,15.151515151515152,0.25278505104202426));



/*
// only 1:
GLOBALSTAGE.root().matrix().scale(2.0);
var indee = 1; // 0,3,8
var pointsA = [ pointsA[indee] ];
var pointsB = [ pointsB[indee] ];
*/



/*
// TEST zoom/rotated images
pointsA = [
			new V2D(240.5,161.5), // armpit
			new V2D(187.5,181.0), // origin
			new V2D(182.0,218.0), // grid corner
			new V2D(220.0,211.0), // brick
			new V2D(280.0,137.0), // right mouth
			];
pointsB = [
			new V2D(230.0,169.0),
			new V2D(120.5,151.5), // origin
			new V2D( 71.0,209.0), // grid corner
			new V2D(144.5,234.0), // brick
			new V2D(325.0,166.0), // right mouth
			];
*/

// from medium:
/// ...

// // flip for tests:
// var imageMatrixC = imageMatrixA;
// var pointsC = pointsA;
// imageMatrixA = imageMatrixB;
// pointsA = pointsB;
// imageMatrixB = imageMatrixC;
// pointsB = pointsC;

	var images = [];
	//var imageList = Code.arrayReverse(imageList);
	for(i=0;i<imageList.length;++i){
		var img = imageList[i];
		var d = new DOImage(img);
		this._root.addChild(d);
		d.graphics().alpha(0.5);
		//d.graphics().alpha(1.0);
		//d.graphics().alpha(0.0);
		d.matrix().translate(x,y);
		x += img.width;
	}




	var i, j, c, d, point, color, rad;

	rad = 3;
	for(i=0; i<pointsA.length; ++i){
		point = pointsA[i];
		color = 0xFFFF0000;
		c = new DO();
		c.graphics().setLine(1.0, color);
		c.graphics().beginPath();
		c.graphics().drawCircle(point.x, point.y, rad);
		c.graphics().strokeLine();
		c.graphics().endPath();
		//GLOBALSTAGE.addChild(c);
		//
		point = pointsB[i];
		color = 0xFF0000FF;
		c = new DO();
		c.graphics().setLine(1.0, color);
		c.graphics().beginPath();
		c.graphics().drawCircle(point.x, point.y, rad);
		c.graphics().strokeLine();
		c.graphics().endPath();
		c.matrix().translate(imageMatrixA.width(), 0);
		//GLOBALSTAGE.addChild(c);
	}


// exact for testUniq
// pointsB = pointsA;
// imageMatrixB = imageMatrixA;


Dense.DISPLAY = new DO();
GLOBALSTAGE.addChild(Dense.DISPLAY);
this._stage.root().matrix().translate(30,50);

	//GLOBALSTAGE.root().matrix().identity().translate(100,100);

	GLOBALSTAGE.root().matrix().scale(1.5);
	//this.testFeatureComparison(imageMatrixA,pointsA, imageMatrixB,pointsB);
	//this.testImageScaling(imageMatrixA,pointsA);
	//this.testSeedOptimization(imageMatrixA,pointsA, imageMatrixB,pointsB);
	//this.testSimilarityMetrics(imageMatrixA,pointsA, imageMatrixB,pointsB);
	//this.testEntropy(imageMatrixA,pointsA, imageMatrixB,pointsB);
//this.testUniqueness(imageMatrixA,pointsA, imageMatrixB,pointsB);
	Dense.denseMatch(imageMatrixA,pointsA, imageMatrixB,pointsB, this);
}
Dense.prototype.testSeedOptimization = function(imageA,pointsA, imageB,pointsB){

}
Dense.prototype.testImageScaling = function(image,points){
	var imageGry = image.gry();
	var imageWidth = image.width();
	var imageHeight = image.height();
	var point = new V2D(100,100);
	var scale = 2.0;
	var scaled = Code.scaleImage(imageGry,imageWidth,imageHeight, point,scale);
	console.log(scaled);
}
Dense.prototype.testUniqueness = function(imageA,pointsA, imageB,pointsB){
	console.log("testUniqueness")
	// get scores of matched areas
	// areas with non-uniqueness response => penalty
	var imageAGry = imageA.gry();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();
	var imageBGry = imageB.gry();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();

	var index = 0;
	var pointA = pointsA[index];
	var pointB = pointsB[index];


	// trash
	// pointA = new V2D(89,163);
	// pointB = new V2D(200,200);
	// pointA = new V2D(240,270);
	// pointB = new V2D(200,50);
	// pointA = new V2D(11,265);
	// pointB = new V2D(250,130);


	// pattern
	// pointA = new V2D(165,150);
	// pointB = new V2D(160,150);
	// pointA = new V2D(50,50);
	// pointB = new V2D(100,100);
	// pointA = new V2D(350,40);
	// pointB = new V2D(350,70);


	// blank
	// pointA = new V2D(130,250);
	// pointB = new V2D(150,250);
	// pointA = new V2D(30,260);
	// pointB = new V2D(170,240);


	var uniquenessMap = Dense.uniquenessMap(imageA);
	var values = ImageMat.normalFloat01(Code.copyArray(uniquenessMap));
		var c = values;
		//c = ImageMat.invertFloat(c);
		//c = ImageMat.normalFloat01(c);
		c = Code.grayscaleFloatToHeatMapFloat(c);
	img = GLOBALSTAGE.getFloatRGBAsImage(c["red"],c["grn"],c["blu"], imageA.width(),imageA.height());
	//img = GLOBALSTAGE.getFloatRGBAsImage(values,values,values, imageA.width(),imageA.height());
	d = new DOImage(img);
	d.matrix().translate(10, 10);
	GLOBALSTAGE.addChild(d);

return;


	// blank space
	// pointA = new V2D(45,209);
	// pointB = new V2D(65,139);

	// pattern top right
	// pointA = new V2D(356,63);
	// pointB = new V2D(363,87);



	var scale = 1.0;
	var rotation = Code.radians(0.0);
	var needleSize = 11;
	var haystackSize = 55;
	var sigma = null;
	var matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DScale(matrix,scale);
		matrix = Matrix.transform2DRotate(matrix,rotation);
	var needleMask = ImageMat.circleMask(needleSize);
	var needle = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,1.0,sigma,needleSize,needleSize, imageAGry,imageAWidth,imageAHeight, matrix);
	var matrix = new Matrix(3,3).identity();
	var haystack = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0,sigma,haystackSize,haystackSize, imageBGry,imageBWidth,imageBHeight, matrix);

	img = GLOBALSTAGE.getFloatRGBAsImage(needle,needle,needle, needleSize,needleSize);
	d = new DOImage(img);
	d.matrix().translate(20, 320);
	GLOBALSTAGE.addChild(d);

	img = GLOBALSTAGE.getFloatRGBAsImage(haystack,haystack,haystack, haystackSize,haystackSize);
	d = new DOImage(img);
	d.matrix().translate(120, 320);
	GLOBALSTAGE.addChild(d);


	var uniqueness = Dense.uniqueness(needle,needleSize,needleSize,needleMask,   haystack,haystackSize,haystackSize);



console.log("uniqueness: "+uniqueness);

return;

	var scores = Dense.searchNeedleHaystack(needle,needleSize,needleSize,needleMask, haystack,haystackSize,haystackSize);
	var values = scores.value;
	var width = scores.width;
	var height = scores.height;
	var windowCenterX = Math.floor(needleSize*0.5);
	var windowCenterY = Math.floor(needleSize*0.5);
	var c = ImageMat.normalFloat01(Code.copyArray(values));
		c = Code.grayscaleFloatToHeatMapFloat(c);
	img = GLOBALSTAGE.getFloatRGBAsImage(c["red"],c["grn"],c["blu"], width,height);
	d = new DOImage(img);
	d.matrix().translate(120 + windowCenterX, 320 + windowCenterY);
	d.graphics().alpha(0.5);
	GLOBALSTAGE.addChild(d);
/*
	var str = "\n\ny = [";
	for(var i=0; i<values.length; ++i){
		str = str + values[i].toExponential(3) + ",";
	}
	str = str + "];\n";
	str = str + "plot(y,'r-x');\n\n";
console.log(str);
*/
	var uniqueness = Dense.uniquenessFromScores(values);
	console.log(uniqueness);

}
Dense.entropyImage = function(imageAGry, imageAWidth,imageAHeight){
	var imageEntropy = Code.newArrayZeros(imageAWidth*imageAHeight);
	var needleSize = 11; // 11
	var needleCenter = needleSize*0.5 | 0;
	var needleMask = ImageMat.circleMask(needleSize);
	var i, j;
	for(j=0; j<imageAHeight; ++j){
		for(i=0; i<imageAWidth; ++i){
			var needle = ImageMat.subImage(imageAGry,imageAWidth,imageAHeight, i-needleCenter,j-needleCenter, needleSize,needleSize);
			var entropy = Code.entropy01(needle, needleMask);
			imageEntropy[j*imageAWidth + i] = entropy;
		}
	}
	return imageEntropy;
}

Dense.genericImage = function(imageAGry, imageAWidth,imageAHeight, fxn){
	var imageRange = Code.newArrayZeros(imageAWidth*imageAHeight);
	var needleSize = 11; // 11
	var needleCenter = needleSize*0.5 | 0;
	var needleMask = ImageMat.circleMask(needleSize);
	var i, j;
	for(j=0; j<imageAHeight; ++j){
		for(i=0; i<imageAWidth; ++i){
			//var needle = ImageMat.subImage(imageAGry,imageAWidth,imageAHeight, i-needleCenter,j-needleCenter, needleSize,needleSize);
			var needle = ImageMat.extractRectFromFloatImage(i-needleCenter,j-needleCenter,1.0,null,needleSize,needleSize, imageAGry,imageAWidth,imageAHeight, null);	
			imageRange[j*imageAWidth + i] = fxn(needle,needleMask,needleSize,needleSize);
		}
		console.log(j+"/"+imageAHeight);
	}
	return imageRange;
}
Dense.gradientImage = function(imageAGry, imageAWidth,imageAHeight){
	//???
}
Dense.rangeImage = function(imageAGry, imageAWidth,imageAHeight){
	var fxn = function(needle, needleMask){
		var info = Code.infoArray(needle, needleMask);
		var range = info["range"];
		return range;
	}
	return Dense.genericImage(imageAGry, imageAWidth,imageAHeight, fxn);
}


Dense.uniquenessImage = function(imageAGry,imageAWidth,imageAHeight, imageBGry,imageBWidth,imageBHeight, point){
	point = point!==undefined ? point : new V2D(70, 100);
	//point = new V2D(200,200);
	//point = new V2D(350,50);
	//point = new V2D(60,225);
	//point = new V2D(350,50);
	//point = new V2D(190,180);
	//point = new V2D(260,103);
	//point = new V2D(216,154);
	//point = new V2D(202,127);
	//point = new V2D(94,176);
	point = new V2D(18,225+15);
	var haySize = 19; // 11
	//var haySize = 51; // 11
	var hayCenter = haySize*0.5 | 0;
	var hayPoint = ImageMat.subImage(imageAGry,imageAWidth,imageAHeight, point.x-hayCenter,point.y-hayCenter, haySize,haySize);

	var fxn = function(needle, needleMask, needleWidth, needleHeight){
		var uniqueness = Dense.uniqueness(needle,needleWidth,needleHeight,needleMask,   hayPoint,haySize,haySize);
		return uniqueness;
	}
	return Dense.genericImage(imageBGry, imageBWidth,imageBHeight, fxn);
}



Dense.prototype.testEntropy = function(imageA,pointsA, imageB,pointsB){
	var imageAGry = imageA.gry();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();
	var imageBGry = imageB.gry();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();
// ENTROPY
/*
	imageEntropy = Dense.entropyImage(imageAGry,imageAWidth,imageAHeight);
	var c = ImageMat.normalFloat01(Code.copyArray(imageEntropy));
	c = Code.grayscaleFloatToHeatMapFloat(c);
	img = GLOBALSTAGE.getFloatRGBAsImage(c["red"],c["grn"],c["blu"], imageAWidth,imageAHeight);
	d = new DOImage(img);
	d.matrix().translate(0,0);
	GLOBALSTAGE.addChild(d);

	imageEntropy = Dense.entropyImage(imageBGry,imageBWidth,imageBHeight);
	var c = ImageMat.normalFloat01(Code.copyArray(imageEntropy));
	c = Code.grayscaleFloatToHeatMapFloat(c);
	img = GLOBALSTAGE.getFloatRGBAsImage(c["red"],c["grn"],c["blu"], imageBWidth,imageBHeight);
	d = new DOImage(img);
	d.matrix().translate(400,0);
	GLOBALSTAGE.addChild(d);

// RANGE
/*
	imageRange = Dense.rangeImage(imageAGry,imageAWidth,imageAHeight);
	var c = ImageMat.normalFloat01(Code.copyArray(imageRange));
	c = Code.grayscaleFloatToHeatMapFloat(c);
	img = GLOBALSTAGE.getFloatRGBAsImage(c["red"],c["grn"],c["blu"], imageAWidth,imageAHeight);
	d = new DOImage(img);
	d.matrix().translate(0,0);
	GLOBALSTAGE.addChild(d);

	imageRange = Dense.rangeImage(imageBGry,imageBWidth,imageBHeight);
	var c = ImageMat.normalFloat01(Code.copyArray(imageRange));
	c = Code.grayscaleFloatToHeatMapFloat(c);
	img = GLOBALSTAGE.getFloatRGBAsImage(c["red"],c["grn"],c["blu"], imageBWidth,imageBHeight);
	d = new DOImage(img);
	d.matrix().translate(400,0);
	GLOBALSTAGE.addChild(d);
*/

// UNIQUENESS

	imageRange = Dense.uniquenessImage(imageAGry,imageAWidth,imageAHeight, imageBGry,imageBWidth,imageBHeight);
console.log(imageRange);
	var c = ImageMat.normalFloat01(Code.copyArray(imageRange));
	c = Code.grayscaleFloatToHeatMapFloat(c);
	img = GLOBALSTAGE.getFloatRGBAsImage(c["red"],c["grn"],c["blu"], imageAWidth,imageAHeight);
	d = new DOImage(img);
	d.matrix().translate(0,0);
	GLOBALSTAGE.addChild(d);

	imageRange = Dense.uniquenessImage(imageBGry,imageBWidth,imageBHeight, imageAGry,imageAWidth,imageAHeight);
	var c = ImageMat.normalFloat01(Code.copyArray(imageRange));
	c = Code.grayscaleFloatToHeatMapFloat(c);
	img = GLOBALSTAGE.getFloatRGBAsImage(c["red"],c["grn"],c["blu"], imageBWidth,imageBHeight);
	d = new DOImage(img);
	d.matrix().translate(400,0);
	GLOBALSTAGE.addChild(d);

// gradient angle
// gradient magnitude
// ssd ?????
// 

return;

	//var points = R3D.entropyExtract(imageA);
	var points = R3D.harrisExtract(imageA);
	console.log(points)

	for(var k=0; k<points.length; ++k){
		var point = points[k];
		//console.log(""+point)
		var x = point.x*imageA.width();
		var y = point.y*imageA.height();
		var z = point.z;
		var c = new DO();
		//color = 0xFFFF0000;
		color = 0xFFFFFFFF;
		c.graphics().setLine(2, color);
		c.graphics().beginPath();
		c.graphics().drawCircle(x, y, z);
		c.graphics().strokeLine();
		c.graphics().endPath();
		//c.matrix().translate(0 + (f>0 ? images[f-1].width(): 0), 0);
		GLOBALSTAGE.addChild(c);
	}


	//var points = R3D.entropyExtract(imageB);
	var points = R3D.harrisExtract(imageB);
	console.log(points)

	for(var k=0; k<points.length; ++k){
		var point = points[k];
		//console.log(""+point)
		var x = point.x*imageA.width();
		var y = point.y*imageB.height();
		var z = point.z;
		var c = new DO();
		//color = 0xFFFF0000;
		color = 0xFFFFFFFF;
		c.graphics().setLine(2, color);
		c.graphics().beginPath();
		c.graphics().drawCircle(x, y, z);
		c.graphics().strokeLine();
		c.graphics().endPath();
		//c.matrix().translate(0 + (f>0 ? images[f-1].width(): 0), 0);
		c.matrix().translate(400,0);
		GLOBALSTAGE.addChild(c);
	}

return;



	// imageA = imageB;
	// pointsA = pointsB;

	
	//
	var pointA = pointsA[0];
	//
	var rotation = Code.radians(0);
var zoom = 4.0;
	//var scale = 1.9 * zoom;
	var scale = 1.0 * zoom;
	var needleSize = (11 * zoom) | 0;
	var sigma = null;
	var matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DScale(matrix,scale);
		matrix = Matrix.transform2DRotate(matrix,rotation);
	
	var needleMask = ImageMat.circleMask(needleSize);
	var needle = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,1.0,sigma,needleSize,needleSize, imageAGry,imageAWidth,imageAHeight, matrix);	
	var entropy = Code.entropy01(needle, needleMask);
	console.log(entropy+"");

	img = GLOBALSTAGE.getFloatRGBAsImage(needle,needle,needle, needleSize,needleSize);
	d = new DOImage(img);
	d.matrix().translate(20, 20);
	GLOBALSTAGE.addChild(d);
}
Dense.prototype.testSimilarityMetrics = function(imageA,pointsA, imageB,pointsB){
//GLOBALSTAGE.root().matrix().scale(0.70);
//GLOBALSTAGE.root().matrix().scale(2.0);
console.log("testSimilarityMetrics");
	var i, j, matrix, img, a, b, c, d;
	var imageAGry = imageA.gry();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();
	var imageBGry = imageB.gry();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();
	var pointA = new V2D(208,149); // foot
		var pointB = new V2D(220,140);
	//var point = new V2D(173,107); // grid corner
	// var pointA = new V2D(243,100); //armpit
	// 	var pointB = new V2D(220,90);
//var needleSize = 21;
//var needleSize = 12;
//var needleSize = 24;
// 12, 16, 20, 24
var needleSize = 21;
//var needleSize = 12;
//var needleSize = 20;
//var needleSize = 50;
	var haystackSize = 150;
	var mask = ImageMat.circleMask(needleSize);
	var rotation = Code.radians(10.0); // Code.radians(45.0);
	var scale = 0.75; // 0.5; // 1.5; // 1.0;
	var noise = 0.0; // 0.0;
	var sigma = null;


imageBGry = imageAGry;
pointB = pointA;

rotation = Code.radians(0.0);
scale = 1.0;



//var optimal = true;
var optimal = false;
if(optimal){
	console.log("optimal");
	var best = Dense.optimalNeedleHaystack(imageAGry,imageAWidth,imageAHeight, pointA,needleSize,needleSize, mask, imageBGry,imageBWidth,imageBHeight, pointB,haystackSize,haystackSize, Dense.SAD, scale,rotation);
	// optimal scale,rotation, haystack location
	console.log(best);
	var location = best.location;
	var c = new DO();
		c.graphics().setLine(1, 0xFF00FF00);
		c.graphics().beginPath();
		c.graphics().drawCircle(0,0, 2.0 );
		c.graphics().strokeLine();
		c.graphics().endPath();
		c.matrix().translate(400 + location.x,location.y);
		GLOBALSTAGE.addChild(c);
}else{
	console.log("metrics");
	matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DScale(matrix,scale);
		matrix = Matrix.transform2DRotate(matrix,rotation);
	var needle = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,1.0,sigma,needleSize,needleSize, imageAGry,imageAWidth,imageAHeight, matrix);
	matrix = new Matrix(3,3).identity();
	var haystack = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0,sigma,haystackSize,haystackSize, imageBGry,imageBWidth,imageBHeight, matrix);
	// noise
	Code.addRandomNoise(needle, noise);
	//Code.addRandomNoise(haystack, noise);
	Code.clipArray(needle, 0,1);
	//Code.clipArray(haystack, 0,1);
	// grads:
	// var needleGradient = ImageMat.gradientMagnitude(needle,needleSize,needleSize);
	// 	needleGradient = needleGradient.value;
	// var haystackGradient = ImageMat.gradientMagnitude(haystack,haystackSize,haystackSize);
	// 	haystackGradient = haystackGradient.value;
		var sigma = 1.0;
		var needleSmooth = ImageMat.getBlurredImage(needle,needleSize,needleSize, sigma);
		var haystackSmooth = ImageMat.getBlurredImage(haystack,haystackSize,haystackSize, sigma);
	var needleGradient = ImageMat.gradientVector(needleSmooth,needleSize,needleSize);
	var haystackGradient = ImageMat.gradientVector(haystackSmooth,haystackSize,haystackSize);
	// SHOW NEEDLE
	img = GLOBALSTAGE.getFloatRGBAsImage(needle,needle,needle, needleSize,needleSize);
	d = new DOImage(img);
	d.matrix().translate(20, 20);
	GLOBALSTAGE.addChild(d);
	// SHOW HAYSTACK
	img = GLOBALSTAGE.getFloatRGBAsImage(haystack,haystack,haystack, haystackSize,haystackSize);
	// for(i=0;i<5;++i){
	// 	d = new DOImage(img);
	// 	d.matrix().translate(100 + haystackSize*i, 20);
	// 	GLOBALSTAGE.addChild(d);
	// }
	// get score fields:
	// var ncc = Dense.ncc(a,b, mask);
	// var sad = Dense.sad(a,b, mask);
	var diff = needleSize*0.5 | 0;
	// flats
	var sad  = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.SAD);
	var zsad  = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.ZSAD);
	//var psad  = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.PSAD);
	
	var sift = Dense.searchNeedleHaystackGradient(needleGradient,needleSize,needleSize,mask, haystackGradient,haystackSize,haystackSize);
	
	// var nsad = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.NSAD);
	//var ssd  = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.SSD);
	// var nssd  = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.NSSD);
	var cc   = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.CC);
	// var ncc  = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.NCC);
	var zcc = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.ZCC);
	var chi = Dense.searchNeedleHaystack(needle,needleSize,needleSize,mask, haystack,haystackSize,haystackSize,  Dense.CHI);
	// gradients
	// var gsad  = Dense.searchNeedleHaystack(needleGradient,needleSize,needleSize,mask, haystackGradient,haystackSize,haystackSize,  Dense.SAD);
	// var gnsad = Dense.searchNeedleHaystack(needleGradient,needleSize,needleSize,mask, haystackGradient,haystackSize,haystackSize,  Dense.NSAD);
	// var gssd = Dense.searchNeedleHaystack(needleGradient,needleSize,needleSize,mask, haystackGradient,haystackSize,haystackSize,  Dense.SSD);
	// var gnssd = Dense.searchNeedleHaystack(needleGradient,needleSize,needleSize,mask, haystackGradient,haystackSize,haystackSize,  Dense.SSD);
	//var gdiv  = Dense.searchNeedleHaystack(needleGradient,needleSize,needleSize,mask, haystackGradient,haystackSize,haystackSize,  Dense.DIV);
	//var list = [sad, gsad, nsad, gnsad, ssd, gssd, nssd, gnssd];
	var list = [sad, zsad, cc, zcc, chi, sift];
	for(i=0; i<list.length; ++i){
		// hasytack BG
		d = new DOImage(img);
		d.matrix().translate(100 + haystackSize*i, 20);
		GLOBALSTAGE.addChild(d);
		// SCORE FG
		var val = list[i];
		Dense.showScore(val, 100 + haystackSize*i + diff,20 + diff, false);
	}
	//Dense.showScore(cc,  100 + haystackSize*3 + diff,20 + diff, true);
	// Dense.showScore(ncc, 100 + haystackSize*4 + diff,20 + diff, true);
	// Dense.showScore(zncc,100 + haystackSize*5 + diff,20 + diff, true);
}
}
Dense.SAD = 0;
Dense.SSD = 1;
Dense.CC = 2;
Dense.NCC = 3;
Dense.ZNCC = 4;
Dense.NSAD = 5;
Dense.NSSD = 6;
Dense.ZSAD = 7;
Dense.PSAD = 8;
Dense.ZCC = 9;
Dense.CHI = 10;
Dense.DIV = 11;
Dense.OTHER = -1;
Dense.showScore = function(data, locX,locY, isMax){
	var image = data.value;
	var width = data.width;
	var height = data.height;
	var c = ImageMat.normalFloat01(Code.copyArray(image));
		c = Code.grayscaleFloatToHeatMapFloat(c);
		var cr = c["red"];
		var cg = c["grn"];
		var cb = c["blu"];
	var img = GLOBALSTAGE.getFloatRGBAsImage(cr,cg,cb, width,height);
	var d = new DOImage(img);
	d.matrix().translate(locX,locY);
	d.graphics().alpha(0.5);
	GLOBALSTAGE.addChild(d);
	//
	//var peaks = Code.findExtrema2DFloat(cornerScores,width,height);
		image = ImageMat.normalFloat01( Code.copyArray(image) );
	var peaks = Code.findMinima2DFloat(image,width,height);
	peaks = peaks.sort(function(a,b){ return a.z<b.z ? -1 : 1 });
	for(i=0; i<peaks.length; ++i){
		peak = peaks[i];
		color = 0xFFFF0000;
		if(i==0){
			color = 0xFF00FF00;
		}
		var c = new DO();
		c.graphics().setLine(1, color);
		c.graphics().beginPath();
		c.graphics().drawCircle(0,0, (0.5/(peak.z+0.1)) );
		c.graphics().strokeLine();
		c.graphics().endPath();
		c.matrix().translate(locX + peak.x, locY + peak.y);
		GLOBALSTAGE.addChild(c);
	}
	// var maxX = maxIndex%width;
	// var maxY = (maxIndex/width) | 0;
	// var c = new DO();
	// c.graphics().setLine(1, 0xFFFF0000);
	// c.graphics().beginPath();
	// c.graphics().drawCircle(0,0, 4);
	// c.graphics().strokeLine();
	// c.graphics().endPath();
	// c.matrix().translate(locX + maxX, locY + maxY);
	// GLOBALSTAGE.addChild(c);
}

Dense.prototype.testFeatureComparison = function(imageA,seedsA, imageB,seedsB){
	Dense.BESTMATCHOFFX = 0;
	Dense.BESTMATCHOFFY = 0;

	var i, pointA, pointB;

	var imageAGry = imageA.gry();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();
	var imageBGry = imageB.gry();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();

	var cellSizeA = 50; // 2 4 10 20 25 50 100
	var cellSizeB = cellSizeA;
	var gridACols = Math.ceil(imageAWidth/cellSizeA);
	var gridARows = Math.ceil(imageAHeight/cellSizeA);
	var gridBCols = Math.ceil(imageAWidth/cellSizeB);
	var gridBRows = Math.ceil(imageAHeight/cellSizeB);
	
	var gridA = new Dense.Grid(imageAWidth,imageAHeight,imageAGry, gridACols,gridARows,cellSizeA);
	var gridB = new Dense.Grid(imageBWidth,imageBHeight,imageBGry, gridBCols,gridBRows,cellSizeB);

	i = 4;
	pointA = seedsA[i];
	pointB = seedsB[i];
	var match = Dense.matchFromPoints(imageAGry,imageAWidth,imageAHeight,pointA,gridA, imageBGry,imageBWidth,imageBHeight,pointB,gridB);
	var scale = match.scale();
	var rotation = match.rotation();
	var score = match.score();

	console.log("FINAL RESULT:");
	var pointA = match.featureA().point();
	var pointB = match.featureB().point();
	var needleSize = 50;
	var sigma = null;
	var matrix = new Matrix(3,3).identity();
	matrix = Matrix.transform2DRotate(matrix,rotation);
	matrix = Matrix.transform2DScale(matrix,scale);
	var a = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,1.0,sigma,needleSize,needleSize, gridA.image(),gridA.width(),gridA.height(), matrix);
	var matrix = new Matrix(3,3).identity();
	var b = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0,sigma,needleSize,needleSize, gridB.image(),gridB.width(),gridB.height(), matrix);
	img = GLOBALSTAGE.getFloatRGBAsImage(a,a,a, needleSize,needleSize);
	d = new DOImage(img);
	d.matrix().translate(100,10);
	Dense.DISPLAY.addChild(d);
	img = GLOBALSTAGE.getFloatRGBAsImage(b,b,b, needleSize,needleSize);
	d = new DOImage(img);
	d.matrix().translate(200,10);
	Dense.DISPLAY.addChild(d);
}	



Dense._matchSorting = function(a,b){
	if(a===b){ return 0; }
	// sad & ncc
	return a.rank() < b.rank() ? -1 : 1;
}

Dense.denseMatchGrid = function(imageA,seedsA, imageB,seedsB, dense){
	// Dense.DISPLAY = new DO();
	// GLOBALSTAGE.addChild(Dense.DISPLAY);

var pointsA = seedsA;
var pointsB = seedsB;
var matrixFfwd = R3D.fundamentalMatrix(pointsA,pointsB);
var matrixFfwd = R3D.fundamentalMatrixNonlinear(matrixFfwd,pointsA,pointsB);
var matrixFrev = R3D.fundamentalInverse(matrixFfwd);

	var i, len, featureA, featureB, match;
	// local image vars
	var imageAGry = imageA.gry();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();
	var imageBGry = imageB.gry();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();
	// global best-match queue
	var queue = new PriorityQueue(Dense._matchSorting);
	// global list of successful matches
	var matches = [];
	// grid of matching cells
	var cellSizeA = 50; // 2 4 10 20 25 50 100
	var cellSizeB = cellSizeA;
	var gridACols = Math.ceil(imageAWidth/cellSizeA);
	var gridARows = Math.ceil(imageAHeight/cellSizeA);
	var gridBCols = Math.ceil(imageAWidth/cellSizeB);
	var gridBRows = Math.ceil(imageAHeight/cellSizeB);
	//cellSizeA = 
	var gridA = new Dense.Grid(imageAWidth,imageAHeight,imageAGry, gridACols,gridARows,cellSizeA);
	var gridB = new Dense.Grid(imageBWidth,imageBHeight,imageBGry, gridBCols,gridBRows,cellSizeB);
	gridA.F(matrixFfwd);
	gridB.F(matrixFrev);
	// convert seeds to matches
	len = Math.min(seedsA.length, seedsB.length);
	for(i=0; i<len; ++i){
		var seedA = seedsA[i];
		var seedB = seedsB[i];
		var match = Dense.matchFromPoints(imageAGry,imageAWidth,imageAHeight,seedA,gridA, imageBGry,imageBWidth,imageBHeight,seedB,gridB);
		Dense.addMatchToQueue(queue, match);
		console.log("   pimary match: "+match);
//		if(i==10){break;}
	}
	console.log("TOTAL START QUEUE SIZE: "+queue.length());
	// start at about 16th of total size

	


/*
// show grids
for(var j=0; j<gridARows; ++j){
for(var i=0; i<gridACols; ++i){
	var c = new DO();
	c.graphics().setLine(1, 0xFFFF0000);
	c.graphics().beginPath();
	c.graphics().drawRect(0,0, cellSizeA,cellSizeA);
	c.graphics().strokeLine();
	c.graphics().endPath();
	c.matrix().translate(0 + i*cellSizeA, 0 + j*cellSizeA);
	GLOBALSTAGE.addChild(c);
}
}
for(var j=0; j<gridBRows; ++j){
for(var i=0; i<gridBCols; ++i){
	var c = new DO();
	c.graphics().setLine(1, 0xFFFF0000);
	c.graphics().beginPath();
	c.graphics().drawRect(0,0, cellSizeB,cellSizeB);
	c.graphics().strokeLine();
	c.graphics().endPath();
	c.matrix().translate(400 + i*cellSizeB, 0 + j*cellSizeB);
	GLOBALSTAGE.addChild(c);
}
}
*/

Dense.imageMatrixA = imageA;
Dense.imageMatrixB = imageB;
Dense.QUEUE = queue;
Dense.GRIDA = gridA;
Dense.GRIDB = gridB;
Dense.ITERATION = 0;
	//Dense.TICKER = new Ticker(2000000);
	Dense.TICKER = new Ticker(10000);
	Dense.TICKER.addFunction(Ticker.EVENT_TICK, Dense.denseMatch_iteration_ticker, Dense);
	Dense.TICKER.start();

	Dense.KEYBOARD = new Keyboard();
	Dense.KEYBOARD.addFunction(Keyboard.EVENT_KEY_DOWN,Dense.denseMatch_iteration_key,Dense);
	Dense.KEYBOARD.addFunction(Keyboard.EVENT_KEY_DOWN_,Dense.denseMatch_iteration_key,Dense);
	Dense.KEYBOARD.addListeners();
}
Dense.denseMatch_iteration_key = function(e){
	//console.log("denseMatch_iteration_key "+e.keyCode);
	if(e.keyCode==Keyboard.KEY_SPACE){
		Dense.TICKER.stop();
		Dense.denseMatch_iteration();
		Dense.TICKER.start();
	}
	if(e.keyCode==Keyboard.KEY_ESCAPE){
		Dense.TICKER.stop();
	}
	if(e.keyCode==Keyboard.KEY_ENTER){
		Dense.TICKER.start();
	}
	if(e.keyCode==Keyboard.KEY_LET_A){
		//GLOBALSTAGE.addListeners();
		if(!Dense.OVERLAYED){
			Dense.OVERLAYED = new DO();
			GLOBALSTAGE.addChild(Dense.OVERLAYED);
		}
		var overlay = Dense.OVERLAYED;
		overlay.removeAllChildren();
		var latticeAtoB = Dense.LATTICE;
		var cells = latticeAtoB.allValidCells(null);
		console.log("DRAW: "+cells.length);
		for(var i=0; i<cells.length; ++i){
			var cell = cells[i];
			Dense.showMatchingMapping(latticeAtoB, cell, GLOBALSTAGE);
		}
	}
	if(e.keyCode==Keyboard.KEY_LET_Q){
		console.log("DRAW LATTICE");
		var latticeAtoB = Dense.LATTICE;
		Dense.visualizeLattice(latticeAtoB, Dense.DISPLAY);
		var interpolator = Dense.INTERPOLATOR;
		Code.printPoints(interpolator.points());
	}
if(e.keyCode==Keyboard.KEY_LET_P){
Dense.ITER = 0;
GLOBALSTAGE.root().removeAllChildren();	
// GLOBALSTAGE.root().matrix().identity().scale(4.0);
	}
	
}
Dense.denseMatch_iteration_ticker = function(t){
	//console.log("denseMatch_iteration_ticker: "+t)
	Dense.TICKER.stop();
	Dense.denseMatch_iteration();
	if(Dense.IS_DONE!==true){
		Dense.TICKER.start();
	}
}



Dense.addMatchToQueue = function(queue, match){
	var MAXIMUM_SCORE = 0.5; // max average SAD score per pixel // TODO: ARBITRARY
	var MAXIMUM_RANK = 1E6; // 15; // max rank score // TODO: ARBITRARY    ... 14 starts to get bad, but accurate results appear at least to 25
	if(match.score()>MAXIMUM_SCORE){
		return;
	}
	if(match.rank()>MAXIMUM_RANK){
		return;
	}
	//console.log("ADD MATCH: "+featureA.point()+" => "+featureB.point()+" ["+scale+" | "+Code.degrees(angle)+"]      score: "+match.score()+" | rank: "+match.rank());
	queue.push(match);
}
Dense.denseMatch_iterationGRID = function(){
	// re-init
	var queue = Dense.QUEUE;
	var gridA = Dense.GRIDA;
	var gridB = Dense.GRIDB;
	var cellSizeA = gridA.cellSize();
	var cellSizeB = gridB.cellSize();
	var iteration = Dense.ITERATION;
	var imageMatrixA = Dense.imageMatrixA;
	var imageMatrixB = Dense.imageMatrixB;

	if(iteration>1E10 || queue.isEmpty()){
		return;
	}

	console.log("denseMatch_iteration: "+queue.length());
	// var MAXIMUM_SCORE = 0.5; // max average SAD score per pixel // TODO: ARBITRARY
	// var if(bestMatch.score()>MAXIMUM_SCORE){
// 	break;
// } = 15; // max rank score // TODO: ARBITRARY    ... 14 starts to get bad, but accurate results appear at least to 25
	// clear display:
	var display = Dense.DISPLAY;

	// pick up best match ad infinitum
	while(!queue.isEmpty()){
		++iteration;
// var q = queue.toArray();
// for(var k=0; k<q.length && k<3; ++k){
// 	console.log("    "+k+" : "+q[k]);
// }
		var bestMatch = queue.popMinimum();
console.log("best score: "+bestMatch.score()+"            ("+bestMatch.rank()+")  @ scale:"+bestMatch.scale()+" | angle:"+Code.degrees(bestMatch.rotation())+"");
		// satellite operation
		var featureA = bestMatch.featureA();
		var featureB = bestMatch.featureB();
		var cellA = bestMatch.cellA();
		var cellB = bestMatch.cellB();
if(cellA==null || cellB==null){
	console.log("null cell");
	throw "null";
}
		if(cellA.grid()!=gridA){ // flip
			var temp = cellA;
			cellA = cellB;
			cellB = temp;
		}
		// if either cell is still unmatched => match cells
		//if(cellA.isJoined() && cellB.isJoined()){ //non-unique => many duplicates
		if(cellA.isJoined() || cellB.isJoined()){ // uniqueness => not match everything
			continue;
		}

// clear on successful join
display.removeAllChildren();

//console.log(bestMatch)
		bestMatch.cellA(cellA);
		bestMatch.cellB(cellB);

		cellA.join(bestMatch);
		cellB.join(bestMatch);
		/*
		// display each grid's disparity
		var minDisparity = null;
		var maxDisparity = null;
		for(var j=0; j<gridA.rows(); ++j){
			for(var i=0; i<gridA.cols(); ++i){
				var cell = gridA.cell(i,j);
				var disparity = cell.disparity();
				if(disparity==null){ continue; }
				if(minDisparity===null || minDisparity>disparity){
					minDisparity = disparity;
				}
				if(maxDisparity===null || maxDisparity<disparity){
					maxDisparity = disparity;
				}
			}
		}
		if(minDisparity && maxDisparity){
			var rangeDisparity = maxDisparity - minDisparity;
			for(var j=0; j<gridA.rows(); ++j){
				for(var i=0; i<gridA.cols(); ++i){
					var cell = gridA.cell(i,j);
					var disparity = cell.disparity();
					if(disparity==null){ continue; }
					disparity = (disparity-minDisparity)/rangeDisparity;
					// disparity = 1.0 - disparity; // darker is more disparity
					var color = Code.grayscaleFloatToHeatMapFloat([disparity]);
					color = Code.getColARGBFromFloat(color.alp[0],color.red[0],color.grn[0],color.blu[0]);
					//color = Code.getColARGBFromFloat(1.0,disparity,disparity,disparity);
					var c = new DO();
					c.graphics().setFill(color);
					c.graphics().beginPath();
					c.graphics().drawRect(0,0, cellSizeA,cellSizeA);
					c.graphics().endPath();
					c.graphics().fill();
					c.matrix().translate(800 + i*cellSizeA, 0 + j*cellSizeA);
					display.addChild(c);
				}
			}
		}
		*/

		var neighborsA = cellA.neighbors();
		var neighborsB = cellB.neighbors();
// show matches
var color = 0x990000FF;

// var i = cellA._col;
// var j = cellA._row;
// var c = new DO();
// c.graphics().setFill(color);
// c.graphics().beginPath();
// c.graphics().drawRect(0,0, cellSizeA,cellSizeA);
// c.graphics().endPath();
// c.graphics().fill();
// c.matrix().translate(0 + i*cellSizeA, 0 + j*cellSizeA);
// GLOBALSTAGE.addChild(c);

var i = cellB._col;
var j = cellB._row;
var c = new DO();
c.graphics().setFill(color);
c.graphics().beginPath();
c.graphics().drawRect(0,0, cellSizeB,cellSizeB);
c.graphics().endPath();
c.graphics().fill();
c.matrix().translate(400 + i*cellSizeB, 0 + j*cellSizeB);
GLOBALSTAGE.addChild(c);

// line
// var c = new DO();
// c.graphics().setLine(1.0, 0x33FF0000);
// c.graphics().beginPath();
// c.graphics().moveTo(cellA.center().x+0  ,cellA.center().y+0);
// c.graphics().lineTo(cellB.center().x+400,cellB.center().y+0);
// c.graphics().strokeLine();
// c.graphics().endPath();
// GLOBALSTAGE.addChild(c);
//console.log(cellA.center()+"")


// show matched point
var match = bestMatch;
if(match){
	if(match.cellA().grid()==gridB){ // swap
		match = match.inverse();
	}
	var cA = match.cellA();
	var cB = match.cellB();
	var fA = match.featureA();
	var fB = match.featureB();
	var rotationAtoB = match.rotation();
	var scaleAtoB = match.scale();
	var pA = fA.point();
	var pB = fB.point();
	var matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DRotate(matrix,-rotationAtoB);
		matrix = Matrix.transform2DScale(matrix,1.0/scaleAtoB);
	var bR = ImageMat.extractRectFromFloatImage(pB.x,pB.y,1.0,null,cellSizeA,cellSizeA, imageMatrixB.red(),imageMatrixB.width(),imageMatrixB.height(), matrix);
	var bG = ImageMat.extractRectFromFloatImage(pB.x,pB.y,1.0,null,cellSizeA,cellSizeA, imageMatrixB.grn(),imageMatrixB.width(),imageMatrixB.height(), matrix);
	var bB = ImageMat.extractRectFromFloatImage(pB.x,pB.y,1.0,null,cellSizeA,cellSizeA, imageMatrixB.blu(),imageMatrixB.width(),imageMatrixB.height(), matrix);
	var diff = V2D.sub(pA,cellA.center());
	img = GLOBALSTAGE.getFloatRGBAsImage(bR,bG,bB, cellSizeA,cellSizeA);
	d = new DOImage(img);
	//d.matrix().translate(0 + i*cellSizeA, 0 + j*cellSizeA);
	//d.matrix().translate(800 + i*cellSizeA + diff.x, 0 + j*cellSizeA + diff.y);
	//d.matrix().translate(800 + pA.x, 0 + pA.y);
	//d.matrix().translate(0 + pA.x, 0 + pA.y);
	d.matrix().translate(0 + pA.x - cellSizeA*0.5, 0 + pA.y - cellSizeA*0.5);
	GLOBALSTAGE.addChild(d);
}
		// check neighbor matches
		Dense.BESTMATCHOFFY = 200;
		Dense.checkAddNeighbors(cellA, cellB, queue, gridA, gridB, bestMatch);
		Dense.checkAddNeighbors(cellB, cellA, queue, gridB, gridA, bestMatch);
		break; // ticker loop
	}
}
Dense.cellSizeAbout = function(desired,width,height){
	// find closest square cell that is divisible by both width and height 
	return 0;
}
Dense.addSatelliteFeature = function(pointA, pointB){
	//
	// Q score should be based not solely on the absolute matching score, but on how unique the match is compared to other neighbor matches (confidence)
}
Dense.checkAddNeighbors = function(cellA, cellB, queue, gridA, gridB, match){ // A = needle, B = haystack
var display = Dense.DISPLAY;
Dense.BESTMATCHOFFX = 0;
Dense.BESTMATCHOFFY += 130;
	var neighborsA = cellA.neighbors();
	var offsetScaleMatch = match.scale();// TODO: get from matched neighbor & append: 2^[-0.1,0,0.1]
	var offsetRotationMatch = match.rotation();// TODO: get from matched neighbor & append: [-10,0,10]
	var flipped = false;
	if(match.cellA()==cellB){ // opposite direction
		flipped = true;
		offsetScaleMatch = 1.0/offsetScaleMatch;
		offsetRotationMatch = -offsetRotationMatch;
	}


	for(var i=0; i<neighborsA.length; ++i){
		var neighborA = neighborsA[i];
		if(neighborA.isJoined()){
			continue;
		}
		// create definitive feature for un-inited cells if not 
		var featureA = neighborA.feature();
		var cornerValues = null;
		if(!featureA){
			
			var centerPoint = neighborA.center();
			
			var cellSize = gridA.cellSize();
			var cellImage = ImageMat.extractRectFromFloatImage(centerPoint.x,centerPoint.y,1.0,null,cellSize,cellSize, gridA.image(),gridA.width(),gridA.height(), null);
				var sigma = 2.0;
			cellImage = ImageMat.getBlurredImage(cellImage,cellSize,cellSize, sigma);
			cornerValues = ImageMat.corners(cellImage,cellSize,cellSize);
			// TODO: if corner is bad enough, ignore
			var bestCorner;
			if(cornerValues.length>0){
				bestCorner = cornerValues[0];
				bestCorner.x += centerPoint.x - cellSize*0.5;
				bestCorner.y += centerPoint.y - cellSize*0.5;
			}else{
				bestCorner = centerPoint;
			}
			var point = new V2D(bestCorner.x,bestCorner.y);
			featureA = Dense.definitiveFeature(point, null);
			neighborA.feature(featureA);
		}
		var cellSizeA = Math.max(gridA.cellSize(),Dense.MINIMUM_CELL_SIZE);
		var cellSizeB = Math.max(gridB.cellSize(),Dense.MINIMUM_CELL_SIZE);
		var needleSize = Math.min(Dense.COMPARE_CELL_SIZE,cellSizeA);
		var needleScaleCellToCompare = needleSize / cellSizeA;
		var neighborhoodMagnitude = 5; // cellSizeA > 11 ? 4 : (cellSizeA * 2);
		// larger neighborhood decreases uniqueness odds
		var haystackSize = needleSize * neighborhoodMagnitude; // 3x3 window + padding
		// for small cell sizes (~ 1 px) neighborhood is tiny
		
		var centerB = cellB.center();
	var needleMask = ImageMat.circleMask(needleSize);
	var best = Dense.optimalNeedleHaystack(gridA.image(),gridA.width(),gridA.height(), featureA.point(),needleSize,needleSize, needleMask, gridB.image(),gridB.width(),gridB.height(), centerB,haystackSize,haystackSize, null, needleScaleCellToCompare*offsetScaleMatch,offsetRotationMatch); // Dense.SAD
	if(best){
		best.scale /= needleScaleCellToCompare;
		//console.log("BEST: "+best);
		var location = best.location;
		var scale = best.scale;
		var angle = best.angle;
		var score = best.score;
		if(score){
			var pointB = new V2D(location.x,location.y);
			var featureB = new Dense.Feature(pointB);
			var sigma = null;
			var matrix = new Matrix(3,3).identity();
			matrix = Matrix.transform2DRotate(matrix,angle);
			matrix = Matrix.transform2DScale(matrix,scale);
			var a = ImageMat.extractRectFromFloatImage(featureA.point().x,featureA.point().y,1.0,sigma,needleSize,needleSize, gridA.image(),gridA.width(),gridA.height(), matrix);
			var matrix = new Matrix(3,3).identity();
			var b = ImageMat.extractRectFromFloatImage(featureB.point().x,featureB.point().y,1.0,sigma,needleSize,needleSize, gridB.image(),gridB.width(),gridB.height(), matrix);

			// SHOW MATCH:
			var haystack = ImageMat.extractRectFromFloatImage(featureB.point().x,featureB.point().y,1.0,sigma,haystackSize,haystackSize, gridB.image(),gridB.width(),gridB.height(), matrix);
			var scores = Dense.searchNeedleHaystack(b,needleSize,needleSize,needleMask, haystack,haystackSize,haystackSize);
			var values = scores.value;
			var width = scores.width;
			var height = scores.height;
			var windowCenterX = Math.floor(needleSize*0.5);
			var windowCenterY = Math.floor(needleSize*0.5);

/*
img = GLOBALSTAGE.getFloatRGBAsImage(a,a,a, needleSize,needleSize);
d = new DOImage(img);
d.matrix().translate(10 + Dense.BESTMATCHOFFX + 0, Dense.BESTMATCHOFFY + 0);
Dense.DISPLAY.addChild(d);

img = GLOBALSTAGE.getFloatRGBAsImage(haystack,haystack,haystack, haystackSize,haystackSize);
d = new DOImage(img);
d.matrix().translate(30 + Dense.BESTMATCHOFFX + 0, Dense.BESTMATCHOFFY + 0);
Dense.DISPLAY.addChild(d);

	var c = ImageMat.normalFloat01(Code.copyArray(values));
		c = Code.grayscaleFloatToHeatMapFloat(c);
		var cr = c["red"];
		var cg = c["grn"];
		var cb = c["blu"];
	img = GLOBALSTAGE.getFloatRGBAsImage(cr,cg,cb, width,height);
	d = new DOImage(img);
	d.matrix().translate(30 + Dense.BESTMATCHOFFX + windowCenterX, Dense.BESTMATCHOFFY + windowCenterY);
	d.graphics().alpha(0.5);
	Dense.DISPLAY.addChild(d);

d = new DOText(score.toExponential(3)+"", 10, DOText.FONT_ARIAL, 0xFFFF0000, DOText.ALIGN_LEFT);
d.matrix().translate(Dense.BESTMATCHOFFX + 0, Dense.BESTMATCHOFFY + 14 + needleSize*2);
Dense.DISPLAY.addChild(d);
*/

			var b = gridB.cell(pointB);
			if(b==null){ // outside of grid for some reason
				console.log("have null cell: "+pointB);
			}else{
				//var uniqueness = Dense.uniquenessFromPair(featureA.point(),gridA.image(),gridA.width(),gridA.height(), featureB.point(),gridB.image(),gridB.width(),gridB.height(),  scale,angle);
				var uniqueness = Dense.uniquenessFromPoints(featureA.point(),needleSize,needleSize,needleMask, gridA.image(),gridA.width(),gridA.height(),  featureB.point(),haystackSize,haystackSize, gridB.image(),gridB.width(),gridB.height(), scale,angle);
				//console.log("uniqueness: "+uniqueness)
/*
d = new DOText(uniqueness.toExponential(3)+"", 10, DOText.FONT_ARIAL, 0xFFFF0000, DOText.ALIGN_LEFT);
d.matrix().translate(Dense.BESTMATCHOFFX + 0, Dense.BESTMATCHOFFY + 14 + 15 + needleSize*2);
Dense.DISPLAY.addChild(d);
				//score = score * uniqueness;
				//score = uniqueness;
d = new DOText(score.toExponential(3)+"", 10, DOText.FONT_ARIAL, 0xFFFF9999, DOText.ALIGN_LEFT);
d.shadow(0xFFF000000,1,0,0);
d.matrix().translate(Dense.BESTMATCHOFFX + 0, Dense.BESTMATCHOFFY + 14 + 30 + needleSize*2);
Dense.DISPLAY.addChild(d);
*/
				var match;
				if(flipped){
					var match = new Dense.Match(featureB,featureA, score, uniqueness, 1.0/scale,-angle, b, neighborA);
				}else{
					var match = new Dense.Match(featureA,featureB, score, uniqueness, scale,angle, neighborA, b);
				}
				Dense.addMatchToQueue(queue, match);
			}
		}
	}
Dense.BESTMATCHOFFX += 80;
	}
}
Dense.definitiveFeature = function(point, image,imageWidth,imageHeight, windowWidth,windowHeight){
	// TODO: find most prominent / unique feature location;
	return new Dense.Feature(point);
}

/*
Dense.MINIMUM_CELL_SIZE = 5;
Dense.COMPARE_CELL_SIZE = 11;
Dense.OFFX = 10;
Dense.OFFY = 0;
Dense.featuresFromPoints = function(floatA,widthA,heightA, pointA, floatB,widthB,heightB, pointB,   cellSize){ // only for seed points, // assumed correctly matched
var offIN = Dense.OFFY;
var calculateScale = 1.0; // 0.50; // 0.25;

cellSize = Math.max(cellSize,Dense.MINIMUM_CELL_SIZE);
var windowSize = cellSize;
 	var mask = ImageMat.circleMask(windowSize);
 	var center = Math.floor(windowSize * 0.5);
 	var i, j, k, l, score;
 	var d, img;
 	var scale, rotation, sigma, matrix;
var sca = 1.0;
	var scales = Code.lineSpace(-2,0,0.5); // negatives should be done on opposite image -- scaling down
	var rotations = Code.lineSpace(-180,170,10);
	var matrix, a, b, u, v;
	var angleA, angleB;
	var minScore = null;
	var optimumScale = null;
	var optimumRotation = null;
	var optimumAsymmAngle = null;
	var optimumAsymmScale = null;
	// do A = haystack
		sigma = 4.0;
		scale = 1.0;
		rotation = 0.0;
		matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DRotate(matrix,rotation);
// GET ANGLE FROM SIFT FEATURE ESTIMATE
		// get local image
		a = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,scale*calculateScale,sigma,windowSize,windowSize, floatA,widthA,heightA, matrix);
		u = ImageMat.gradientVector(a, windowSize,windowSize, center,center);
		angleA = V2D.angle(V2D.DIRX,u);
		// get local image
		b = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,scale*calculateScale,sigma,windowSize,windowSize, floatB,widthB,heightB, matrix);
		u = ImageMat.gradientVector(b, windowSize,windowSize, center,center);
		angleB = V2D.angle(V2D.DIRX,u);
		// get 0-angled image
		sigma = null;
		scale = 1.0;
		rotation = -angleA;
		matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DRotate(matrix,rotation);
		a = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,scale*calculateScale,sigma,windowSize,windowSize, floatA,widthA,heightA, matrix);
//var entropyA = Dense.entropy(a,windowSize,windowSize, mask);
		// show A
		// img = GLOBALSTAGE.getFloatRGBAsImage(a, a, a, windowSize,windowSize);
		// 	d = new DOImage(img);
		// 	// d.matrix().translate(-windowSize*0.5,-windowSize*0.5);
		// 	// d.matrix().rotate(angleA);
		// 	// d.matrix().translate(windowSize*0.5,windowSize*0.5);
		// 	d.matrix().scale(sca);
		// 	d.matrix().translate(Dense.OFFX + 0, Dense.OFFY);
		// 	GLOBALSTAGE.addChild(d);
//Dense.OFFY += 30;
	// ASYMM
	var asymmScales = Code.lineSpace(0.0,1.0,0.25);
	// var asymmAngles = Code.lineSpace(-90,60,30);
	// var asymmAngles = Code.lineSpace(-90,70,20);
	// var asymmAngles = Code.lineSpace(-90,80,10);
	// var asymmScales = Code.lineSpace(0.0,0.75,0.25);
	var asymmScales = Code.lineSpace(0.0,0.5,0.1);
	// var asymmAngles = [0.0];
	// var asymmScales = [0.0];
	// at asymmScale ==0 => all angles are always the same
	// scales = [-1.5];
	// rotations = [0.0];
	// asymmAngles = [90.0];
	// asymmScales = [0.5];
	// do Bs = needles
	for(i=0; i<scales.length; ++i){
		scale = scales[i];
		scale = Math.pow(2,scale);
		for(j=0; j<rotations.length; ++j){
			rotation = rotations[j];
			rotation = Code.radians(rotation);
			rotation -= angleB;
			for(k=0; k<asymmScales.length; ++k){
				var asymmScale = asymmScales[k];
				asymmScale = Math.pow(2,asymmScale);
				for(l=0; l<asymmAngles.length; ++l){
					var asymmAngle = asymmAngles[l];
					asymmAngle = Code.radians(asymmAngle);
					sigma = null;
					matrix = new Matrix(3,3).identity();
					matrix = Matrix.transform2DRotate(matrix,asymmAngle);
					matrix = Matrix.transform2DScale(matrix,asymmScale,1.0);
					matrix = Matrix.transform2DRotate(matrix,-asymmAngle);
					matrix = Matrix.transform2DRotate(matrix,rotation);
					matrix = Matrix.transform2DScale(matrix,scale);

					b = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0*calculateScale,sigma,windowSize,windowSize, floatB,widthB,heightB, matrix);
					// SCORE
					//var ncc = Dense.ncc(a,b, mask);
					var sad = Dense.sad(a,b, mask);
					score = sad;
			// entropy in [0,1]
			// lower score are better
			// higher entropy is better
			//	var entropyB = Dense.entropy(b,windowSize,windowSize, mask);
			//	score = score / Math.pow( Math.max(0.000001,Math.min(entropyA,entropyB)) , 2);
					//score = ncc/sad;
					//score = 1.0/sad;
					//score = ncc;
					//score = 1.0 / score;
					//score = ImageMat.SADFloatSimple(a,windowSize,windowSize, b, mask);
					//score = ImageMat.ssd(a,windowSize,windowSize, b,windowSize,windowSize); // NaN ?
					//score = ImageMat.ssdInner(a,windowSize,windowSize, b,windowSize,windowSize);
					// show B
					// img = GLOBALSTAGE.getFloatRGBAsImage(b, b, b, windowSize,windowSize);
					// d = new DOImage(img);
					// d.matrix().translate(Dense.OFFX, Dense.OFFY + windowSize*sca);
					// GLOBALSTAGE.addChild(d);
					// // show score
					// d = new DOText((Math.round(score*100)/100)+"", 10, DOText.FONT_ARIAL, 0xFF000000, DOText.ALIGN_LEFT);
					// d.matrix().translate(Dense.OFFX + windowSize, Dense.OFFY + 14 + windowSize*sca);
					// GLOBALSTAGE.addChild(d);
					// sad
					if(minScore==null || score<minScore){
						minScore = score;
						optimumRotation = rotation;
						optimumAsymmScale = asymmScale;
						optimumAsymmAngle = asymmAngle;
						optimumScale = scale;
					}
					//console.log(scale,rotation,asymmAngle,asymmScale,score);
					Dense.OFFY += windowSize;
					if(asymmScale==1.0){break;}
				}
			}
		}
	}
	// SHOW FINAL:
	sigma = null;
	matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DRotate(matrix,optimumAsymmAngle);
		matrix = Matrix.transform2DScale(matrix,optimumAsymmScale);
		matrix = Matrix.transform2DRotate(matrix,-optimumAsymmAngle);
		matrix = Matrix.transform2DRotate(matrix,optimumRotation);
		matrix = Matrix.transform2DScale(matrix,optimumScale);

	b = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0*calculateScale,sigma,windowSize,windowSize, floatB,widthB,heightB, matrix);
	img = GLOBALSTAGE.getFloatRGBAsImage(b, b, b, windowSize,windowSize);
	d = new DOImage(img);
	d.matrix().scale(sca);
	d.matrix().translate(Dense.OFFX + windowSize*sca, offIN);
	GLOBALSTAGE.addChild(d);

	// FROM B->A to A->B
	optimumScale = 1.0/optimumScale;
	optimumRotation = -(optimumRotation + angleA);
	optimumAsymmScale = 1.0/optimumAsymmScale;
	optimumAsymmAngle = -optimumAsymmAngle;
	
Dense.OFFX += windowSize*sca*2 + 20;
	return {"score":minScore, "angle":optimumRotation, "scale":optimumScale};
}
*/

Dense.Grid = function(width,height,image, cols,rows,size){
	this._id = Dense.Grid.ID++;
	this._image = image;
	this._width = width;
	this._height = height;
	this._cols = cols;
	this._rows = rows;
	this._cellSize = size;
	this._cells = [];
	var i, j, len = cols*rows;
	for(j=0; j<this._rows; ++j){
		for(i=0; i<this._cols; ++i){
			this._cells.push( new Dense.Cell(this, i,j) );
		}
	}
	this._areas = [];
	this._F = null;
}
Dense.Grid.ID = 0;
Dense.Grid.prototype.F = function(f){
	if(f!==undefined){
		this._F = f;
	}
	return this._F;
}
Dense.Grid.prototype._indexFromColRow = function(col,row){
	if(0<=row && row<this._rows  &&  0<=col && col<this._cols){
		var index = row*this._cols + col;
		return index;
	}
	return null;
}
Dense.Grid.prototype._cellFromColRow = function(col,row){
	var index = this._indexFromColRow(col,row);
	if(index!==null){
		return this._cells[index];
	}
	return null;
}
Dense.Grid.prototype.cellSize = function(s){
	if(s!==undefined){
		this._cellSize = s;
	}
	return this._cellSize;
}
Dense.Grid.prototype.image = function(i){
	if(i!==undefined){
		this._image = i;
	}
	return this._image;
}
Dense.Grid.prototype.cols = function(c){
	if(c!==undefined){
		this._cols = c;
	}
	return this._cols;
}
Dense.Grid.prototype.rows = function(r){
	if(r!==undefined){
		this._rows = r;
	}
	return this._rows;
}
Dense.Grid.prototype.width = function(w){
	if(w!==undefined){
		this._width = w;
	}
	return this._width;
}
Dense.Grid.prototype.height = function(h){
	if(h!==undefined){
		this._height = h;
	}
	return this._height;
}
Dense.Grid.prototype.cell = function(a,b){
	if(arguments.length==2){
		return this._cellFromColRow(a,b);
	}else if(Code.isa(a,V2D)){ // point index
		var col = ((a.x/this._width)*this._cols) | 0;
		var row = ((a.y/this._height)*this._rows) | 0;
		return this._cellFromColRow(col,row);
	}else{
		// ?
		console.log("unknown");
	}
	return null;
}
Dense.Grid.prototype.toString = function(){
	return "[Grid: "+this._id+"]";
}


Dense.Cell = function(grid, col, row){
	this._grid = grid;
	this._col = col;
	this._row = row;
	this._joins = [];
	this._keyFeature = null;
}
Dense.Cell.prototype.grid = function(g){
	if(g!==undefined){
		this._grid = g;
	}
	return this._grid;
}
Dense.Cell.prototype.feature = function(f){
	if(f!==undefined){
		this._keyFeature = f;
	}
	return this._keyFeature;
}
Dense.Cell.prototype.center = function(){
	var size = this._grid._cellSize;
	return new V2D(size*(this._col+0.5), size*(this._row+0.5));
}
Dense.Cell.prototype.join = function(match){
	this._joins.push(match);
}
Dense.Cell.prototype.isJoined = function(){
	return this._joins.length>0;
}
Dense.Cell.prototype.match = function(){ // TODO: BEST match
	if(this._joins.length>0){
		return this._joins[0];
	}
	return null;
}
Dense.Cell.prototype.neighbors = function(){
	var n, neighbors = [];
	for(var j=-1; j<=1; ++j){
		for(var i=-1; i<=1; ++i){
			if(i==0 && j==0){
				continue;
			}
			n = this._grid.cell(this._col+i,this._row+j);
			if(n){
				neighbors.push(n);
			}
		}
	}
	return neighbors;
}
Dense.Cell.prototype.disparity = function(){ // average disparity for all matches
	var i, len = this._joins.length;
	if(len==0){ return null; }
	var disparity = 0;
	for(i=0; i<len; ++i){
		var match = this._joins[i];
		var featureA = match.featureA();
		var featureB = match.featureB();
		if(match.cellB()==this){
			featureA = match.featureB();
			featureB = match.featureA();
		}
		// do the images need to be brought into similar scale?
		var distance = V2D.distance(featureA.point(),featureB.point());
		disparity += distance;
	}
	disparity = disparity / len;
	return disparity;
}
Dense.Cell.prototype.toString = function(){
	return "[Cell: "+this._col+","+this._row+"]";
}


Dense.Feature = function(point){
	this._point = null;
	this.point(point);
}
Dense.Feature.prototype.toString = function(){
	return "[Feature: "+this._point+"]";
}
Dense.Feature.prototype.point = function(p){
	if(p!==undefined){
		this._point = V2D.copy(p);
	}
	return this._point;
}


Dense.Match = function(featureA,featureB, score, rank, scale, rotation, cellA, cellB){
	this._featureA = null;
	this._featureB = null;
	this._score = null;
	this._rank = null;
	this._rotation = 0.0;
	this._scale = 1.0;
	this.featureA(featureA);
	this.featureB(featureB);
	this.score(score);
	this.rank(rank);
	this.scale(scale);
	this.rotation(rotation);
	this._cellA = null;
	this._cellB = null;
	this.cellA(cellA);
	this.cellB(cellB);
}
Dense.Match.prototype.inverse = function(){
	var match = new Dense.Match(this.featureB(),this.featureA(),this.score(),this.rank(),1.0/this.scale(),-this.rotation(),this.cellB(),this.cellA());
	return match;
}
Dense.Match.prototype.featureA = function(a){
	if(a!==undefined){
		this._featureA = a;
	}
	return this._featureA;
}
Dense.Match.prototype.featureB = function(b){
	if(b!==undefined){
		this._featureB = b;
	}
	return this._featureB;
}
Dense.Match.prototype.score = function(s){
	if(s!==undefined){
		this._score = s;
	}
	return this._score;
}
Dense.Match.prototype.rank = function(r){
	if(r!==undefined){
		this._rank = r;
	}
	return this._rank;
}
Dense.Match.prototype.scale = function(s){
	if(s!==undefined){
		this._scale = s;
	}
	return this._scale;
}
Dense.Match.prototype.rotation = function(r){
	if(r!==undefined){
		this._rotation = r;
	}
	return this._rotation;
}
Dense.Match.prototype.cellA = function(c){
	if(c!==undefined){
		this._cellA = c;
	}
	return this._cellA;
}
Dense.Match.prototype.cellB = function(c){
	if(c!==undefined){
		this._cellB = c;
	}
	return this._cellB;
}
Dense.Match.prototype.toString = function(){
	var str = "";
	str = "[Match: "+this._score+" && "+this._rank+" -- "+Math.round(Code.degrees(this._rotation))+"deg | "+this._scale+"  A:"+(this._featureA?this._featureA.point():"x")+" => B:"+(this._featureB?this._featureB.point():"x")+" ]";
	return str;
}

Dense.ncc = function(aRed,aGrn,aBlu, bRed,bGrn,bBlu, m){ // normalized cross correlation
	if(arguments.length>3){
		var red = Dense.sad(aRed,bRed,m);
		var grn = Dense.sad(aGrn,bGrn,m);
		var blu = Dense.sad(aBlu,bBlu,m);
		var sum = (red + grn + blu)/3.0;
		return sum;
	} // else
	var a = aRed;
	var b = aGrn;
	var m = aBlu;
	var score = 0;
	var aa = 0, bb = 0, ab = 0;
	var aMean = 0, bMean = 0;
	var ai, bi;
	var i, len = a.length;
	var maskCount = 0;
	var mask = 1.0;
	if(len==0){ return 0; }
	for(i=0; i<len; ++i){
		if(m){ mask = m[i]; }
		if(mask==0){ continue; }
		maskCount += mask;
		aMean += a[i] * mask;
		bMean += b[i] * mask;
	}
	aMean /= maskCount;
	bMean /= maskCount;
	for(i=0; i<len; ++i){
		if(m){ mask = m[i]; }
		if(mask==0){ continue; }
		ai = a[i] - aMean;
		bi = b[i] - bMean;
		aa += ai * ai * mask;
		bb += bi * bi * mask;
		ab += ai * bi * mask;
	}
	ab = ab/maskCount;
	//score = ab / Math.sqrt(aa*bb);
	score = 1.0/ab;
	return score;
}
Dense.sad = function(aRed,aGrn,aBlu, bRed,bGrn,bBlu, m, rangeYes){ // sum of absolute differences
	if(arguments.length>3){
		var red = Dense.sad(aRed,bRed,m);
		var grn = Dense.sad(aGrn,bGrn,m);
		var blu = Dense.sad(aBlu,bBlu,m);
		var sum = (red + grn + blu)/3.0;
		return sum;
	} // else
	var a = aRed;
	var b = aGrn;
	var m = aBlu;
	var score = 0;
	var aa = 0, bb = 0, ab = 0;
	var aMean = 0, bMean = 0;
	var ai, bi;
	var i, len = a.length;
	var maskCount = 0;
	var mask = 1.0;
	if(len==0){ return 0; }
	for(i=0; i<len; ++i){
		if(m){ mask = m[i]; }
		if(mask==0){ continue; }
		maskCount += mask;
		aMean += a[i] * mask;
		bMean += b[i] * mask;
	}
	aMean /= maskCount;
	bMean /= maskCount;
	for(i=0; i<len; ++i){
		if(m){ mask = m[i]; }
		if(mask==0){ continue; }
		ai = a[i] - aMean;
		bi = b[i] - bMean;
		ab += Math.abs(ai - bi);
		//ab += Math.pow(Math.abs(ai - bi),2);
		//ab += Math.abs(a[i] - b[i]);
	}
	score = ab/maskCount;
	if(rangeYes===true){
		score = score * (1.0 + Math.abs(aMean-bMean));
	}
	return score;
}

Dense.searchNeedleHaystackImage = function(needle,needleMask, haystack){
	var needleWidth = needle.width();
	var needleHeight = needle.height();
	var needleR = needle.red();
	var needleG = needle.grn();
	var needleB = needle.blu();
	var haystackWidth = haystack.width();
	var haystackHeight = haystack.height();
	var haystackR = haystack.red();
	var haystackG = haystack.grn();
	var haystackB = haystack.blu();

	var needleCount = needleWidth*needleHeight;
	var resultWidth = haystackWidth - needleWidth + 1;
	var resultHeight = haystackHeight - needleHeight + 1;
	var resultCount = resultWidth * resultHeight;
	if(resultCount<=0){
		return null;
	}
	var mask = 1.0;
	var i, j;
	var maskCount = 0;
	for(i=0; i<needleCount; ++i){
		if(needleMask){ mask = needleMask[i]; }
		if(mask===0){ continue; }
		++maskCount;
	}


	var avgN = new V3D();
	for(k=0; k<needleCount; ++k){
		if(needleMask){ mask = needleMask[k]; }
		if(mask===0){ continue; }
		avgN.x += needleR[k];
		avgN.y += needleG[k];
		avgN.z += needleB[k];
		++maskCount;

	}
	avgN.scale(1.0/needleCount);
//console.log(avgN+"")
	// for(k=0; k<needleCount; ++k){
	// 	if(needleMask){ mask = needleMask[k]; }
	// 	if(mask===0){ continue; }
	// 	sigmaNN += Math.pow(mask*needle[k] - avgN, 2);
	// }


	var result = new Array();
	for(j=0; j<resultHeight; ++j){
		for(i=0; i<resultWidth; ++i){
			var resultIndex = j*resultWidth + i;
			var sadR = 0;
			var sadG = 0;
			var sadB = 0;

			var avgH = new V3D();
			// var sigmaHH = 0;
			// var sigmaNH = 0;
			for(var nJ=0; nJ<needleHeight; ++nJ){ // entire needle
				for(var nI=0; nI<needleWidth; ++nI){ 
					var nIndex = nJ*needleWidth + nI;
					var hIndex = (j+nJ)*haystackWidth + (i+nI);
					if(needleMask){ mask = needleMask[nIndex]; }
					if(mask===0){ continue; }
					var n = needle[nIndex];
					var h = haystack[hIndex];
					// maxH = maxH==null || maxH<h ? h : maxH;
					// minH = minH==null || minH>h ? h : minH;
					avgH.x += haystackR[hIndex];
					avgH.y += haystackG[hIndex];
					avgH.z += haystackB[hIndex];
				}
			}
			avgH.scale(1.0/needleCount);
			//console.log(avgH+"")


			for(var nJ=0; nJ<needleHeight; ++nJ){ // entire needle
				for(var nI=0; nI<needleWidth; ++nI){ 
					var nIndex = nJ*needleWidth + nI;
					var hIndex = (j+nJ)*haystackWidth + (i+nI);
					if(needleMask){ mask = needleMask[nIndex]; }
					if(mask===0){ continue; }
					// completely ignore a masked operation
					var nR = needleR[nIndex];
					var nG = needleG[nIndex];
					var nB = needleB[nIndex];
					var hR = haystackR[hIndex];
					var hG = haystackG[hIndex];
					var hB = haystackB[hIndex];
					nR = nR - avgN.x;
					nG = nG - avgN.y;
					nB = nB - avgN.z;
					hR = hR - avgH.x;
					hG = hG - avgH.y;
					hB = hB - avgH.z;
					sadR += Math.abs(nR - hR);
					sadG += Math.abs(nG - hG);
					sadB += Math.abs(nB - hB);
//					here
				}
			}
			var sss = (sadR + sadG + sadB) / maskCount / 3.0;
			var avgR = Math.abs(avgN.x-avgH.x);
			var avgG = Math.abs(avgN.y-avgH.y);
			var avgB = Math.abs(avgN.z-avgH.z);
			var avgTot = (avgR+avgG+avgB) / 3.0;
			//sss = sss * (1.0 + avgTot);
			result[resultIndex] = sss;
		}
	}
	return {"value":result, "width":resultWidth, "height":resultHeight};

}
/*
Dense.searchNeedleHaystackXXX = function(needle,needleWidth,needleHeight,needleMask, haystack,haystackWidth,haystackHeight,  type){ // make smaller output better

	// // OVERRIDE
	// // GRADIENT SCORES
	// var sigma = 1.0;
	// var needleSmooth = ImageMat.getBlurredImage(needle,needleWidth,needleHeight, sigma);
	// var needleGradient = ImageMat.gradientVector(needle,needleWidth,needleHeight);
	// 	//needleGradient = needleGradient.value;
	// var haystackSmooth = ImageMat.getBlurredImage(haystack,haystackWidth,haystackHeight, sigma);
	// var haystackGradient = ImageMat.gradientVector(haystackSmooth,haystackWidth,haystackHeight);
	// 	//haystackGradient = haystackGradient.value;
	// 	// console.log(needleGradient);
	// 	// console.log(haystackGradient);
	// var scores = Dense.searchNeedleHaystackGradient(needleGradient,needleWidth,needleHeight,needleMask, haystackGradient,haystackWidth,haystackHeight);
	// return scores;


var def = Dense.SAD;
//var def = Dense.ZSAD;
	//def = Dense.CHI;
type = (type!==undefined && type!==null) ? type : def;
	if(needleWidth>haystackWidth || needleHeight>haystackHeight){ // flipped
		console.log("FLIPPED");
		return null;
	}
	var needleCount = needleWidth*needleHeight; // == needleMask.length
	var resultWidth = haystackWidth - needleWidth + 1;
	var resultHeight = haystackHeight - needleHeight + 1;
	var resultCount = resultWidth * resultHeight;
	if(resultCount<=0){
		return [];
	}
	var mask = 1.0;
	var k;
	var minN = Math.min.apply(this,needle);
	var maxN = Math.max.apply(this,needle);
	var avgN = 0;
	var sigmaNN = 0;
	// var entropyN = Dense.entropy();
	// var momentN = 
	var maskCount = 0;
	for(k=0; k<needleCount; ++k){
		if(needleMask){ mask = needleMask[k]; }
		if(mask===0){ continue; }
		avgN += mask*needle[k];
		++maskCount;
	}
	avgN = avgN / needleCount;
	for(k=0; k<needleCount; ++k){
		if(needleMask){ mask = needleMask[k]; }
		if(mask===0){ continue; }
		sigmaNN += Math.pow(mask*needle[k] - avgN, 2);
	}
	//sigmaNN = (1.0/needleCount)*sigmaNN;
	var rangeN = maxN-minN;
	var midN = minN + rangeN*0.5;
	var invRangeN = rangeN != 0 ? rangeN : 1.0;
	var result = new Array();
	for(var j=0; j<resultHeight; ++j){
		for(var i=0; i<resultWidth; ++i){
			var resultIndex = j*resultWidth + i;
			var sad = 0;
			var zsad = 0;
			var nsad = 0;
			var ssd = 0;
			var zssd = 0;
			var psad = 0;
			var nssd = 0;
			var cc = 0;
			var zcc = 0;
			var ncc = 0;
			var zncc = 0;
			var chi = 0;
			var maxH = null;
			var minH = null;
			var avgH = 0;
			var sigmaHH = 0;
			var sigmaNH = 0;
			for(var nJ=0; nJ<needleHeight; ++nJ){ // entire needle
				for(var nI=0; nI<needleWidth; ++nI){ 
					var nIndex = nJ*needleWidth + nI;
					var hIndex = (j+nJ)*haystackWidth + (i+nI);
					if(needleMask){ mask = needleMask[nIndex]; }
					if(mask===0){ continue; }
					var n = needle[nIndex];
					var h = haystack[hIndex];
					maxH = maxH==null || maxH<h ? h : maxH;
					minH = minH==null || minH>h ? h : minH;
					avgH += h;
				}
			}
			avgH /= needleCount;
			var rangeH = maxH-minH;
			// var midH = minH + rangeH*0.5;
			// var invRangeH = rangeH != 0 ? rangeH : 1.0;
			for(var nJ=0; nJ<needleHeight; ++nJ){ // entire needle
				for(var nI=0; nI<needleWidth; ++nI){ 
					var nIndex = nJ*needleWidth + nI;
					var hIndex = (j+nJ)*haystackWidth + (i+nI);
					if(needleMask){ mask = needleMask[nIndex]; }
					if(mask===0){ continue; }
					// completely ignore a masked operation
					var n = needle[nIndex];
					var h = haystack[hIndex];
					ssd += Math.pow(n - h,2);
					sad += Math.abs(n - h);
					zsad += Math.abs( (n-avgN) - (h-avgH) );
					zssd += Math.pow( (n-avgN) - (h-avgH), 2);
					sigmaHH += Math.pow(h-avgH,2);
					sigmaNH += (n-avgN)*(h-avgH);
					cc += n*h;
					//chi += Math.pow(n - h,2)/Math.max(0.000001, n+h);
					chi += Math.pow((n-avgN) - (h-avgH),2)/Math.max(0.000001, Math.abs(n-avgN) + Math.abs(h-avgH) );
				}
			}

			chi = chi * 0.5;
			zcc = sigmaNH;
			nsad = sad / 1.0; // TODO
			psad = sad / (sigmaHH*sigmaNN);// sad * Math.abs(rangeN-rangeH)
			ncc = cc / (sigmaHH*sigmaNN);
			zncc = sigmaNH/(sigmaHH*sigmaNN);
			nssd = zssd / (sigmaHH*sigmaNN);
			//ncc = sigmaNH;///(sigmaHH*sigmaNN);
			//result[resultIndex] = 1.0/sad;
			//result[resultIndex] = ssd;
			//result[resultIndex] = ncc;
			//result[resultIndex] = sad/ncc;
			//result[resultIndex] = Math.pow(ncc,2)/sad;
			//result[resultIndex] = Math.sqrt(ncc)/sad; // bad
			//result[resultIndex] = ncc/sad;
			
			// // invert for consistency:
			// cc = 1.0 / cc;
			// //cc = 1.0 / cc;
			// //ssd = 1.0 / zssd;
			// ncc = 1.0 / ncc;
			// zncc = 1.0 / zncc;
			

			if(type==Dense.SAD){
				result[resultIndex] = sad;
			}else if(type==Dense.NSAD){
				result[resultIndex] = nsad;
			}else if(type==Dense.SSD){
				result[resultIndex] = ssd;
			}else if(type==Dense.NSSD){
				result[resultIndex] = nssd;
			}else if(type==Dense.NCC){
				result[resultIndex] = ncc;
			}else if(type==Dense.ZNCC){
				result[resultIndex] = zncc;
			}else if(type==Dense.ZCC){
				result[resultIndex] = zcc;
			}else if(type==Dense.CC){
				result[resultIndex] = cc;
			}else if(type==Dense.ZSAD){
				result[resultIndex] = zsad;
			}else if(type==Dense.PSAD){
				result[resultIndex] = psad;
			}else if(type==Dense.CHI){
				result[resultIndex] = chi;
			}else if(type==Dense.OTHER){
				result[resultIndex] = 0;
			}else{
				result[resultIndex] = 0;
			}
// var maxRange = Math.max(rangeN,rangeH);
// var minRange = Math.min(rangeN,rangeH);
//var dRange = Math.pow(1.0-minRange,.2);
//var dRange = Math.pow(minRange,10);
//result[resultIndex] =  Math.pow(sad/dRange,0.01);
// var rangeNH = rangeN*rangeH;
// var delta = 1.0/rangeNH;//10/Math.pow(rangeNH,2);
//result[resultIndex] = Math.pow(sad * Math.pow((1-minRange),10),  0.01);
//result[resultIndex] = Math.pow(zsad * delta,0.1);
// result[resultIndex] = sad;//sad;

result[resultIndex] = sad / maskCount;
//result[resultIndex] = nsad / maskCount;
//result[resultIndex] = zsad / maskCount;
//result[resultIndex] = 1.0/zncc / maskCount;

		}
	}
	return {"value":result,"width":resultWidth,"height":resultHeight};
}
*/
/*
rank:
sad
zsad
chi

zssd
ssd

cc
zcc
zncc
*/
Dense.siftVectorFromGradient = function(data, width, height, masking, groupSize, binSize){ // TODO: allow falloff fxn
//	console.log(data);
	groupSize = groupSize!==undefined ? groupSize : 4;
	binSize = binSize!==undefined ? binSize : 8;
	var i, j, k;
	var groupsI = Math.ceil(width/groupSize);
	var groupsJ = Math.ceil(height/groupSize);
	var histogramCount = groupsI * groupsJ;
	var histograms = Code.newArray(histogramCount);
	var mask = 1.0;
	for(i=0; i<histogramCount; ++i){
		histograms[i] = Code.newArrayZeros(binSize);
	}
	var vector = Code.newArrayZeros(histogramCount * binSize);
	for(j=0; j<height; ++j){
		var histogramJ = (j/groupSize) | 0;
		for(i=0; i<width; ++i){
			var index = j*width + i;
			if(masking){ mask = masking[index]; }
			var histogramI = (i/groupSize) | 0;
			var histogramIndex = histogramJ*groupsI + histogramI;
			
			var v = data[index];
//			console.log(v);
			var m = v.length();
			var a = V2D.angleDirection(V2D.DIRX,v);
				a = Code.angleZeroTwoPi(a);
			var bin = Math.min(Math.floor((a/Math.PI2)*binSize),binSize-1);
			var histogram = histograms[histogramIndex];
			histogram[bin] += m*mask;
			histogram = histograms[histogramIndex];
			histogram[bin];
		}
	}
	for(j=0; j<histogramCount; ++j){
		for(i=0; i<binSize; ++i){
			var index = j*binSize + i;
			vector[index] = histograms[j][i];
		}
	}
	Code.normalizeArray(vector);
	vector = ImageMat.pow(vector,0.5);
	Code.normalizeArray(vector);
	return vector;
	
}
Dense.searchNeedleHaystackGradient = function(needle,needleWidth,needleHeight,needleMask, haystack,haystackWidth,haystackHeight,  type){
	var needleCount = needleWidth*needleHeight;
	var resultWidth = haystackWidth - needleWidth + 1;
	var resultHeight = haystackHeight - needleHeight + 1;
	var resultCount = resultWidth * resultHeight;
	if(resultCount<=0){
		return [];
	}
	var mask = 1.0;
	var i, j, k;
	var siftN = Dense.siftVectorFromGradient(needle,needleWidth,needleHeight, needleMask);
	var result = new Array();
	for(j=0; j<resultHeight; ++j){
		for(i=0; i<resultWidth; ++i){
			var resultIndex = j*resultWidth + i;
			var siftH = [];
			for(var nJ=0; nJ<needleHeight; ++nJ){ // entire needle
				for(var nI=0; nI<needleWidth; ++nI){ 
					var nIndex = nJ*needleWidth + nI;
					var hIndex = (j+nJ)*haystackWidth + (i+nI);
					siftH[nIndex] = haystack[hIndex];
				}
			}
			siftH = Dense.siftVectorFromGradient(siftH,needleWidth,needleHeight, needleMask);
			//var sad = Code.sad(siftN,siftH);
			//var sad = Code.cc(siftN,siftH);
			var sad = Code.sad_cc(siftN,siftH);
				//ImageMat.invertFloat(sad);
				//sad = sad===0 ? 0.0 : 1.0/sad;
			result[resultIndex] = sad;
		}
	}
	return {"value":result,"width":resultWidth,"height":resultHeight};
}
Dense.uniquenessFromPoints = function(needlePoint,needleWidth,needleHeight,needleMask, sourceN,sourceNWidth,sourceNHeight,  haystackPoint,haystackWidth,haystackHeight, sourceH,sourceHWidth,sourceHHeight, scale,angle){
	var matrix;
	var sigma = null;
	matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DScale(matrix,scale);
		matrix = Matrix.transform2DRotate(matrix,angle);
	var needle = ImageMat.extractRectFromFloatImage(needlePoint.x,needlePoint.y,1.0,sigma,needleWidth,needleHeight, sourceN,sourceNWidth,sourceNHeight, matrix);
	matrix = new Matrix(3,3).identity();
	var haystack = ImageMat.extractRectFromFloatImage(haystackPoint.x,haystackPoint.y,1.0,sigma,haystackWidth,haystackHeight, sourceH,sourceHWidth,sourceHHeight, matrix);
	var uniqueness = Dense.uniqueness(needle,needleWidth,needleHeight,needleMask,   haystack,haystackWidth,haystackHeight);
	return uniqueness;
}

Dense.uniquenessOLD = function(needle,needleWidth,needleHeight,needleMask, haystack,haystackWidth,haystackHeight, type){	
/*
	var scores = Dense.searchNeedleHaystack(needle,needleWidth,needleHeight,needleMask, haystack,haystackWidth,haystackHeight, type);
	var values = scores.value;
	var width = scores.width;
	var height = scores.height;
	var i;
	var result = 0;
	var count = 0;
	var values = values.sort( function(a,b){ return a<b ? -1 : 1; } );
var str = "x=[";
for(var i=0; i<values.length; ++i){
	str = str+values[i].toExponential(4) +",";
}
str += "];";
console.log("\n\n"+str+"\n\n");
*/
return Dense.uniqueness2(needle,needleWidth,needleHeight,needleMask, haystack,haystackWidth,haystackHeight, type);

console.log(values);
	var minValue = values[0];
	for(i=0; i<values.length; ++i){
		var value = values[i];
		if(value===undefined || value===null){
			continue;
		}
		var decay = 1.0 - Math.exp(-0.5 * i); // 0.7 => 0.0, 0.5, 0.75, 0.877, ...
		var comp = value;
		//comp = 1.0/comp;
		//comp = (1.0 + value-minValue);
		//comp = (1.0 - value);
		//comp = Math.pow(comp,2);
		//comp = comp * 
		var comp = 1.0/Math.pow(value,2);
		//comp = comp * decay;
		//console.log(i+": "+value+"   =>  "+comp);
		result += comp * decay;
		++count;
	}
//console.log("total: "+result);
//result = Math.pow(result,2);
// 
// average 'area'
// 
	//result = Math.pow(result,0.5);
	if(count>0){
		result = result / count;
	}
	//result = Math.pow(result,0.5);
//console.log("average: "+result);
	//result = 1.0 / (1.0 + result);
	//result = Math.pow(result,4);
	//result = Math.log(result);
	//result = Math.pow(result,0.1);
	//result = Math.pow(result,1E-6);
	
	return result;
	/*
	0.2 ... 59.0
	*/
	/*
		get scores in neighborhood
		sort scores by lowest to heighest
		uniqueness = SUM_i( (1/score_i)^n )

		1/0.1 + 1/0.2 + 1/0.9 + 1/10 + 1/100 + ...
		10 + 5 + 1.11 + 0.1 + 0.001 + ...

		divide by total count (average) uniquenss in area ?
		lower uniqueness is better
	*/
}
Dense.moment = function(data, mom){
	mom = mom!==undefined ? mom : 3;
	var i, len=data.length;
	if(len==0){
		return 0;
	}
	var total = 0;
	for(i=0; i<len; ++i){
		total += data[i];
	}
	var mean = total / len;
	var variance = 0;
	for(i=0; i<len; ++i){
		variance += Math.pow(data[i]-mean,2);
	}
	variance = variance / mean;
	var stddev = Math.sqrt(variance);
	var moment = 0;
	for(i=0; i<len; ++i){
		moment += Math.pow(data[i]-mean,mom);
	}
	moment = moment / ( total * Math.pow(stddev,mom) )
	return moment;
}
Dense.skew = function(data){
	return Dense.moment(data, 3);
}
Dense.kertosis = function(data){
	return Dense.moment(data, 4);
}
Dense.slope = function(values,start,count,skip){
	skip = skip!==undefined ? skip : 0;
	var i;
	var points = [];
	for(i=0; i<count; ++i){
		var index = start + i + skip*i;
		var value = values[index];
		var point = new V2D(i,value);
		points.push( point );
	}
	var line = Code.bestFitLine2D(points);
	var intercept = line["b"];
	var slope = line["m"];
	return slope;
}
Dense.uniqueness = function(needle,needleWidth,needleHeight,needleMask, haystack,haystackWidth,haystackHeight, type){
	throw "old"
}
Dense.uniquenessFromValues = function(valuesIn){
	var values = Code.copyArray(valuesIn).sort( function(a,b){ return a<b ? -1 : 1; } );
	// use differentials to get a peakness value
	// var sigma = 1.0;
	// var filter = ImageMat.gaussianWindow1DFromSigma(sigma);
	// var averaged = Code.convolve1D(values,filter);
	// values = averaged;
	// peaked = averaged[1] - averaged[0];
	// return 1.0/peaked;
	// var range = values[values.length-1] - values[0];
	// peaked = values[10] - values[0];
	// return range/peaked;

	// values[0] ~ 0.25
	// values[1] ~ 0.26
	// v1 - v0 ~ 0.01

	//return 1.0 - (values[1] - values[0]);

var diff = Math.max(values[1] - values[0],1E-6);
return 1.0/diff;

	//return values[0]/diff;

	//return 1.0/Math.abs(values[0] - values[1]);
return values[0]/values[1]; // OK
	// return (values[0]/values[1] + values[0]); // OK
	// return values[0]/values[1]/values[2]; // BAD


	//return 1.0/Dense.slope(values, 0, 3, 0); // NO
	//return 1.0/Dense.slope(values, 0, 2, 0); // NO
	
	


	// VERSION 3
	var s0 = Dense.slope(values, 0, 5, 0);
	var s1 = Dense.slope(values, 0, 10, 0);
	//var s = Dense.slope(values, 0, 2, 0);
	//var s = Dense.slope(averaged, 0, 5, 0);
	//var s = Dense.slope(values, 0, 10, 1);
	//var s = Dense.slope(values, 0, 25, 1);
	s0 = Math.max(s0,1E-10);
	s1 = Math.max(s1,1E-10);
	var uniqueness = 1.0/s1/s0;
	uniqueness = Math.pow(uniqueness,0.1);
	return uniqueness;
	//return 1.0/s0;
	

	/*
	var count = 3;
	var skip = 1;
	var i, j;
	var peakness = 1.0;
	for(i=0; i<count; i+=skip){
		var diff = averaged[i+1]-averaged[i];
		if(diff>0){
			peakness = peakness/diff;
		}
	}
	return peakness;
	*/
	// VERSION 2:
	/*
	var carePortion = 0.10;
	var careAmount = values.length*carePortion;
	var sections = 2;
	var starts = careAmount/sections;
	var samps = 3;//Math.floor(careAmount);// this can be a lot
	var skips = 1;//Math.floor(starts/samps);
	var mag = 1.0;
	for(i=0; i<sections; ++i){
		var s = Dense.slope(values, Math.floor(i*starts), samps, skips);
		mag = mag/s;
	}
	//mag = mag / peaked;
	mag = Math.pow(mag,0.1); // to human readable scale
	//mag = range / mag;
	return mag;
	*/

	/*
	// VERSION 2:
	var dy01 = values[1]-values[0];
	var dy12 = values[2]-values[1];
	var dyy = values[2] - 2*values[1] + values[0];
	return dyy;
	*/
	return Dense.slope(values, 0, 5, 0);
}

Dense._handleKeyboardDown = function(e){
	if(e.keyCode==Keyboard.KEY_SPACE){
		console.log("space");
	}
}



Dense.Lattice = function(imageFr, imageTo, corners, size, matrixFfwd){
	this._imageFr = imageFr;
	this._imageTo = imageTo;
	this._cellSize = null;
	this.cellSize(size);
	this._matrixFrev = null;
	this._matrixFfwd = null;
	this.F(matrixFfwd);
	var imageWidth = this._imageFr.width();
	var imageHeight = this._imageFr.height();
	var cols = Math.ceil(imageWidth/size);
	var rows = Math.ceil(imageHeight/size);
	var sizeX = size;
	var sizeY = size;
	this._cols = cols;
	this._rows = rows;
	this._vertexes = [];
	var i, j, index;
	for(j=0; j<rows; ++j){
		for(i=0; i<cols; ++i){
			index = j*cols + i;
			var startX = Math.floor(i*sizeX);
			var startY = Math.floor(j*sizeY);
			var cell = ImageMat.subImage(corners, imageWidth,imageHeight, startX,startY, sizeX,sizeY);
			var info = Code.infoArray(cell);
			var maxIndex = info["indexMax"];
			var maxX = maxIndex%sizeX;
			var maxY = maxIndex/sizeX | 0;
			//var point = new V2D(startX + maxX, startY + maxY);
			var point = new V2D(startX + sizeX*0.5, startY + sizeY*0.5);
			this._vertexes[index] = new Dense.Vertex(this, j,i, point);
		}
	}
}
Dense.Lattice.prototype.F = function(f){
	if(f!==undefined){
		this._matrixFfwd = f;
		if(f!==null){
			this._matrixFrev = R3D.fundamentalInverse(this._matrixFfwd);
		}else{
			this._matrixFrev = null;
		}
	}
	return this._matrixFfwd;
}
Dense.Lattice.prototype.Finv = function(){
	return this._matrixFrev;
}
Dense.Lattice.prototype.rows = function(){
	return this._rows;
}
Dense.Lattice.prototype.cols = function(){
	return this._cols;
}
Dense.Lattice.prototype.imageFrom = function(i){
	if(i!==undefined){
		this._imageFr = i;
	}
	return this._imageFr;
}
Dense.Lattice.prototype.imageTo = function(i){
	if(i!==undefined){
		this._imageTo = i;
	}
	return this._imageTo;
}
Dense.Lattice.prototype.cellSize = function(size){
	if(size!==undefined){
		this._cellSize = size;
	}
	return this._cellSize;
}
Dense.Lattice.prototype.closestVertex = function(point){
	var width = this._imageFr.width();
	var height = this._imageFr.height();
	var col = ((point.x/width)*this._cols) | 0;
	var row = ((point.y/height)*this._rows) | 0;
	if(col<0){
		col = 0;
	}
	if(row<0){
		row = 0;
	}
	if(col>=this._cols){
		col = this._cols - 1;
	}
	if(row>=this._rows){
		row = this._rows - 1;
	}
	var vertex = this._vertexFromColRow(col,row);
	if(!vertex){ // outside area ? 
		console.log("VERTEX NULL - WHAT ?");
	}
	var neighbors = vertex.neighborhood();
	var i;
	var closest = null, minDistance = null;
	for(i=0; i<neighbors.length; ++i){
		var n = neighbors[i];
		var from = n.from();
		var distance = V2D.distance(point,from);
		if(!closest || distance<minDistance){
			closest = n;
			minDistance = distance;
		}
	}
	return closest;
}
Dense.Lattice.prototype.vertex = function(a,b){
	if(arguments.length==2){
		return this._vertexFromColRow(a,b);
	}else if(Code.isa(a,V2D)){ // point index
		var col = ((a.x/this._width)*this._cols) | 0;
		var row = ((a.y/this._height)*this._rows) | 0;
		return this._vertexFromColRow(col,row);
	}else{
		console.log("unknown");
	}
	return null;
}
Dense.Lattice.prototype._vertexFromColRow = function(col,row){
	var index = this._indexFromColRow(col,row);
	if(index!==null){
		return this._vertexes[index];
	}
	return null;
}
Dense.Lattice.prototype._indexFromColRow = function(col,row){
	if(0<=row && row<this._rows  &&  0<=col && col<this._cols){
		var index = row*this._cols + col;
		return index;
	}
	return null;
}
Dense.Lattice.prototype.allValidCells = function(fromPoint, maximumCount, maximumDistance){
	var i, j, v, list = [];
	var rows = this._rows;
	var cols = this._cols;
	for(j=0; j<rows; ++j){
		for(i=0; i<cols; ++i){
			v = this.vertex(i,j);
			if(v.to() && v.isJoined()){
				var distance = 1E12;
				if(fromPoint){
					distance = V2D.distance(fromPoint,v.from());
				}
				list.push([v,distance]);
			}
		}
	}
	if(maximumCount || maximumDistance){
		list = list.sort(function(a,b){
			var distanceA = a[1];
			var distanceB = b[1];
			return distanceA<distanceB ? -1 : 1;
		});
		if(maximumCount){
			if(maximumCount<list.length){
				list = Code.copyArray(list,0,maximumCount-1);
			}
		}else if(maximumDistance){
			for(i=0; i<list.length; ++i){
				var distance = list[i][1];
				if(distance>maximumDistance){
					list = Code.copyArray(list,0,i-1);
					break;
				}
			}
		}
	}
	for(i=0; i<list.length; ++i){ // remove appended distances
		list[i] = list[i][0];
	}
	return list;
}
Dense.Lattice.prototype.printYAML = function(){
	var str = "";
	str += "# dense mapping \n";
	var i, j, k;
	var vertex, from, to;
	var rows = this.rows();
	var cols = this.cols();
	//var cells = this.cells();
	str += "created: "+Code.getTimeStampFromMilliseconds()+"\n";
	str += "imageFrom: \n";
	str += "imageTo: \n";
	str += "mapping: \n";
	// image: filename, width, height, 
	//
	for(j=0; j<rows; ++j){
		for(i=0; i<cols; ++i){
			vertex = this._vertexFromColRow(i,j);
			if(vertex.isJoined()){
				from = vertex.from();
				to = vertex.to()
				str += "\t-\n";
				str += "\t\tfrom:\n"; // pointCenter
				str += "\t\t\tx: "+from.x+"\n";
				str += "\t\t\ty: "+from.y+"\n";
				str += "\t\tto:\n";
				str += "\t\t\tx: "+to.x+"\n";
				str += "\t\t\ty: "+to.y+"\n";
			}
		}
	}
	console.log("\n\n"+str+"\n\n");
}



// var distanceA = V2D.distanceSquare(fromPoint,a.from());
// var distanceB = V2D.distanceSquare(fromPoint,b.from());
Dense.Transform = function(to, scale, angle, score, rank){
	this._score = null;
	this._rank = null;
	this._to = null;
	this._scale = 1.0; // transform FROM A TO B
	this._angle = 0.0; // 0.5 === B is half as big as A
}
Dense.Transform.prototype.toString = function(){
	return "[T: r: "+this._rank+"  s: "+this._score+" @ "+this._scale+" @ "+Code.degrees(this._angle)+"  => "+this._to+" ]";
}
Dense.Transform.prototype.scale = function(s){
	if(s!==undefined){
		this._scale = s;
	}
	return this._scale;
}
Dense.Transform.prototype.angle = function(a){
	if(a!==undefined){
		this._angle = a;
	}
	return this._angle;
}
Dense.Transform.prototype.score = function(s){
	if(s!==undefined){
		this._score = s;
	}
	return this._score;
}
Dense.Transform.prototype.rank = function(r){
	if(r!==undefined){
		this._rank = r;
	}
	return this._rank;
}
Dense.Transform.prototype.to = function(t){
	if(t!==undefined){
		this._to = t;
	}
	return this._to;
}
Dense.Vertex = function(lattice, row, col, from){
	this._lattice = lattice;
	this._row = row;
	this._col = col;
	this._pointFrom = null;
	this._matches = [new Dense.Transform()]; // default transform
	this._currentTransform = 0;
	this.from(from);
	this._joined = false;
	this._temp = null;
}
Dense.Vertex.prototype.temp = function(t){
	if(t!==undefined){
		this._temp = t;
	}
	return this._temp;
}
Dense.Vertex.prototype.toString = function(){
	var str = "[Vertex: "+this._col+","+this._row+" : "+this.from()+"=>"+this.to()+" @ "+this.scale()+" @ "+this.angle()+" deg "+"]";
	return str;
}
Dense.Vertex.prototype.lattice = function(l){
	if(l!==undefined){
		this._lattice = l;
	}
	return this._lattice;
}
Dense.Vertex.prototype.isJoined = function(){
	return this._joined;
}
Dense.Vertex.prototype.join = function(j){
	j = true;
	if(j!==undefined){
		this._joined = j;
	}
	return this._joined;
}
Dense.Vertex.prototype.pointCenter = function(){
	var cellSize = this._lattice.cellSize();
	return new V2D(this._col*cellSize + cellSize*0.5, this._row*cellSize + cellSize*0.5);
}
Dense.Vertex.prototype.pointTL = function(){
	var halfCellSize = this._lattice.cellSize()*0.5;
	return this.pointCenter().add(-halfCellSize, -halfCellSize);
}
Dense.Vertex.prototype.pointTR = function(){
	var halfCellSize = this._lattice.cellSize()*0.5;
	return this.pointCenter().add(halfCellSize, -halfCellSize);
}
Dense.Vertex.prototype.pointBL = function(){
	var halfCellSize = this._lattice.cellSize()*0.5;
	return this.pointCenter().add(-halfCellSize, halfCellSize);
}
Dense.Vertex.prototype.pointBR = function(){
	var halfCellSize = this._lattice.cellSize()*0.5;
	return this.pointCenter().add(halfCellSize, halfCellSize);
}
Dense.Vertex.prototype.TL = function(){
	return this._lattice.vertex(this._col-1,this._row-1);
}
Dense.Vertex.prototype.top = function(){
	return this._lattice.vertex(this._col,this._row-1);
}
Dense.Vertex.prototype.TR = function(){
	return this._lattice.vertex(this._col+1,this._row-1);
}
Dense.Vertex.prototype.left = function(){
	return this._lattice.vertex(this._col-1,this._row);
}
Dense.Vertex.prototype.right = function(){
	return this._lattice.vertex(this._col+1,this._row);
}
Dense.Vertex.prototype.BL = function(){
	return this._lattice.vertex(this._col-1,this._row+1);
}
Dense.Vertex.prototype.bottom = function(){
	return this._lattice.vertex(this._col,this._row+1);
}
Dense.Vertex.prototype.BR = function(){
	return this._lattice.vertex(this._col+1,this._row+1);
}
Dense.Vertex.prototype.row = function(r){
	if(r!==undefined){
		this._row = r;
	}
	return this._row;
}
Dense.Vertex.prototype.col = function(c){
	if(c!==undefined){
		this._col = c;
	}
	return this._col;
}
Dense.Vertex.prototype.from = function(f){
	if(f!==undefined){
		this._pointFrom = f;
	}
	return this._pointFrom;
}
Dense.Vertex.prototype.transform = function(t){
	if(t!==undefined){
		this._currentTransform = t;
	}
	if(this._currentTransform!==null){
		return this._matches[this._currentTransform];
	}
	return null;
}
Dense.Vertex.prototype.matches = function(m){
	if(m!==undefined){
		this._matches = m;
	}
	return this._matches;
}
Dense.Vertex.prototype.to = function(t){
	var transform = this.transform();
	if(transform){
		return transform.to(t);
	}
	return null;
}
Dense.Vertex.prototype.rank = function(r){
	var transform = this.transform();
	if(transform){
		return transform.rank(r);
	}
	return null;
}
Dense.Vertex.prototype.score = function(s){
	var transform = this.transform();
	if(transform){
		return transform.score(s);
	}
	return null;
}
Dense.Vertex.prototype.angle = function(a){
	var transform = this.transform();
	if(transform){
		return transform.angle(a);
	}
	return null;
}
Dense.Vertex.prototype.scale = function(s){
	var transform = this.transform();
	if(transform){
		return transform.scale(s);
	}
	return null;
}
Dense.Vertex.prototype.neighborhood = function(){
	var neighborhood = this.neighbors();
	Code.arrayPushNotNull(neighborhood,this);
	return neighborhood;
}
Dense.Vertex.prototype.neighbors = function(){
	var neighborhood = [];
	var TL = this.TL();
	var TM = this.top();
	var TR = this.TR();
	var ML = this.left();
	var MR = this.right();
	var BL = this.BL();
	var BM = this.bottom();
	var BR = this.BR();
	Code.arrayPushNotNull(neighborhood,TL);
	Code.arrayPushNotNull(neighborhood,TM);
	Code.arrayPushNotNull(neighborhood,TR);
	Code.arrayPushNotNull(neighborhood,ML);
	Code.arrayPushNotNull(neighborhood,MR);
	Code.arrayPushNotNull(neighborhood,BL);
	Code.arrayPushNotNull(neighborhood,BM);
	Code.arrayPushNotNull(neighborhood,BR);
	return neighborhood;
}
Dense.Vertex.prototype.crossedNeighbors = function(toPoint){
// TODO: this could cross ANYWHERE .. need to search entire TO haystack radius
	var i;
	var crossed = [];
	var TL = this.TL();
	var TM = this.top();
	var TR = this.TR();
	var ML = this.left();
	var MR = this.right();
	var BL = this.BL();
	var BM = this.bottom();
	var BR = this.BR();
	var direct = []; // 4 possible edges
	Dense.Vertex.pushValid(direct,TM);
	Dense.Vertex.pushValid(direct,ML);
	Dense.Vertex.pushValid(direct,MR);
	Dense.Vertex.pushValid(direct,BM);
	var pairs = []; // 8 possible edges
	Dense.Vertex.pushValidPair(pairs, TL,TM);
	Dense.Vertex.pushValidPair(pairs, TM,TR);
	Dense.Vertex.pushValidPair(pairs, TR,MR);
	Dense.Vertex.pushValidPair(pairs, MR,BR);
	Dense.Vertex.pushValidPair(pairs, BR,BM);
	Dense.Vertex.pushValidPair(pairs, BM,BL);
	Dense.Vertex.pushValidPair(pairs, BL,ML);
	Dense.Vertex.pushValidPair(pairs, ML,TL);
	for(i=0; i<direct.length; ++i){
		n = direct[i];
		var oNew = n.to();
		var dNew = V2D.sub(toPoint,oNew);
		for(j=0; j<pairs.length; ++j){
			var pair = pairs[j];
			var a = pair[0];
			var b = pair[1];
			var oEdge = a.to();
			var dEdge = V2D.sub(b.to(),oEdge);
			var intersection = Code.rayFiniteIntersect2D(oNew,dNew, oEdge,dEdge);
			if(intersection){
				Code.addUnique(crossed, a);
				Code.addUnique(crossed, b);
			}
		}
	}
	return crossed;
}
Dense.Vertex.pushValid = function(a, n){
	if(n){
		var to = n.to();
		if(to && n.isJoined()){
			a.push(n);
		}
	}
}
Dense.Vertex.pushValidPair = function(a, n,m){
	if(n && m){
		var toN = n.to();
		var toM = m.to();
		if(toN && toM && n.isJoined() && m.isJoined()){
			a.push([n,m]);
		}
	}
}
Dense.Vertex.prototype.assignNeighbors = function(queue, interpolator){
	var neighbors = this.neighbors();
	var angle = this.angle();
	var scale = this.scale();
	for(var i=0; i<neighbors.length; ++i){
		var n = neighbors[i];
		if(!n.isJoined()){
			//console.log("neighbor: "+i);
			//queue.remove(n); // TODO: BECAUSE 
			//var same = Dense.assignBestNeedleInHaystack(interpolator, n, queue, true);
			//if(same){
			// interpolator.setAsTri();
			// 	Dense.assignBestNeedleInHaystack(interpolator, n, queue);
			//interpolator.setAsNeighbor();
				Dense.assignBestNeedleInHaystack(interpolator, n, queue);
			//}
		}
	}
}

Dense.bestTransformationFromPoints = function(imageA,pointA, imageB,pointB, cellSize, rev){ // only for seed points, // assumed correctly matched
	var imageARed = imageA.red();
	var imageAGrn = imageA.grn();
	var imageABlu = imageA.blu();
	var imageAGry = imageA.gry();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();
	var imageBRed = imageB.red();
	var imageBGrn = imageB.grn();
	var imageBBlu = imageB.blu();
	var imageBGry = imageB.gry();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();

	var calculateScale = 2.0; // 0.50; // 0.25;
	var windowSize = 11;//Math.max(cellSize,Dense.MINIMUM_CELL_SIZE);


	var scaleA = pointA.z ? pointA.z : 1.0;
	var scaleB = pointB.z ? pointB.z : 1.0;
	var angleA = pointA.t ? pointA.t : 0.0;
	var angleB = pointB.t ? pointB.t : 0.0;

	var relativeScaleAtoB = scaleB/scaleA;
	var relativeAngleAtoB = angleB - angleA;

	var nativeSizeA = scaleA;
	var nativeSizeB = scaleB;

	var scaleUpA = pointA.z ? windowSize/scaleA : 1.0;
	var scaleUpB = pointB.z ? windowSize/scaleB : 1.0;

	// scaleUpA = 1.0 / scaleUpA;
	// scaleUpB = 1.0 / scaleUpB;

 	var mask = ImageMat.circleMask(windowSize);
 	var center = Math.floor(windowSize * 0.5);
 	var i, j, k, l, score;
 	var aGry, aRed, aGrn, aBlu;
 	var bGry, bRed, bGrn, bBlu;
 	var u, v, scale, rotation, sigma, matrix;
	var minScore = null;
	var optimumScale = null;
	var optimumRotation = null;
	var optimumAsymmAngle = null;
	var optimumAsymmScale = null;
	// do A = haystack

		sigma = 4.0;
		scale = 1.0;
		rotation = 0.0;
		matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DRotate(matrix,rotation);
		// get local image A
		if(!angleA){
			aGry = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,scale*calculateScale,sigma,windowSize,windowSize, imageAGry,imageAWidth,imageAHeight, matrix);
			u = ImageMat.gradientVector(aGry, windowSize,windowSize, center,center);
			angleA = V2D.angle(V2D.DIRX,u);
		}
		// get local image B
		if(!angleB){
			bGry = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,scale*calculateScale,sigma,windowSize,windowSize, imageBGry,imageBWidth,imageBHeight, matrix);
			u = ImageMat.gradientVector(bGry, windowSize,windowSize, center,center);
			angleB = V2D.angle(V2D.DIRX,u);
		}
		// get 0-angled image A
		sigma = null;
		scale = 1.0 / scaleUpA;
		rotation = -angleA;
		matrix = new Matrix(3,3).identity();
		matrix = Matrix.transform2DRotate(matrix,rotation);
		aRed = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,scale*calculateScale,sigma,windowSize,windowSize, imageARed,imageAWidth,imageAHeight, matrix);
		aGrn = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,scale*calculateScale,sigma,windowSize,windowSize, imageAGrn,imageAWidth,imageAHeight, matrix);
		aBlu = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y,scale*calculateScale,sigma,windowSize,windowSize, imageABlu,imageAWidth,imageAHeight, matrix);

/*
if(!rev){//===true){
//Dense.js:3546 INFO: 15.151515151515152 | 10 == 0.6599999999999999 @ 0
	console.log("INFO: "+scaleA+" | "+scaleB+" == "+relativeScaleAtoB+" @ "+Code.degrees(relativeAngleAtoB));

var d = new DO();
	d.graphics().setLine(1, 0xFFFF0000);
	d.graphics().beginPath();
	d.graphics().drawRect(-scaleA*0.5,-scaleA*0.5, scaleA,scaleA);
	d.graphics().strokeLine();
	d.graphics().endPath();
d.matrix().translate(pointA.x,pointA.y);
GLOBALSTAGE.addChild(d);

var d = new DO();
	d.graphics().setLine(1, 0xFFFF0000);
	d.graphics().beginPath();
	d.graphics().drawRect(-scaleB*0.5,-scaleB*0.5, scaleB,scaleB);
	d.graphics().strokeLine();
	d.graphics().endPath();
d.matrix().translate(pointB.x,pointB.y);
d.matrix().translate(400,0);
GLOBALSTAGE.addChild(d);


var img = GLOBALSTAGE.getFloatRGBAsImage(aRed,aGrn,aBlu, windowSize,windowSize);
var d = new DOImage(img);
d.matrix().translate(20,200);
d.matrix().scale(1.0);
GLOBALSTAGE.addChild(d);

}
*/


	var scales = Code.lineSpace(-2,0,0.5); // negatives should be done on opposite image -- scaling down only here
	var rotations = Code.lineSpace(-25,25,10); // trusting gradient
	//var rotations = Code.lineSpace(-180,170,10); // don't trust gradient vector currently
	//var rotations = Code.lineSpace(-180,160,20);

	//var scales = Code.lineSpace(-1,0, 0.5);
	//var rotations = Code.lineSpace(-25,25,10);

	// scales = [1.0];
	// rotations = [0.0];
	var asymmAngles = [0.0];
	var asymmScales = [0.0];
	// var asymmAngles = Code.lineSpace(-90,60,30);
	 //var asymmAngles = Code.lineSpace(-90,70,20);
	//var asymmAngles = Code.lineSpace(-90,80,10);
	//var asymmScales = Code.lineSpace(0.0,0.5,0.1);
	//var asymmScales = Code.lineSpace(-2,2,0.25);
	// do Bs = needles
var iter = 0;
	for(i=0; i<scales.length; ++i){
		scale = scales[i];
		scale = Math.pow(2,scale);
		scale = scale * scaleUpB;
		for(j=0; j<rotations.length; ++j){
			rotation = rotations[j];
			rotation = Code.radians(rotation);
			rotation -= angleB;
			for(k=0; k<asymmScales.length; ++k){
				var asymmScale = asymmScales[k];
				asymmScale = Math.pow(2,asymmScale);
				for(l=0; l<asymmAngles.length; ++l){
					var asymmAngle = asymmAngles[l];
					asymmAngle = Code.radians(asymmAngle);
					sigma = null;
					matrix = new Matrix(3,3).identity();
					matrix = Matrix.transform2DRotate(matrix,rotation);
					matrix = Matrix.transform2DScale(matrix,scale);
					matrix = Matrix.transform2DRotate(matrix,-asymmAngle);
					matrix = Matrix.transform2DScale(matrix,asymmScale,1.0);
					matrix = Matrix.transform2DRotate(matrix,asymmAngle);
					bRed = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0*calculateScale,sigma,windowSize,windowSize, imageBRed,imageBWidth,imageBHeight, matrix);
					bGrn = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0*calculateScale,sigma,windowSize,windowSize, imageBGrn,imageBWidth,imageBHeight, matrix);
					bBlu = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0*calculateScale,sigma,windowSize,windowSize, imageBBlu,imageBWidth,imageBHeight, matrix);
/*
var img = GLOBALSTAGE.getFloatRGBAsImage(bRed,bGrn,bBlu, windowSize,windowSize);
var d = new DOImage(img);
d.matrix().translate(20 + iter*(windowSize+1),200+(windowSize+1));
d.matrix().scale(1.0);
GLOBALSTAGE.addChild(d);
++ iter;
*/
					// SCORE
					//score = Dense.sad(aRed,aGrn,aBlu,bRed,bGrn,bBlu, mask);
					score = Dense.ncc(aRed,aGrn,aBlu,bRed,bGrn,bBlu, mask);
					if(minScore==null || score<minScore){
						minScore = score;
						optimumRotation = rotation;
						optimumAsymmScale = asymmScale;
						optimumAsymmAngle = asymmAngle;
						optimumScale = scale;
					}
					if(asymmScale==1.0){break;}
				}
			}
		}
	}
/*
	// // TODO: do LM minimization using scale & rotation variables & SAD to find minimum
	var result = Dense.gdOptimumScaleRotation(pointA,pointB, imageA,imageB, windowSize,windowSize,calculateScale,mask,aRed,aGrn,aBlu, optimumScale,optimumRotation,
		optimumScale*0.9,optimumScale/0.9, optimumRotation-Code.radians(10),optimumRotation+Code.radians(10));
	//console.log("OPT: "+optimumScale+","+optimumRotation+" @ "+minScore+" => "+result["scale"]+","+result["rotation"]+" @ "+result["cost"]);
	optimumScale = result["scale"];
	optimumRotation = result["rotation"];
*/

// refine rotation
var rotations = Code.lineSpace(-4,4,1);
for(i=0; i<rotations.length; ++i){
	rotation = rotations[i];
	rotation = Code.radians(rotation);
	// rotation -= angleB;
	rotation += optimumRotation;
	//rotation -= angleB;
	sigma = null;
	matrix = new Matrix(3,3).identity();
	matrix = Matrix.transform2DRotate(matrix,optimumAsymmAngle);
	matrix = Matrix.transform2DScale(matrix,optimumAsymmScale,1.0);
	matrix = Matrix.transform2DRotate(matrix,-optimumAsymmAngle);
	matrix = Matrix.transform2DRotate(matrix,rotation);
	matrix = Matrix.transform2DScale(matrix,optimumScale);
	bRed = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0*calculateScale,sigma,windowSize,windowSize, imageBRed,imageBWidth,imageBHeight, matrix);
	bGrn = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0*calculateScale,sigma,windowSize,windowSize, imageBGrn,imageBWidth,imageBHeight, matrix);
	bBlu = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y,1.0*calculateScale,sigma,windowSize,windowSize, imageBBlu,imageBWidth,imageBHeight, matrix);
	score = Dense.sad(aRed,aGrn,aBlu,bRed,bGrn,bBlu, mask);
	if(score<minScore){
		//console.log(i+": "+score+" / "+minScore);
		minScore = score;
		optimumRotation = rotation;
	}
}

	// FROM B->A to A->B
	optimumScale = 1.0/optimumScale;
	optimumRotation = -(optimumRotation + angleA);
	optimumAsymmScale = 1.0/optimumAsymmScale;
	optimumAsymmAngle = -optimumAsymmAngle;
	//console.log("OPTIMUM: "+optimumScale+" | "+Code.degrees(optimumRotation)+" | "+optimumAsymmScale+" | "+Code.degrees(optimumAsymmAngle));
	return {"score":minScore, "angle":optimumRotation, "scale":optimumScale, "asymmAngle":optimumAsymmAngle, "asymmScale":optimumAsymmScale};
}
//Dense.lmOptimumScaleRotation = function(pointA,pointB, imageA,imageB, compareWidth,compareHeight,compareScale,compareMask,aRed,aGrn,aBlu, startScale,startRotation){
Dense.gdOptimumScaleRotation = function(pointA,pointB, imageA,imageB, compareWidth,compareHeight,compareScale,compareMask,aRed,aGrn,aBlu, startScale,startRotation, minScale,maxScale,minRot,maxRot){
	if(!aRed || !aGrn || !aBlu){
		var matrix = new Matrix(3,3).identity();
		var sigma = null;
		aRed = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y, compareScale,sigma,compareWidth,compareHeight, imageA.red(),imageA.width(),imageA.height(), matrix);
		aGrn = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y, compareScale,sigma,compareWidth,compareHeight, imageA.red(),imageA.width(),imageA.height(), matrix);
		aBlu = ImageMat.extractRectFromFloatImage(pointA.x,pointA.y, compareScale,sigma,compareWidth,compareHeight, imageA.red(),imageA.width(),imageA.height(), matrix);
	}
	var xVals = [startScale,startRotation];
	var args = [pointA,pointB,imageA,imageB,compareWidth,compareHeight,compareScale, compareMask, aRed,aGrn,aBlu, minScale,maxScale,minRot,maxRot];
	//var yVals = Code.newArrayZeros(1);
	//var yVals = Code.newArrayZeros(compareWidth*compareHeight);
	//Matrix.lmMinimize( Dense._lmScaleRotationOptimiumFxn, args, yVals.length,xVals.length, xVals, yVals,  undefined,undefined,undefined, false, 1E-12 ); // NEED TO PASS TRUE ?
	result = Code.gradientDescent(Dense._gdScaleRotationOptimiumFxn, args, xVals);
	xVals = result["x"];
	var cost = result["cost"];
	var scale = xVals[0];
	var rotation = xVals[1];
	return {"scale":scale, "rotation":rotation, "cost":cost};
}
Dense._gdScaleRotationOptimiumFxn = function(args, x){
	var currentScale = x[0];
	var currentAngle = x[1];

	var pointA = args[0];
	var pointB = args[1];
	var imageA = args[2];
	var imageB = args[3];
	var compareWidth = args[4];
	var compareHeight = args[5];
	var compareScale = args[6];
	var mask = args[7];
	var aRed = args[8];
	var aGrn = args[9];
	var aBlu = args[10];
	var limitScaleMin = args[11];
	var limitScaleMax = args[12];
	var limitRotationMin = args[13];
	var limitRotationMax = args[14];
	/*
	var limitScaleMin = startScale*0.5;
	var limitScaleMax = startScale*2.0;
	var limitRotationMin = startRotation - Code.radians(20);
	var limitRotationMax = startRotation + Code.radians(20);
	*/
	if(currentScale<limitScaleMin || currentScale>limitScaleMax || currentAngle<limitRotationMin || currentAngle>limitRotationMax){
		return 1E10; // outside range = bad
	}
	var imageARed = imageA.red();
	var imageAGrn = imageA.grn();
	var imageABlu = imageA.blu();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();
	var imageBRed = imageB.red();
	var imageBGrn = imageB.grn();
	var imageBBlu = imageB.blu();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();

	var sigma = null;
	var matrix = new Matrix(3,3).identity();
	matrix = Matrix.transform2DRotate(matrix,currentAngle);
	matrix = Matrix.transform2DScale(matrix,currentScale);
	
	var bRed = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y, compareScale,sigma,compareWidth,compareHeight, imageBRed,imageBWidth,imageBHeight, matrix);
	var bGrn = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y, compareScale,sigma,compareWidth,compareHeight, imageBGrn,imageBWidth,imageBHeight, matrix);
	var bBlu = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y, compareScale,sigma,compareWidth,compareHeight, imageBBlu,imageBWidth,imageBHeight, matrix);
	
	var score = Dense.sad(aRed,aGrn,aBlu,bRed,bGrn,bBlu, mask);
	return score;
}
Dense._lmScaleRotationOptimiumFxn = function(args, xMatrix,yMatrix,eMatrix){
	var pointA = args[0];
	var pointB = args[1];
	var imageA = args[2];
	var imageB = args[3];
	var compareWidth = args[4];
	var compareHeight = args[5];
	var compareScale = args[6];
	var mask = args[7];
	var aRed = args[8];
	var aGrn = args[9];
	var aBlu = args[10];

	var imageARed = imageA.red();
	var imageAGrn = imageA.grn();
	var imageABlu = imageA.blu();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();2
	var imageBRed = imageB.red();
	var imageBGrn = imageB.grn();
	var imageBBlu = imageB.blu();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();
	var currentScale = xMatrix.get(0,0);
	var currentAngle = xMatrix.get(1,0);

	var length = compareWidth*compareHeight;
//console.log(".  GOT: "+currentScale+","+Code.degrees(currentAngle));
	var sigma = null;
	var matrix = new Matrix(3,3).identity();
	matrix = Matrix.transform2DRotate(matrix,currentAngle);
	matrix = Matrix.transform2DScale(matrix,currentScale);
	
	var bRed = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y, compareScale,sigma,compareWidth,compareHeight, imageBRed,imageBWidth,imageBHeight, matrix);
	var bGrn = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y, compareScale,sigma,compareWidth,compareHeight, imageBGrn,imageBWidth,imageBHeight, matrix);
	var bBlu = ImageMat.extractRectFromFloatImage(pointB.x,pointB.y, compareScale,sigma,compareWidth,compareHeight, imageBBlu,imageBWidth,imageBHeight, matrix);
	
	// SCORE
	score = Dense.sad(aRed,aGrn,aBlu,bRed,bGrn,bBlu, mask);
	//score = 1.0/score;
	//score *= 1E10;
	//console.log(".  GOT: "+currentScale+","+Code.degrees(currentAngle)+"   ==== "+score);

	//var score = Dense.sad(aRed,aGrn,aBlu,bRed,bGrn,bBlu, mask);
	//return score;
// console.log(yMatrix+"");
// console.log(eMatrix+"");
	/*
	if(yMatrix){ // scale & rotation
		//yMatrix.set(0,0, 1.0);
		//yMatrix.set(0,0, 0.0);
		//yMatrix.set(0,0, score);
		yMatrix.set(0,0, score);
	}
	if(eMatrix){ // error
		eMatrix.set(0,0, score);
	}
	*/
	if(yMatrix){ // scale & rotation
		for(var i=0; i<length; ++i){
			var d = (bRed[i] + bGrn[i] + bBlu[i])/3.0;
			yMatrix.set(i,0, d);
			//yMatrix.set(i,0, 1.0);
		}
	}
	if(eMatrix){ // error
		for(var i=0; i<length; ++i){
			var d = Math.pow(aRed[i]-bRed[i],2) + Math.pow(aGrn[i]-bGrn[i],2) + Math.pow(aBlu[i]-bBlu[i],2);
			eMatrix.set(i,0, d);
		}
	}
	//console.log(i+"/"+length);
	
	//console.log("B");
//throw "?"
	// 	if(yMatrix){
	// 	yMatrix.set(i*4+0,0, frB.x);
	// 	yMatrix.set(i*4+1,0, frB.y);
	// 	yMatrix.set(i*4+2,0, toB.x);
	// 	yMatrix.set(i*4+3,0, toB.y);
	// }
	// if(eMatrix){
	// 	eMatrix.set(i*4+0,0, Math.pow(frB.x-fr.x,2) );
	// 	eMatrix.set(i*4+1,0, Math.pow(frB.y-fr.y,2) );
	// 	eMatrix.set(i*4+2,0, Math.pow(toB.x-to.x,2) );
	// 	eMatrix.set(i*4+3,0, Math.pow(toB.y-to.y,2) );
	// }
}
Dense.VVV = 0;
Dense.vertexFromMatch = function(pointA,pointB, lattice){
	var imageA = lattice.imageFrom();
	var imageB = lattice.imageTo();
	var cellSize = lattice.cellSize();
	var bestA = Dense.bestTransformationFromPoints(imageA,pointA, imageB,pointB, cellSize);
	var bestB = Dense.bestTransformationFromPoints(imageB,pointB, imageA,pointA, cellSize, true);
	// 1.0, 2.0, 4.0, ... ?
//console.log("GOT SCORES: "+bestA.score+" | "+bestB.score);
	// TODO: seed points must pass more stringent tests to throw out more probable bad seeds
	//: look at seed at multiple scales [cell size] ...

	var relativeAngleAtoB, relativeScaleAtoB, relativeAsymmScaleAtoB, relativeAsymmAngleAtoB, score;
	if(bestA.score<bestB.score){
		optimum = bestA;
		relativeAngleAtoB = optimum["angle"];
		relativeScaleAtoB = optimum["scale"];
		relativeAsymmScaleAtoB = optimum["asymmScale"];
		relativeAsymmAngleAtoB = optimum["asymmAngle"];
	}else{
		optimum = bestB; // & inverse
		relativeAngleAtoB = -optimum["angle"];
		relativeScaleAtoB = 1.0/optimum["scale"];
		relativeAsymmScaleAtoB = 1.0/optimum["asymmScale"];
		relativeAsymmAngleAtoB = optimum["asymmAngle"];
	}
	
	// check to see how good the point is
	// cellSize
	var seedScore = Dense.seedScaleCheck(pointA,pointB, imageA,imageB, 11, relativeScaleAtoB,relativeAngleAtoB,relativeAsymmScaleAtoB,relativeAsymmAngleAtoB);
	var seedRangeSAD = seedScore["rangeSAD"];
	var seedMaxSAD = seedScore["maxSAD"];
	var seedRangeNCC = seedScore["rangeNCC"];
	var seedMaxNCC = seedScore["maxNCC"];
	//console.log("seedScore:"+seedRange+" | "+seedMax);
	//if(seedRange>0.5 || seedMax>0.75){ // generated points // ncc
	//if(seedRange>0.05 || seedMax>0.10){ // manual points.  // ssd
	//if(seedRangeSAD>0.15 || seedMaxSAD>0.25){ // manual points
	//if(seedRangeSAD>0.15 || seedMaxSAD>0.25  ||  seedRangeNCC>0.15 || seedMaxNCC>0.20){ // manual
	if(seedRangeSAD>0.10 || seedMaxSAD>0.15  ||  seedRangeNCC>0.10 || seedMaxNCC>0.15){ // auto
	//if(false){
		//console.log("unstable point");
		return null;
	}
	console.log("seedScore:"+seedRangeSAD+" | "+seedMaxSAD+"  -   "+seedRangeNCC+" | "+seedMaxNCC);



/*
var sizSize = 25;
// A

var matrix = new Matrix(3,3).identity();
var needle = imageA.extractRectFromFloatImage(pointA.x,pointA.y,1.0,null,sizSize,sizSize, matrix);
var img = GLOBALSTAGE.getFloatRGBAsImage(needle.red(),needle.grn(),needle.blu(), needle.width(),needle.height());
var d = new DOImage(img);
d.matrix().translate(-needle.width()*0.5,-needle.height()*0.5);
d.matrix().scale(1.0);
d.matrix().translate(10 + Dense.VVV*50, 10 + sizSize*0);
GLOBALSTAGE.addChild(d);
// FROM B TO A
var matrix = new Matrix(3,3).identity();

	matrix = Matrix.transform2DRotate(matrix,-relativeAngleAtoB);
	matrix = Matrix.transform2DScale(matrix,1.0/relativeScaleAtoB);

					matrix = Matrix.transform2DRotate(matrix,-relativeAsymmAngleAtoB);
					matrix = Matrix.transform2DScale(matrix,1.0/relativeAsymmScaleAtoB,1.0);
					matrix = Matrix.transform2DRotate(matrix,relativeAsymmAngleAtoB);


var needle = imageB.extractRectFromFloatImage(pointB.x,pointB.y,1.0,null,sizSize,sizSize, matrix);
var img = GLOBALSTAGE.getFloatRGBAsImage(needle.red(),needle.grn(),needle.blu(), needle.width(),needle.height());
var d = new DOImage(img);
d.matrix().translate(-needle.width()*0.5,-needle.height()*0.5);
d.matrix().scale(1.0);
d.matrix().translate(10 + Dense.VVV*50, 10 + sizSize*1);
GLOBALSTAGE.addChild(d);

// B
var matrix = new Matrix(3,3).identity();
var needle = imageB.extractRectFromFloatImage(pointB.x,pointB.y,1.0,null,sizSize,sizSize, matrix);
var img = GLOBALSTAGE.getFloatRGBAsImage(needle.red(),needle.grn(),needle.blu(), needle.width(),needle.height());
var d = new DOImage(img);
d.matrix().translate(-needle.width()*0.5,-needle.height()*0.5);
d.matrix().scale(1.0);
d.matrix().translate(10 + Dense.VVV*50, 10 + sizSize*2);
GLOBALSTAGE.addChild(d);
// FROM A TO B
var sizSize = 25;
var matrix = new Matrix(3,3).identity();

	matrix = Matrix.transform2DRotate(matrix,relativeAngleAtoB);
	matrix = Matrix.transform2DScale(matrix,relativeScaleAtoB);

					matrix = Matrix.transform2DRotate(matrix,-relativeAsymmAngleAtoB);
					matrix = Matrix.transform2DScale(matrix,relativeAsymmScaleAtoB,1.0);
					matrix = Matrix.transform2DRotate(matrix,relativeAsymmAngleAtoB);


var needle = imageA.extractRectFromFloatImage(pointA.x,pointA.y,1.0,null,sizSize,sizSize, matrix);
var img = GLOBALSTAGE.getFloatRGBAsImage(needle.red(),needle.grn(),needle.blu(), needle.width(),needle.height());
var d = new DOImage(img);
d.matrix().translate(-needle.width()*0.5,-needle.height()*0.5);
d.matrix().scale(1.0);
d.matrix().translate(10 + Dense.VVV*50, 10 + sizSize*3);
GLOBALSTAGE.addChild(d);

// SCORE
d = new DOText(optimum.score.toExponential(3)+"", 10, DOText.FONT_ARIAL, 0xFF000000, DOText.ALIGN_CENTER);
d.matrix().translate(10 + Dense.VVV*50, 10 + sizSize*4 );
Dense.DISPLAY.addChild(d);

++Dense.VVV;
*/



	// use closest cell to approximate seed location
	var vertex = lattice.closestVertex(pointA);
	//vertex.from(pointA);
	vertex.from(vertex.pointCenter());
	vertex.to(pointB); // neighborhood
	vertex.scale(relativeScaleAtoB);
	vertex.angle(relativeAngleAtoB);
			var cells = [vertex];
			var interpolator = new Dense.Interpolator(cells);
	Dense.assignBestNeedleInHaystack(interpolator,vertex,null);
	//console.log(pointA+"  vertexFromMatch - closest: "+vertex+"  ");
	return vertex;
}
Dense.seedScaleCheck = function(pointA,pointB, imageA,imageB, compareSize, relativeScaleAtoB,relativeAngleAtoB,relativeAsymmScaleAtoB,relativeAsymmAngleAtoB){
	var scales = Code.lineSpace(-2,2,0.5);
	var i, j, k, a, b;
	var angleA, angleB;
	var matrix = new Matrix(3,3).identity();
	var mask = ImageMat.circleMask(compareSize,compareSize);
	var minScoreSAD = null;
	var maxScoreSAD = null;
	var minScoreNCC = null;
	var maxScoreNCC = null;
	for(i=0; i<scales.length; ++i){
		var scale = scales[i];
		scale = Math.pow(2,scale);
		matrix.identity();
		matrix = Matrix.transform2DScale(matrix,relativeScaleAtoB);
		matrix = Matrix.transform2DRotate(matrix,relativeAngleAtoB);
		matrix = Matrix.transform2DScale(matrix,scale);
		a = imageA.extractRectFromFloatImage(pointA.x,pointA.y,1.0,null,compareSize,compareSize, matrix);
		matrix.identity();
		matrix = Matrix.transform2DScale(matrix,scale);
		b = imageA.extractRectFromFloatImage(pointB.x,pointB.y,1.0,null,compareSize,compareSize, matrix);
		// orientation
		angleA = a.calculateMoment();
		angleB = b.calculateMoment();
		//console.log(i+": "+angleA+"");
		var sad = Dense.sad(a.red(),a.grn(),a.blu(), b.red(),b.grn(),b.blu(), mask);
		var ncc = Dense.sad(a.red(),a.grn(),a.blu(), b.red(),b.grn(),b.blu(), mask);
		// SAD
		if(minScoreSAD==null || minScoreSAD>sad){
			minScoreSAD = sad;
		}
		if(maxScoreSAD==null || maxScoreSAD<sad){
			maxScoreSAD = sad;
		}
		// NCC
		if(minScoreNCC==null || minScoreNCC>ncc){
			minScoreNCC = ncc;
		}
		if(maxScoreNCC==null || maxScoreNCC<ncc){
			maxScoreNCC = ncc;
		}
	}
	var scoreRangeSAD = maxScoreSAD-minScoreSAD;
	var scoreRangeNCC = maxScoreNCC-minScoreNCC;
	return {"rangeSAD":scoreRangeSAD,"maxSAD":maxScoreSAD,"minSAD":minScoreSAD, "rangeNCC":scoreRangeNCC,"maxNCC":maxScoreNCC,"minNCC":minScoreNCC};
}
Dense.lineFromF = function(FA,pointA){
	var matrixFfwd = FA;
	pointA = new V3D(pointA.x,pointA.y,1.0);
	var lineA = new V3D();
	matrixFfwd.multV3DtoV3D(lineA, pointA);
	var dir = new V2D();
	var org = new V2D();
	Code.lineOriginAndDirection2DFromEquation(org,dir, lineA.x,lineA.y,lineA.z);
	return {"org":org,"dir":dir};
}
Dense.ITER = 0;
Dense.assignBestNeedleInHaystack = function(interpolator, vertex, globalQueue, checkOnly){
// Dense.ITER = 0;
// GLOBALSTAGE.root().removeAllChildren();	
//GLOBALSTAGE.root().matrix().identity().scale(4.0);
// EHRE
	var i, j, k, sigma, matrix, angle, scale, toScale, toPoint, toAngle, fromPoint;
	//console.log(vertex);
	var lattice = vertex.lattice();
	var imageFr = lattice.imageFrom();
	var imageTo = lattice.imageTo();
	var cellSize = lattice.cellSize();
	//var fromPoint = vertex.from();
		//if(!useFrom){ fromPoint = vertex.pointCenter(); }
	//var fromPoint = vertex.pointCenter(); // always center 
	//var halfCellSize = 2.0*cellSize;
	var halfCellSize = 0.5*cellSize;
	var TL = vertex.pointTL().add(-halfCellSize,-halfCellSize);
	var TR = vertex.pointTR().add(halfCellSize,-halfCellSize);
	var BL = vertex.pointBL().add(-halfCellSize,halfCellSize);
	var BR = vertex.pointBR().add(halfCellSize,halfCellSize);
	var CE = vertex.pointCenter(); // TODO: this should be the best point in the image .. or does it need to be?
	var TLto = interpolator.projected(TL)["point"];
	var TRto = interpolator.projected(TR)["point"];
	var BLto = interpolator.projected(BL)["point"];
	var BRto = interpolator.projected(BR)["point"];
	var center = interpolator.projected(CE);
	toAngle = center["angle"];
	toScale = center["scale"];
	toPoint = center["point"];

	//console.log(" ::: FROM: "+CE+" =to=> "+toPoint);
	//  <170.5,104.5> =to=> <212,46>
	// FROM: <159.5,93.5> =to=> <197.08990411189728,29.823194363299592>

	var currentTransform = vertex.transform();
	/*
	if(checkOnly){
		if(currentTransform && currentTransform.to()!==null){
			var diffAngle = Math.abs(toAngle-currentTransform.angle());
			var diffPoint = V2D.distance(toPoint,currentTransform.to());
			var diffScale = (toScale/currentTransform.scale());
				if(diffScale<1.0){
					diffScale = 1.0/diffScale;
				}
			// console.log(diffAngle+" | "+diffPoint+" | "+diffScale); // 0.08454846289525905 | 3.067630993640056 | 1.1015456071164045
			var maxAngle = Code.radians(10.0);
			var maxPoint = 1.0;
			var maxScale = 1.1;
			if(diffAngle<maxAngle || diffPoint<maxPoint || diffScale<maxScale){
			//if( toAngle===currentTransform.angle() && V2D.equal(toPoint,currentTransform.to()) && toScale===currentTransform.scale() ){
				//console.log("alreadyDone");
				return false; // already done
			}
		}
		return true;
	}
	*/
	var fromPoint = CE;
	var boundingBox = new Rect().fromArray([TLto,TRto,BLto,BRto]);

	var compareSizeMax = 11;
	var neighborhoodScale = 0.5; // 0.75 ~ 0.5 ~ 5x5, 0.25 ~ 3x3.  // SHOULD EXPAND BASED ON DISTINCTIVENESS OF AREA
	//var neighborhoodScale = 0.75; // 7x7 ?
	//var neighborhoodScale = 0.25; // smaller neighborhoods need larger window
	var compareSizeNatural = Math.ceil(cellSize/neighborhoodScale);
	var compareSize = Math.min(compareSizeNatural,compareSizeMax);
	var cellScale = (cellSize/neighborhoodScale/compareSize);
//console.log(".     compareSize: "+compareSize+" cellScale: "+cellScale+" ------------");

	var needlePoint = fromPoint;
	var needleWidth = compareSize;
	var needleHeight = needleWidth;
	var needleMask = ImageMat.circleMask(needleWidth,needleHeight);
	// find bounding box for haystack, minimum size of cellSize if necessary
	
	// var haystackPoint = boundingBox.center();
	// var haystackWidth = Math.max(Math.ceil(boundingBox.width()), needleWidth);
	// var haystackHeight = Math.max(Math.ceil(boundingBox.height()), needleHeight);
var haystackPoint = toPoint.copy();
haystackPoint.add(2,2);
var haystackWidth = 2*compareSize;
var haystackHeight = haystackWidth;
	matrix = new Matrix(3,3).identity();
	sigma = null;
	var haystack = imageTo.extractRectFromFloatImage(haystackPoint.x,haystackPoint.y,cellScale,sigma,haystackWidth,haystackHeight, matrix);
	// create mask of allowed pixels based on model
	
	/*
	var haystackMask = Code.newArrayOnes(haystackWidth*haystackHeight);
	var localTL = V2D.sub(TLto,haystackPoint);
	var localTR = V2D.sub(TRto,haystackPoint);
	var localBL = V2D.sub(BLto,haystackPoint);
	var localBR = V2D.sub(BRto,haystackPoint);
	for(j=0; j<haystackHeight; ++j){
		for(i=0; i<haystackWidth; ++i){
			var index = j*haystackWidth + i;
			var loc = new V2D(i - haystackWidth*0.5,j - haystackHeight*0.5); // TODO: may be off by ~ pixel about where ?
			//haystackMask[index] = 1.0;
			//loc.scale(cellScale);
			loc.scale(1.0/cellScale);
			//loc = matrix.multV3DtoV3D(loc,loc);
			var isInside = Code.isPointInsidePolygon2D(loc, [localTL,localTR,localBR,localBL]);
			//console.log(loc+"  ==  "+isInside);
			if(isInside){
				haystackMask[index] = 1.0;
			}else{
				haystackMask[index] = 0.0;
			}
		}
	}
	haystackMask = ImageMat.expandBlob(haystackMask, haystackWidth,haystackHeight);
	var offX = Math.floor(needleWidth*0.5);
	var offY = Math.floor(needleHeight*0.5);
	var subWid = haystackWidth - needleWidth + 1;
	var subHei = haystackHeight - needleHeight + 1;
	var haystackMaskSub = ImageMat.subImage(haystackMask,haystackWidth,haystackHeight, offX,offY,subWid,subHei);
	*/
	// extract needle at relative scales / rotations
	var angleRangeDeg = [-10, 0, 10];
	var scaleRangeExp = [-0.1,0.0,0.1];
	var bestScore = null;
	var bestPoint, bestAngle, bestScale, bestNeedle;
	var best = {};

// // HAYSTACK
// var img = GLOBALSTAGE.getFloatRGBAsImage(haystack.red(),haystack.grn(),haystack.blu(), haystack.width(),haystack.height());
// var d = new DOImage(img);
// d.matrix().translate(-haystack.width()*0.5, -haystack.height()*0.5);
// d.matrix().translate(10 + Dense.ITER*100, 100);
// GLOBALSTAGE.addChild(d);
// // HAYSTACK MASK
// var img = GLOBALSTAGE.getFloatRGBAsImage(haystackMask,haystackMask,haystackMask, haystackWidth, haystackHeight);
// var d = new DOImage(img);
// d.graphics().alpha(0.5);
// d.matrix().translate(-haystack.width()*0.5, -haystack.height()*0.5);
// d.matrix().translate(10 + Dense.ITER*100, 100);
// GLOBALSTAGE.addChild(d);
var bestIndex = 0;
	for(i=0; i<scaleRangeExp.length; ++i){
		scale = toScale * Math.pow(2,scaleRangeExp[i]);
		for(j=0; j<angleRangeDeg.length; ++j){
			angle = toAngle + Code.radians(angleRangeDeg[j]);
			matrix = new Matrix(3,3).identity();
				matrix = Matrix.transform2DScale(matrix,scale);
				matrix = Matrix.transform2DRotate(matrix,angle);
			var needle = imageFr.extractRectFromFloatImage(needlePoint.x,needlePoint.y,cellScale,sigma,needleWidth,needleHeight, matrix);
			
			var scores = Dense.searchNeedleHaystackImage(needle,needleMask, haystack);
				var values = scores.value;
				var valueWidth = scores.width;
				var valueHeight = scores.height;

			for(k=0; k<values.length; ++k){
				var zLoc = values[k];
				//var mask = haystackMaskSub[k];
				var mask = 1.0;
				if(mask>0){
					var index = k;
					var xLoc = index % valueWidth;
					var yLoc = Math.floor(index/valueWidth);// | 0;
					var peak = new V3D(xLoc,yLoc,zLoc);
					if(bestScore===null || peak.z < bestScore){
bestIndex = peak.copy();
						bestScore = peak.z;
						bestScale = scale;
						bestAngle = angle;
						//var s = 1.0/cellScale;
						//bestPoint = new V2D(haystackPoint.x - (valueWidth-1)*0.5 + peak.x, haystackPoint.y - (valueHeight-1)*0.5 + peak.y);
						//bestPoint = new V2D(haystackPoint.x + peak.x, haystackPoint.y + peak.y);
						//bestPoint = haystackPoint.copy().add( new V2D(peak.x/cellScale-(valueWidth-1)*0.5/cellScale, peak.y/cellScale-(valueHeight-1)*0.5/cellScale) );
						//bestPoint = haystackPoint.copy().add( new V2D(peak.x-(valueWidth-1)*0.5, peak.y-(valueHeight-1)*0.5).scale(1.0/cellScale) );
						//bestPoint = haystackPoint.copy().add( new V2D(peak.x-(valueWidth)*0.5, peak.y-(valueHeight)*0.5).scale(1.0/cellScale) );
						// bestPoint.x -= compareSize*0.5;///cellScale;
						// bestPoint.y -= compareSize*0.5;///cellScale;
// TODO: IS THIS OFF BY HALF PIXEL ANYWHERE ?
						// var local = new V2D(peak.x-(valueWidth-1)*0.5, peak.y-(valueHeight-1)*0.5);
						// bestPoint = haystackPoint.copy().add( local.scale(cellScale) );
						bestPoint = new V2D(haystackPoint.x - (valueWidth*0.5)*cellScale + peak.x*cellScale, haystackPoint.y - (valueHeight*0.5)*cellScale + peak.y*cellScale);
						bestNeedle = needle;
					}
				}
			}
		}
	}
//bestPoint = haystackPoint;




// propageted values:
// var values = [];
// for(k=0; k<valuesList.length; ++k){
// 	Code.arrayPushArray(values,valuesList[k]);
// }
// var uniquenessTotal = Dense.uniquenessFromValues(values);
//var uniquenessNH = Dense.uniquenessFromValues(values);

	//console.log("best 1: "+bestPoint+" "+valueWidth+"x"+valueHeight);
	if(bestScore){
		var dist = V2D.distance(haystackPoint, bestPoint);
		var distanceToFrom = dist;
		//console.log("distance from haystack: "+dist+"");
		/*
		// BAD
		var limScale = 0.9;
		var limAngle = Code.radians(10);
		var result = Dense.gdOptimumScaleRotation(needlePoint,bestPoint, imageFr,imageTo, needleWidth,needleHeight,cellScale,needleMask,null,null,null,
		bestScale*limScale, bestScale/limScale, bestAngle-limAngle,bestAngle+limAngle);
		bestScale = result["scale"];
		bestAngle = result["rotation"];
		*/

//var entropyNeedle = Code.entropy01(needle, needleMask); // buckets



//console.log("cellScale cellScale cellScale cellScale: "+cellScale)


		// keep best score
		// calculate uniqueness : extract a haystack at best score credentials, window ~3-4 size of haystack
			matrix = new Matrix(3,3).identity();
			matrix = Matrix.transform2DScale(matrix,bestScale);
			matrix = Matrix.transform2DRotate(matrix,bestAngle);
		var needle = imageFr.extractRectFromFloatImage(needlePoint.x,needlePoint.y,cellScale,sigma,needleWidth,needleHeight, matrix);
		// var needle = bestNeedle;
		var uniquenessWindow = 4;
		var neighborhoodWidth = Math.round(compareSize * uniquenessWindow);
		var neighborhoodHeight = Math.round(compareSize * uniquenessWindow);

// neighborhoodWidth = haystackWidth;
// neighborhoodHeight = haystackHeight;
//var haystack = imageTo.extractRectFromFloatImage(haystackPoint.x,haystackPoint.y,cellScale,sigma,haystackWidth,haystackHeight, matrix);
			matrix = new Matrix(3,3).identity();
		var haystack = imageTo.extractRectFromFloatImage(bestPoint.x,bestPoint.y,cellScale,sigma,neighborhoodWidth,neighborhoodHeight, matrix);
		//var haystack = imageTo.extractRectFromFloatImage(haystackPoint.x,haystackPoint.y,cellScale,sigma,neighborhoodWidth,neighborhoodHeight, matrix);
		var scores = Dense.searchNeedleHaystackImage(needle,needleMask, haystack);
			var values = scores.value;
			var valueWidth = scores.width;
			var valueHeight = scores.height;
		var uniquenessNH = Dense.uniquenessFromValues(values);


/*
if(Dense.ITER==2){ // 2 | 5
//console.log(Dense.ITER+" = Dense.ITER");



// HAYSTACK
var img = GLOBALSTAGE.getFloatRGBAsImage(haystack.red(),haystack.grn(),haystack.blu(), neighborhoodWidth,neighborhoodHeight);
var d = new DOImage(img);
d.matrix().translate(-neighborhoodWidth*0.5, -neighborhoodHeight*0.5);
d.matrix().scale(cellScale);
d.matrix().translate(400 + bestPoint.x,bestPoint.y);
//d.matrix().translate(50 + Dense.ITER*80, 50);
GLOBALSTAGE.addChild(d);

// HEAT MAP
var heat = ImageMat.normalFloat01(Code.copyArray(values));
heat = ImageMat.invertFloat01(heat);
heat = ImageMat.pow(heat,2);
heat = Code.grayscaleFloatToHeatMapFloat(heat);
//console.log("valueWidth,valueHeight: "+valueWidth+"x"+valueHeight);
var img = GLOBALSTAGE.getFloatRGBAsImage(heat["red"],heat["grn"],heat["blu"], valueWidth,valueHeight);
var d = new DOImage(img);
//d.graphics().alpha(0.3);
d.matrix().translate(-valueWidth*0.5,-valueHeight*0.5);
d.matrix().scale(cellScale);
d.matrix().translate(400 + bestPoint.x,bestPoint.y);
//d.matrix().translate(50 + Dense.ITER*80, 50);
GLOBALSTAGE.addChild(d);

// BEST POINT
var d = new DO();
d.graphics().clear();
d.graphics().setLine(1.0, 0xFFFF0000);
d.graphics().beginPath();
d.graphics().drawCircle(0,0, 4.0);
d.graphics().strokeLine();
d.graphics().endPath();
console.log("bestPoint: "+bestPoint);
console.log("haystackPoint: "+haystackPoint);
console.log(" => : "+(bestPoint.x-haystackPoint.x)+","+(bestPoint.y-haystackPoint.y));
//d.matrix().translate(bestPoint.x-haystackPoint.x, bestPoint.y-haystackPoint.y);
//d.matrix().translate( (bestPoint.x-haystackPoint.x)*cellScale, (bestPoint.y-haystackPoint.y)*cellScale);
//d.matrix().translate(-valueWidth*0.5,-valueHeight*0.5);
//d.matrix().translate(-neighborhoodWidth*0.5, -neighborhoodHeight*0.5);
//d.matrix().translate(50 + Dense.ITER*80, 50);
d.matrix().translate(400 + bestPoint.x,bestPoint.y);
GLOBALSTAGE.addChild(d);


//CHECK:
var d = new DO();
d.graphics().clear();
d.graphics().setLine(1.0, 0xFF0000CC);
d.graphics().beginPath();
d.graphics().drawCircle(0,0, 3.0);
d.graphics().strokeLine();
d.graphics().endPath();
console.log("bestIndex: "+bestIndex);
//d.matrix().translate(400 + bestPoint.x - valueWidth*0.5*cellScale + bestIndex.x*cellScale,bestPoint.y - valueHeight*0.5*cellScale + bestIndex.y*cellScale);
//d.matrix().translate(400 + haystackPoint.x - valueWidth*0.5*cellScale + bestIndex.x*cellScale,bestPoint.y - valueHeight*0.5*cellScale + bestIndex.y*cellScale);
//d.matrix().translate(400 + bestPoint.x - (valueWidth-1)*0.5*cellScale,bestPoint.y - (valueHeight-1)*0.5*cellScale); // to top left corner
d.matrix().translate(400 + bestPoint.x - (valueWidth*0.5)*cellScale,bestPoint.y - (valueHeight*0.5)*cellScale); // to top left corner // Math.floor
//d.matrix().translate((valueWidth-0.5)*cellScale, (valueHeight-0.0)*cellScale); // to bottom right
d.matrix().translate(bestIndex.x*cellScale, bestIndex.y*cellScale); // to point
//GLOBALSTAGE.addChild(d);



// NEEDLE
var img = GLOBALSTAGE.getFloatRGBAsImage(needle.red(),needle.grn(),needle.blu(), needleWidth,needleHeight);
var d = new DOImage(img);
d.matrix().translate(-needleWidth*0.5,-needleHeight*0.5);
d.matrix().scale(cellScale);
d.matrix().translate(400 + bestPoint.x, bestPoint.y);
d.matrix().translate(0, 90);
//d.matrix().translate(50 + Dense.ITER*80, 10);
GLOBALSTAGE.addChild(d);




// // HAYSTACK MASK
// var img = GLOBALSTAGE.getFloatRGBAsImage(haystackMask,haystackMask,haystackMask, haystackWidth, haystackHeight);
// var d = new DOImage(img);
// d.graphics().alpha(0.75);
// d.matrix().translate(-haystack.width()*0.5, -haystack.height()*0.5);
// d.matrix().translate(offX,offY);
// d.matrix().translate(50 + Dense.ITER*80, 50);
// GLOBALSTAGE.addChild(d);

d = new DOText("s: "+bestScore.toExponential(3)+"", 8, DOText.FONT_ARIAL, 0xFF000000, DOText.ALIGN_LEFT);
d.matrix().translate(50 + Dense.ITER*80, 80);
GLOBALSTAGE.addChild(d);

// d = new DOText("uNH: "+uniquenessNH.toExponential(3)+"", 8, DOText.FONT_ARIAL, 0xFF000000, DOText.ALIGN_LEFT);
// d.matrix().translate(50 + Dense.ITER*80, 90);
// GLOBALSTAGE.addChild(d);

// d = new DOText("uHN: "+uniquenessHN.toExponential(3)+"", 8, DOText.FONT_ARIAL, 0xFF000000, DOText.ALIGN_LEFT);
// d.matrix().translate(50 + Dense.ITER*80, 100);
// GLOBALSTAGE.addChild(d);

}
*/




	
		// Code.entropy01 = function(data, masking, buckets){

		//var infoNeedle = Code.infoArray(needle.gry(), needleMask);
		//var rangeNeedle = infoNeedle["range"];
			var rangeNeedleR = ImageMat.range(needle.red());
			var rangeNeedleG = ImageMat.range(needle.grn());
			var rangeNeedleB = ImageMat.range(needle.blu());
			var rangeNeedle = (rangeNeedleR+rangeNeedleG+rangeNeedleB)/3.0;

			var roughnessNeedle = 0;//needle.roughness();
		
var gradientNeedle = ImageMat.gradientMagnitude(needle.gry(), needle.width(),needle.height());
	gradientNeedle = ImageMat.absFloat(gradientNeedle);
	gradientNeedle = ImageMat.sumFloat(gradientNeedle);
		

		// distance from F-line ?
		var Ffwd = lattice.F();
		var Frev = lattice.Finv();
		var lineFDistanceError = 0;
		if(Ffwd){
			var needleLine = Dense.lineFromF(Ffwd,needlePoint);
			var haystackLine = Dense.lineFromF(Frev,bestPoint);
			var distA = Code.distancePointRay2D(needleLine.org,needleLine.dir, bestPoint);
			var distB = Code.distancePointRay2D(haystackLine.org,haystackLine.dir, needlePoint);
			var distRMS = Math.sqrt(distA*distA + distB*distB); // RMS ERROR
			lineFDistanceError = distRMS;
		}
				


		// change in local orientation ?

		// change in local scale ?

		// only choose points in direction of original neighbor


/*
var values2 = Code.copyArray(values).sort( function(a,b){ return a<b ? -1 : 1; } );
// use differentials to get a peakness value
var sigma = 1.0;
var filter = ImageMat.gaussianWindow1DFromSigma(sigma);
var averaged = Code.convolve1D(values2,filter);
values2 = averaged;

var str = "\n\ny = [";
for(var i=0; i<values2.length; ++i){
	str = str + values2[i].toExponential(3) + ",";
}
str = str + "];\n";
str = str + "plot(y,'r-x');\n\n";
console.log(str);
*/

		// get uniqueness of matchee point
		// var needle = imageTo.extractRectFromFloatImage(bestPoint.x,bestPoint.y,compareScale,sigma,cellSize,cellSize, matrix);
		// var scores = Dense.searchNeedleHaystackImage(needle,needleMask, haystack);
		// 	var values = scores.value;
		// 	var valueWidth = scores.width;
		// 	var valueHeight = scores.height;
		// var uniquenessHH = Dense.uniquenessFromValues(values);
			matrix = new Matrix(3,3).identity();
			matrix = Matrix.transform2DScale(matrix,1.0/bestScale);
			matrix = Matrix.transform2DRotate(matrix,-bestAngle);
		var needle = imageTo.extractRectFromFloatImage(bestPoint.x,bestPoint.y,cellScale,sigma,needleWidth,needleHeight, matrix);
			matrix = new Matrix(3,3).identity();
		var haystack = imageFr.extractRectFromFloatImage(needlePoint.x,needlePoint.y,cellScale,sigma,neighborhoodWidth,neighborhoodHeight, matrix);
		var scores = Dense.searchNeedleHaystackImage(needle,needleMask, haystack);
			var values = scores.value;
			var valueWidth = scores.width;
			var valueHeight = scores.height;
		var uniquenessHN = Dense.uniquenessFromValues(values);


		//var infoHaystackNeedle = Code.infoArray(needle.gry(), needleMask);
		//var rangeHaystackNeedle = infoHaystackNeedle["range"];
			var rangeHaystackNeedleR = ImageMat.range(needle.red());
			var rangeHaystackNeedleG = ImageMat.range(needle.grn());
			var rangeHaystackNeedleB = ImageMat.range(needle.blu());
			var rangeHaystackNeedle = (rangeHaystackNeedleR+rangeHaystackNeedleG+rangeHaystackNeedleB)/3.0;

			var roughnessHaystackNeedle = 0;//needle.roughness();

		var bestPoint2, bestScale2, bestAngle2, bestScore2 = null;
		var peaks = [];
		if(peaks.length==0){
			var info = Code.infoArray(values);
			var index = info["indexMin"];
			var xLoc = index % valueWidth;
			var yLoc = index/valueWidth | 0;
			var zLoc = info["min"];
			var peak = new V3D(xLoc,yLoc,zLoc);
			var peaks = [peak];
		}
		for(k=0; k<peaks.length; ++k){
			var peak = peaks[k];
			if(bestScore2===null || peak.z < bestScore2){
				bestScore2 = peak.z;
				bestScale2 = scale;
				bestAngle2 = angle;
				bestPoint2 = new V2D(needlePoint.x - (valueWidth-1)*0.5 + peak.x, needlePoint.y - (valueHeight-1)*0.5 + peak.y);
			}
			break; // only first
		}
		//console.log(bestPoint2+"")
		var dist = V2D.distance(needlePoint, bestPoint2);
		var distanceFromTo = dist;

		var uniqueness = Math.max(uniquenessNH,uniquenessHN);

		var worstRangeScore = Math.min(rangeNeedle, rangeHaystackNeedle);
		worstRangeScore = Math.max(worstRangeScore,1E-10);
		var reliability = (0.0); // min(s(a),s(b)) / d(a,b)

		
/*

		// PENALTY FOR MATCH DISTANCE BASED ON 
		// PENALTY MATCH DISTANCE
		//uniqueness = uniqueness * (1+distanceFromTo);
		uniqueness = uniqueness * (1+distanceFromTo*distanceFromTo);
			//uniqueness = uniqueness * (1+Math.sqrt(distanceFromTo));
		// PENALTY F DISTANCE
		//uniqueness = uniqueness * (1+lineFDistanceError);
			uniqueness = uniqueness * (1+Math.pow(lineFDistanceError,0.5));
		// PENALTY NON-TEXTURENESS
		
		//worstRangeScore = Math.pow(1.0/worstRangeScore,0.25);  // 0.1 to 1.0  //uniqueness = uniqueness * (1 + 1.0/rangeNeedle); //uniqueness = uniqueness * (1 + (1.0-rangeNeedle));
		worstRangeScore = Math.pow(1.0/worstRangeScore,0.1);
		//worstRangeScore = Math.pow(1.0/worstRangeScore,0.25);
		uniqueness = uniqueness * worstRangeScore;

		//uniqueness = uniqueness * (1.0+bestScore);

		//uniqueness = bestScore * worstRangeScore * distanceFromTo * lineFDistanceError;
		
		// PENALTY: brightness difference -- median color ?
		// ...
		// PENALTY: range difference
		// ...
		// PENALTY: NEIGHBOR DIFFERENCE ?
		// ...
		//console.log("lineFDistanceError: "+lineFDistanceError)
		//

		// TODO: if range is too low: do nothing
		var rank = uniqueness
*/

		// ignore points that have minimal differences

		if(worstRangeScore < 0.01){
			return vertex;
		}

		// ignore points outside image window
		if(bestPoint.x<0 || bestPoint.y<0 || bestPoint.x>imageTo.width()-1 || bestPoint.y>imageTo.height()-1 ){
			//console.log("POINT OUTSIDE TO WINDOW");
			return vertex;
		}

		// ignore points with really poor scores
		if(bestScore > 0.25){
			return vertex;
		}

		// ignore points with poor uniqueness
		
		if(uniqueness > 50000){ // TODO: ONCE UNIQNESS METRIC IS DETERMINED > FIND THIS VALUE
			return vertex;
		}
		//console.log("uniqueness: "+uniqueness);
		
/*
		if(distanceFromTo>cellSize || distanceToFrom>cellSize){
			return vertex;
		}
*/
	// penalty type 2:
		var rank = 1.0;
		rank = rank * Math.pow(1.0+uniqueness,2.0);
		//rank = rank * Math.pow(1.0+uniquenessNH,2.0);
		//rank = rank * uniquenessTotal;
		//rank = rank * Math.pow(1.0+bestScore,1.0);
		rank = rank * Math.pow(1.0/worstRangeScore,1.0);
		//rank = rank * (Math.pow(1.0/worstRangeScore,0.1));
		//rank = rank * (1.0 + Math.pow(1.0 - worstRangeScore,1.0));
		// 	gradientNeedle = Math.max(gradientNeedle,1E-10);
		// rank = rank * Math.pow(1.0/gradientNeedle,2.0);
		//rank = rank * Math.pow(1.0+lineFDistanceError,1.0);
		rank = rank * Math.pow(1.0+distanceFromTo,2.0);
		rank = rank * Math.pow(1.0+distanceToFrom,2.0);
		//rank = rank * Math.pow(1.0/entropyNeedle,1.0);

		//console.log(rank);

		// if(rank>1E10){
		// 	return vertex;
		// }

		// TODO: NOT JUST NEIGHBORS -- ANY CELL AROUND POINT
		var v = vertex.lattice().vertex(bestPoint);
		var ns = v.neighbors();
		//console.log(ns.length);
		for(k=0; k<ns.length; ++k){
			var n = ns[k];
			if(n.isJoined()){
				var d = V2D.distance(n.to(),bestPoint);
				//console.log("DIST: "+d);
				if(d<cellSize*0.1){
					console.log("too close to neighbor: "+d);
					return vertex;
				}
			}
		}


		var currentRank = vertex.rank();//vertex.transform();
		if(currentRank!==null){
			if(rank > currentRank){
				return null; // not better, don't change
			}
		}
		if(globalQueue){
			// remove current entry if exists, and add new entry
			globalQueue.remove(vertex);
			
			// add best as single transform
			var transform = new Dense.Transform();
			transform.scale(bestScale);
			transform.angle(bestAngle);
			transform.to(bestPoint);
			transform.score(bestScore);
			transform.rank(rank); // transform.rank(bestScore);
			vertex.matches([transform]);
			//vertex.matches(queue.toArray());
			vertex.transform(0); // default to best location 

			// save new model points:
			// ??
			
			globalQueue.push(vertex);
		}
	}else{
		console.log("NO BEST SCORE? : "+vertex);
	}

++Dense.ITER;

	return vertex;
}

Dense.uniquenessMap = function(image){
	var red = image.red();
	var grn = image.grn();
	var blu = image.blu();
	var wid = image.width();
	var hei = image.height();
	var index = 0;
	var i, j, k;
	var siz = 11;
	var haySize = siz*3;
	var length = wid*hei;
	var map = Code.newArrayZeros(length);
	var needleMask = ImageMat.circleMask(siz);
	// for(j=siz; j<hei-siz; ++j){
	// 	for(i=siz; i<wid-siz; ++i){
	for(j=0; j<hei; ++j){
		for(i=0; i<wid; ++i){
			index = j*wid + i;
			var needle = image.extractRectFromFloatImage(i,j,1.0,null,siz,siz, null);
			var haystack = image.extractRectFromFloatImage(i,j,1.0,null,haySize,haySize, null);
			// var uniqueness = 0;
			var scores = Dense.searchNeedleHaystackImage(needle,needleMask, haystack);
			var values = scores.value;
			var valueWidth = scores.width;
			var valueHeight = scores.height;
			var uniqueness = Dense.uniquenessFromValues(values);
			map[index] = uniqueness;
		}
		console.log(j+"/"+hei);
	}
	return map;
}

Dense.assignBestNeedlesInHaystack = function(vertex,haystackPoint, baseScale,baseAngle, searchSize){
	baseScale = baseScale!==undefined ? baseScale : 1.0;
	baseAngle = baseAngle!==undefined ? baseAngle : 0.0;
	searchSize = searchSize!==undefined ? searchSize : 4.0;
	var MAX_MATCHES = 10;
	var F_AVG_ERROR = 5 * Math.sqrt(2);
	var needlePoint = vertex.from();
	var lattice = vertex.lattice();
	var sourceN = lattice.imageFrom();
	var sourceH = lattice.imageTo();
	var Ffwd = lattice.F();
	var Frev = lattice.Finv();
	var cellSize = Math.max(lattice.cellSize(), Dense.MINIMUM_CELL_SIZE);
	var imageN = lattice.imageFrom();
	var imageH = lattice.imageTo();
	var needleSize = cellSize;
	var needleWidth = needleSize;
	var needleHeight = needleSize;
	var needleSizeHalf = needleSize*0.5 | 0;
	var haystackWidth = Math.max(Math.round(needleSize * searchSize * baseScale), needleSize);
	var haystackHeight = haystackWidth;
	var needleMask = ImageMat.circleMask(needleSize);
	//var haystackPoint = vertex.to();

	var queue = new PriorityQueue(Dense.Vertex._queueSorting, MAX_MATCHES);

	var angleRangeDeg = [-10, 0, 10];
	var scaleRangeExp = [-0.1,0.0,0.1];
	var i, j, k, angle, scale;
	var matrix = null;

	// constant haystack:
	var sigma = null;
	matrix = new Matrix(3,3).identity();
	var haystack = sourceH.extractRectFromFloatImage(haystackPoint.x,haystackPoint.y,1.0,sigma,haystackWidth,haystackHeight, matrix);
	// variable needle
var bestScore = null;
var best = {};
	for(i=0; i<scaleRangeExp.length; ++i){
		scale = baseScale * Math.pow(2,scaleRangeExp[i]);
		for(j=0; j<angleRangeDeg.length; ++j){
			angle = baseAngle + Code.radians(angleRangeDeg[j]);
			matrix = new Matrix(3,3).identity();
				matrix = Matrix.transform2DScale(matrix,scale);
				matrix = Matrix.transform2DRotate(matrix,angle);
			var needle = sourceN.extractRectFromFloatImage(needlePoint.x,needlePoint.y,1.0,sigma,needleWidth,needleHeight, matrix);
			var scores = Dense.searchNeedleHaystackImage(needle,needleMask, haystack);
				var values = scores.value;
				var valueWidth = scores.width;
				var valueHeight = scores.height;
			//var uniqueness = Dense.uniquenessFromValues(values);

			// record best
			// var peaks = Code.findMinima2DFloat(values,valueWidth,valueHeight);
			var peaks = [];
			// peaks = peaks.sort(function(a,b){ return a.z<b.z ? -1 : 1 });
			if(peaks.length==0){
				var info = Code.infoArray(values);
				var index = info["indexMin"];
				var xLoc = index % valueWidth;
				var yLoc = index/valueWidth | 0;
				var zLoc = info["min"];
				var peak = new V3D(xLoc,yLoc,zLoc);
				var peaks = [peak];
			}
			for(k=0; k<peaks.length; ++k){
				var peak = peaks[k];
				if(bestScore===null || peak.z < bestScore){
					bestScore = peak.z;
					best["scale"] = scale;
					best["angle"] = angle;
					best["score"] = bestScore;
					best["uniqueness"] = Dense.uniquenessFromValues(values);
					best["location"] = new V2D(peak.x + haystackPoint.x - (valueWidth-1)*0.5, peak.y + haystackPoint.y - (valueHeight-1)*0.5);
				}
				break; // only first
			}
			// for(k=0; k<values.length; ++k){
			// 	var value = values[k];
			// 	var x = k%valueWidth;
			// 		x += haystackPoint.x - haystackWidth*0.5 + needleSizeHalf;
			// 	var y = k/valu geWidth | 0;
			// 		y += haystackPoint.y - haystackHeight*0.5 + needleSizeHalf;
			// 	var localPoint = new V2D(x,y);
			// 	// F
			// 	var lineDistanceError = 0;
			// 	if(Ffwd){
			// 		var needleLine = Dense.lineFromF(Ffwd,needlePoint);
			// 		var haystackLine = Dense.lineFromF(Frev,localPoint);
			// 		var distA = Code.distancePointRay2D(needleLine.org,needleLine.dir, localPoint);
			// 		var distB = Code.distancePointRay2D(haystackLine.org,haystackLine.dir, needlePoint);
			// 		var distRMS = Math.sqrt(distA*distA + distB*distB); // RMS ERROR
			// 		lineDistanceError = distRMS;
			// 	}
			// 	// transform
			// 	var transform = new Dense.Transform();
			// 	var fPenalty = (Math.abs(lineDistanceError - F_AVG_ERROR,0) + 1.0) * 0.0001;
			// 	transform.scale(scale);
			// 	transform.angle(angle);
			// 	transform.to( localPoint );
			// 	transform.score(value);
			// 	transform.rank(uniqueness * fPenalty);
			// 	queue.push(transform);
			// }
		}
	}
	//console.log(best["score"])
		var transform = new Dense.Transform();
		transform.scale(best["scale"]);
		transform.angle(best["angle"]);
		transform.to( best["location"] );
		transform.score(best["score"]);
		transform.rank(best["uniqueness"]);
		vertex.matches([transform]);
	//vertex.matches(queue.toArray());
	vertex.transform(0); // default to best location 
	return vertex;
}
Dense.Vertex._queueSorting = function(a,b){
	if(a===b){ return 0; }
	var rankA = a.rank();
	var rankB = b.rank();
	if(rankA==rankB){
		return a.score() < b.score() ? -1 : 1;
	}
	return rankA < rankB ? -1 : 1;
}

Dense.denseMatch = function(imageA,seedsA, imageB,seedsB, dense){
	var pointsA = seedsA;
	var pointsB = seedsB;
	// IMAGES
	var imageARed = imageA.red();
	var imageAGrn = imageA.grn();
	var imageABlu = imageA.blu();
	var imageAGry = imageA.gry();
	var imageAWidth = imageA.width();
	var imageAHeight = imageA.height();
	var imageBRed = imageB.red();
	var imageBGrn = imageB.grn();
	var imageBBlu = imageB.blu();
	var imageBGry = imageB.gry();
	var imageBWidth = imageB.width();
	var imageBHeight = imageB.height();

	// F
	var matrixFfwd = R3D.fundamentalMatrix(pointsA,pointsB);
	if(matrixFfwd){
		matrixFfwd = R3D.fundamentalMatrixNonlinear(matrixFfwd,pointsA,pointsB);
	}
	console.log(matrixFfwd+"");

	// CORNERS
	var sigmaCorners = 1.0;
	var cornersA = R3D.harrisCornerDetection(imageAGry, imageAWidth, imageAHeight, sigmaCorners);

	// LATTICE
	var cellSize = 11; // 15 10, 5, 3 // CELLSIZEHERE
	var latticeAtoB = new Dense.Lattice(imageA,imageB, cornersA, cellSize, matrixFfwd);
	var globalQueue = new PriorityQueue(Dense.Vertex._queueSorting);
	var localQueue = new PriorityQueue(Dense.Vertex._queueSorting);

	// add seed locations
	var i, len = Math.max(pointsA.length,pointsB.length);
	for(i=0; i<len; ++i){
		var pointA = pointsA[i];
		var pointB = pointsB[i];
		var vertex = Dense.vertexFromMatch(pointA,pointB, latticeAtoB);
		if(vertex){
			globalQueue.push(vertex);
		}
		// if(i>=0){
		// 	break;
		// }
	}
	var interpolator = new Dense.Interpolator();
	Dense.INTERPOLATOR = interpolator;
	// SAVE FOR VISUAL ITERATIONS
	Dense.LOCALQUEUE = localQueue;
	Dense.GLOBALQUEUE = globalQueue;
	Dense.LATTICE = latticeAtoB;
	Dense.ITERATION = 0;
	//Dense.TICKER = new Ticker(2000000);
	Dense.TICKER = new Ticker(10);
	Dense.TICKER.addFunction(Ticker.EVENT_TICK, Dense.denseMatch_iteration_ticker, Dense);
	Dense.TICKER.start();
	Dense.KEYBOARD = new Keyboard();
	Dense.KEYBOARD.addFunction(Keyboard.EVENT_KEY_DOWN,Dense.denseMatch_iteration_key,Dense);
	Dense.KEYBOARD.addFunction(Keyboard.EVENT_KEY_STILL_DOWN,Dense.denseMatch_iteration_key,Dense);
	
	Dense.KEYBOARD.addListeners();
}
Dense.denseMatch_iteration = function(){
	var localQueue = Dense.LOCALQUEUE;
	var globalQueue = Dense.GLOBALQUEUE;
	var latticeAtoB = Dense.LATTICE;
	var iteration = Dense.ITERATION;

	var display = Dense.DISPLAY;
	display.removeAllChildren();

	var interpolator = Dense.INTERPOLATOR;

	// TODO: go thru all perimeters to record best next matches
	if(globalQueue.isEmpty()){
		Dense.IS_DONE = true;
		// YAML
		//latticeAtoB.printYAML();
		//Code.copyToClipboardPrompt(str);

//console.log("DONE => OUTPUT FINAL POINT-POINT MATCHES");
		return; 
	}

	// pick up best match ad infinitum
	while(!globalQueue.isEmpty()){
		// TODO: look at ALL seed points & propagate at all perimeters before choosing ?
		++iteration;
		var nextVertex = globalQueue.popMinimum();

		//console.log("IS JOINED: "+nextVertex.isJoined());
		if(nextVertex.isJoined()){ // TODO: remove beforehand
			//console.log("FOUND JOINED -- ignore");
			break;
		}

		console.log("NEXT: "+iteration+" = "+nextVertex+"        ----- rank:"+nextVertex.rank()+" ");

		// MAP BEST CHOICE
		nextVertex.join();
		interpolator.addCell(nextVertex);

		// CHECK / ADD BEST CELL'S PERIMETER POINTS
		nextVertex.assignNeighbors(globalQueue, interpolator);

		// TODO: go thru all vertexes in model & reassign any changed vertexes
		// queue size can be HUGE
		/*
		var old = globalQueue.toArray();
		console.log("GLOBAL QUEUE COUNT: "+old.length);
		for(var i=0; i<old.length; ++i){
			var v = old[i];
			var result = Dense.assignBestNeedleInHaystack(interpolator, v, globalQueue, true);
			if(result){ // already done, don't do again
				globalQueue.remove(v);
				v.matches([]);
				v.transform(null);
				Dense.assignBestNeedleInHaystack(interpolator, v, globalQueue);
				globalQueue.push(v);
			}
		}
		*/
		
		// VISUAL: SHOW MATCHING
		//Dense.showMatchingMapping(latticeAtoB, nextVertex);

		// TODO: NEIGHBOR MATCHING
		break; // ticker loop
	}
	Dense.ITERATION = iteration;
	display.moveToFront();
	display.graphics().alpha(0.5);
	//Dense.visualizeLattice(latticeAtoB, Dense.DISPLAY);
	//Code.printPoints(interpolator.points());
}

Dense.showMatchingMapping = function(latticeAtoB, vertex, displayStage){
	if(vertex){
		var cellSizeA = latticeAtoB.cellSize();
		var imageMatrixA = latticeAtoB.imageFrom();
		var imageMatrixB = latticeAtoB.imageTo();
		var rotationAtoB = vertex.transform().angle();
		var scaleAtoB = vertex.transform().scale();
		//console.log(Code.degrees(rotationAtoB),scaleAtoB);
		var pA = vertex.from();
		var pB = vertex.to();
		// console.log("CELL POINTS: "+pA+" => "+pB);
		// B to A
		var matrix = new Matrix(3,3).identity();
			matrix = Matrix.transform2DRotate(matrix,-rotationAtoB);
			matrix = Matrix.transform2DScale(matrix,1.0/scaleAtoB);
		var bR = ImageMat.extractRectFromFloatImage(pB.x,pB.y,1.0,null,cellSizeA,cellSizeA, imageMatrixB.red(),imageMatrixB.width(),imageMatrixB.height(), matrix);
		var bG = ImageMat.extractRectFromFloatImage(pB.x,pB.y,1.0,null,cellSizeA,cellSizeA, imageMatrixB.grn(),imageMatrixB.width(),imageMatrixB.height(), matrix);
		var bB = ImageMat.extractRectFromFloatImage(pB.x,pB.y,1.0,null,cellSizeA,cellSizeA, imageMatrixB.blu(),imageMatrixB.width(),imageMatrixB.height(), matrix);
		img = GLOBALSTAGE.getFloatRGBAsImage(bR,bG,bB, cellSizeA,cellSizeA);
		d = new DOImage(img);
		d.matrix().translate(0 + pA.x - cellSizeA*0.5, 0 + pA.y - cellSizeA*0.5);
		displayStage.addChild(d);

		// A to B
		var matrix = new Matrix(3,3).identity();
			matrix = Matrix.transform2DRotate(matrix,rotationAtoB);
			matrix = Matrix.transform2DScale(matrix,scaleAtoB);
		var bR = ImageMat.extractRectFromFloatImage(pA.x,pA.y,1.0,null,cellSizeA,cellSizeA, imageMatrixA.red(),imageMatrixA.width(),imageMatrixA.height(), matrix);
		var bG = ImageMat.extractRectFromFloatImage(pA.x,pA.y,1.0,null,cellSizeA,cellSizeA, imageMatrixA.grn(),imageMatrixA.width(),imageMatrixA.height(), matrix);
		var bB = ImageMat.extractRectFromFloatImage(pA.x,pA.y,1.0,null,cellSizeA,cellSizeA, imageMatrixA.blu(),imageMatrixA.width(),imageMatrixA.height(), matrix);
		img = GLOBALSTAGE.getFloatRGBAsImage(bR,bG,bB, cellSizeA,cellSizeA);
		d = new DOImage(img);
		d.matrix().translate(400,0);
		d.matrix().translate(0 + pB.x - cellSizeA*0.5, 0 + pB.y - cellSizeA*0.5);
		displayStage.addChild(d);
	}
}

Dense.visualizeLattice = function(lattice, display){
	var interpolator = Dense.INTERPOLATOR;

	//console.log(lattice);
	var imageA = lattice.imageFrom();
	var imageB = lattice.imageTo();
	var offX = imageA.width();
	var offY = 0; 
	var i, j, k, l;
	var d, color, rad;
	var rows = lattice.rows();
	var cols = lattice.cols();
	var colorTL = 0xFFFF0000;
	var colorTR = 0xFF0000FF;
	var colorBL = 0xFF00FF00;
	var colorBR = 0xFF000000;
	var cell;

	for(j=0; j<rows; ++j){
		for(i=0; i<cols; ++i){
			var vertex = lattice.vertex(i,j);
			vertex._projected = interpolator.projected(vertex.from())["point"];
		}
	}

	var triangles = interpolator.triangles();
	var datas = interpolator.datas();
	var rays = interpolator.rays();

	var points = interpolator.points();
if(points){
	//Code.printPoints(points);

	for(i=0; i<triangles.length; ++i){
		var tri = triangles[i];
		var cA = datas[tri[0]];
		var cB = datas[tri[1]];
		var cC = datas[tri[2]];
			d = new DO();
			d.graphics().clear();
			d.graphics().setLine(2.0, 0x99FF0000);
			d.graphics().beginPath();
			d.graphics().drawPolygon([cA.from(),cB.from(),cC.from()], true);
			d.graphics().strokeLine();
			d.graphics().endPath();
			display.addChild(d);
			d = new DO();
			d.graphics().clear();
			d.graphics().setLine(2.0, 0x99FF0000);
			d.graphics().beginPath();
			d.graphics().drawPolygon([cA.to(),cB.to(),cC.to()], true);
			d.graphics().strokeLine();
			d.graphics().endPath();
			display.addChild(d);
			d.matrix().translate(offX,offY);
		for(j=0;j<3;++j){
			var ray = rays[tri[j]];
			if(ray){
				ray = ray.copy().scale(100.0);
				var fr = datas[tri[j]].from();
				var to = V2D.add(fr,ray);
				d = new DO();
				d.graphics().clear();
				d.graphics().setLine(2.0, 0x990000BB);
				d.graphics().beginPath();
				d.graphics().drawPolygon([fr,to]);
				d.graphics().strokeLine();
				d.graphics().endPath();
				display.addChild(d);
			}
		}
	}
}


	for(j=0; j<rows; ++j){
		for(i=0; i<cols; ++i){
			var vertex = lattice.vertex(i,j);
			var from = vertex.from();
			var to = vertex.to();
			var isJoined = vertex.isJoined();
			var right = vertex.right();
			var bottom = vertex.bottom();
			var left = vertex.left();
			var top = vertex.top();

			var projected = vertex._projected;

			var xPercent = i/(cols-1);
			var yPercent = j/(rows-1);

			color = Code.linear2DColorARGB(xPercent,yPercent,colorTL,colorTR,colorBL,colorBR);
			rad = 3.0;
			if(from){
				d = new DO();
				d.graphics().clear();
				d.graphics().setLine(1.0, color);
				d.graphics().beginPath();
				d.graphics().drawCircle(from.x,from.y, rad);
				d.graphics().strokeLine();
				d.graphics().endPath();
				display.addChild(d);

				d = new DO();
				d.graphics().clear();
				d.graphics().setLine(1.0, color);
				d.graphics().beginPath();
				d.graphics().drawCircle(projected.x,projected.y, rad);
				d.graphics().strokeLine();
				d.graphics().endPath();
				display.addChild(d);
				d.matrix().translate(offX,offY);

				if(bottom){
					var fr = bottom.from();
					var pr = bottom._projected;
					if(fr){
						d = new DO();
						d.graphics().clear();
						d.graphics().setLine(1.0, color);
						d.graphics().beginPath();
						d.graphics().moveTo(from.x,from.y);
						d.graphics().lineTo(fr.x,fr.y);
						d.graphics().strokeLine();
						d.graphics().endPath();
						display.addChild(d);
					}
					if(pr){
						d = new DO();
						d.graphics().clear();
						d.graphics().setLine(1.0, color);
						d.graphics().beginPath();
						d.graphics().moveTo(projected.x,projected.y);
						d.graphics().lineTo(pr.x,pr.y);
						d.graphics().strokeLine();
						d.graphics().endPath();
						display.addChild(d);
						d.matrix().translate(offX,offY);
					}
				}
				if(right){
					var fr = right.from();
					var pr = right._projected;
					if(fr){
						d = new DO();
						d.graphics().clear();
						d.graphics().setLine(1.0, color);
						d.graphics().beginPath();
						d.graphics().moveTo(from.x,from.y);
						d.graphics().lineTo(fr.x,fr.y);
						d.graphics().strokeLine();
						d.graphics().endPath();
						display.addChild(d);
					}
					if(pr){
						d = new DO();
						d.graphics().clear();
						d.graphics().setLine(1.0, color);
						d.graphics().beginPath();
						d.graphics().moveTo(projected.x,projected.y);
						d.graphics().lineTo(pr.x,pr.y);
						d.graphics().strokeLine();
						d.graphics().endPath();
						display.addChild(d);
						d.matrix().translate(offX,offY);
					}
				}
			}
		}
	}
}

Dense.Interpolator = function(cells){
	this._pA = 0.0;
	this._cells = [];
	this._triangulator = new Triangulator();
	//this.setAsNeighbor();
	//this.setAsTri();
	if(cells){
		var i;
		for(i=0; i<cells.length; ++i){
			//this._cells.push(cells[i]);
			this.addCell(cells[i]);
		}
	}
}

Dense.Interpolator.prototype.addCell = function(cell){
	//console.log("ADD CELL: "+cell.from());

this._cells.push(cell);
//return;
//console.log("ADD CELL "+cell);
	this._triangulator.addPoint(cell.from(), cell);
	//console.log("TOTAL POINTS: "+this._triangulator._mesh._points.length);
	var points = this._triangulator.points(); // this.points();
	var datas = this._triangulator.datas()
	var tris = this._triangulator.triangles();
	var perim = this._triangulator.perimeter();
	//console.log("perim: "+perim.length);
	var rays = Code.rayFromPointPerimeter(points,perim, true);
	var hull = perim;
	// if(hull.length>0){
	// 	var rays = [];
	// 	for(i=0; i<=hull.length; ++i){
	// 		var site = hull[ i%hull.length ];
	// 		var prev = hull[ (i-1+hull.length)%hull.length ];
	// 		var next = hull[ (i+1)%hull.length ];
	// 		var sitePoint = points[site];
	// 		var prevPoint = points[prev];
	// 		var nextPoint = points[next];
	// 		var v1 = V2D.sub(sitePoint,prevPoint);
	// 			v1.norm();
	// 		var v2 = V2D.sub(sitePoint,nextPoint);
	// 			v2.norm();
	// 		var angle = V2D.angleDirection(v2,v1) * 0.5;
	// 		ray = V2D.rotate(v2.copy(),angle);
	// 		rays[site] = ray;
	// 	}
	// }
	var hullFilled = [];
	for(i=0; i<hull.length; ++i){
		hullFilled.push( points[hull[i]] );
	}
	this._points = points;
	this._datas = datas;
	this._triangles = tris;
	this._perimeter = perim;
	this._hull = hull;
	this._hullFilled = hullFilled;
	this._rays = rays;
}
Dense.Interpolator.prototype.projected = function(from){
	var nextPos = new V2D(0,0);
	var nextScale = 0.0;
	var nextAngle = 0.0;
	var interp = this.value(from); // PASS IN VALUE:

//var pointCount = this._triangulator.points().length;///this._points.length; // if points == 1 => double projected area ? === seed point
//interp.push({"value":});
var pointCount = this._cells.length;
if(interp.length==0){
	console.log("NO VALUES TO INTERPRET: "+interp.length);
}
	for(k=0; k<interp.length; ++k){
		var int = interp[k];
		var c = int["value"];
		var p = int["percent"];
		var originA = c.from();
		var originB = c.to();
		var angle = c.angle();
		var scale = c.scale();
		var relativeDirA = V2D.sub(from,originA);
		var isTriangular = int["triangular"] === true;
		//if(this._pA==0.0){
		if(isTriangular){
			var pos = relativeDirA.copy().add(originB).scale(p); // better for triangle interpolation
		}else{
			var pos = relativeDirA.copy().rotate(angle).scale(scale).add(originB).scale(p);
		}
		//var pos = relativeDirA.copy().rotate(angle).scale(scale).add(originB).scale(p);
		// var pos = relativeDirA.copy().rotate(angle).scale(scale).add(originB).scale(p); // better for 1/d^2
		// var pos = relativeDirA.copy().add(originB).scale(p); // better for triangle interpolation
		nextScale += scale*p;
		nextAngle += angle*p;
		nextPos.add(pos);
	}
	nextScale = Math.max(0.1,Math.min(10.0,nextScale));
	if(nextPos.x==0 || nextPos.y==0 || Code.isNaN(nextPos.x) || Code.isNaN(nextPos.y)){
		console.log("GOT INTERP: ");
		console.log(interp.length);
		for(k=0; k<interp.length; ++k){
			var c = int["value"];
			var p = int["percent"];
			console.log(". "+k);
			console.log("value: "+c);
			console.log("percent: "+p);
		}
	}
	//console.log("NEXT POS: "+nextPos);
	return {"point":nextPos, "scale":nextScale, "angle":nextAngle};
}
Dense.Interpolator.prototype.points = function(){
	//var points = this._triangulator.points();
	return this._points;
}
Dense.Interpolator.prototype.triangles = function(){
	//var triangles = this._triangulator.triangles();//this._triangles;
	return this._triangles;
}
Dense.Interpolator.prototype.datas = function(){
	//var datas = this._triangulator.datas();//this._cells;
	return this._datas;
}
Dense.Interpolator.prototype.perimeter = function(){
	//var perimeter = this._triangulator.perimeter();//this._datas;
	return this._perimeter;
}
Dense.Interpolator.prototype.rays = function(){
	return this._rays;
}
Dense.Interpolator.prototype.hull = function(){
	return this._hull;
}
Dense.Interpolator.prototype.hullFilled = function(){
	return this._hullFilled;
}
Dense.Interpolator.prototype.setAsTri = function(){
	this._pA = 0.0;
}
Dense.Interpolator.prototype.setAsNeighbor = function(){
	this._pA = 1.0;
}

Dense.Interpolator.prototype.value = function(point){
	var interpolateTriangular = true;
	//var interpolateTriangular = false;
	// nearest by distance:
		var items = [];
		var cells = this._cells;
		var i;
		var cell, distance, fraction;
		var total = 0;
		var largest = -1;
		for(i=0; i<cells.length; ++i){
			cell = cells[i];
			distance = V2D.distance(cell.from(), point);
			if(distance==0){
				return [{"value":cell, "percent":1.0}];
			}
			//fraction = 1.0/(distance*distance); // OK -- very pinchy locally
			//fraction = 1.0/(distance); // bad
			//fraction = 1.0/Math.pow(distance,1.5); // poor
			//fraction = 1.0/Math.pow(distance,2.0); // OK
			//fraction = 1.0/Math.pow(distance,0.5); // OK
			//fraction = Math.exp(-0.001*distance); // OK
			//fraction = distance - 400; // OK
			//fraction = 1.0 / Math.pow(distance,2);
			//fraction = 1.0 / Math.pow( Math.exp(-distance), 2);
			//fraction = 1.0 / Math.pow( Math.exp(-distance), 2);
			//fraction = 1.0 / Math.pow( distance, 10);
			fraction = 1.0 / (1 + Math.pow(distance, 2) );
			//fraction = 1.0 / Math.pow( distance, 1);
			//total += fraction;
			largest = Math.max(largest,fraction);
			items.push({"value":cell, "percent":fraction, "triangular":false});
		}
		//return [{"value":cell, "percent":largest}];
		items = items.sort(function(a,b){
			return a["percent"] < b["percent"] ? 1 : -1;
		});
		var maxCount = 2;
		if(items.length>maxCount){
			items.splice(maxCount,items.length-maxCount+1);
		}
// add in one:
	
// how to smooth this out ?

		//console.log(items);
		for(i=0; i<items.length; ++i){
			//var factor = Math.pow(i+1,0.25);//(Math.pow(i,2)+1);
			//items[i]["percent"] = Math.pow(items[i]["percent"],i+1);
			//var factor = 1.0 * Math.exp(-0.1*i);
			//var factor = 1.0 * Math.exp(-0.5*i);
			//var factor = 1.0/(i+1);
			var factor = 1.0;
			items[i]["percent"] = items[i]["percent"] * factor;
			total += items[i]["percent"];
		}
		for(i=0; i<items.length; ++i){
			items[i]["percent"] /= total;
		}
// simple distance only
//return items;

	var distanceItems = items;
if(!interpolateTriangular){
return distanceItems;
}



	var i, j, k;
	var items = [];
	var points = this.points();
	var datas = this.datas();
	var cells = datas;
	var tris = this.triangles();
	var rays = this.rays();
	var hull = this.hull();
	var hullFilled = this.hullFilled();

	//var triangle = this._triangulator.triangle(point);
	//neighbors = triangle.neighbors();
	//var triangle = this._triangulator.mesh().triangle(point);
	//console.log(triangle);
	
	var triangleNeighbors = this._triangulator.mesh().triangleNeighbors(point,true);
	//console.log(triangleNeighbors);
//throw "T";

if(points.length<3){
	return distanceItems;
}
	/*
	if(points.length==0){
		// items.push({"value":null, "percent":1.0});
	}else if(points.length==1){
		items.push({"value":cells[0], "percent":1.0});
	}else if(points.length==2){
// THIS SEEMS HIGHLY OFF
		var cellA = cells[0];
		var cellB = cells[1];
		var pointA = cellA.from();
		var pointB = cellB.from();
		// general distance
		var distanceA = V2D.distance(point,pointA);
		var distanceB = V2D.distance(point,pointB);
			// distanceA = distanceA * distanceA;
			// distanceB = distanceB * distanceB;
		var distanceTotal = distanceA + distanceB;
		var fracA = 1.0 - distanceA/distanceTotal;
		var fracB = 1.0 - distanceB/distanceTotal;
		items.push({"value":cellA, "percent":fracA});
		items.push({"value":cellB, "percent":fracB});
		
		var rayAB = V2D.sub(pointB,pointA);
		// find closest point on line 0-1
		var distanceAB = rayAB.length();
		var closest = Code.closestPointLine2D(pointA,rayAB, point);
		var dA = V2D.distance(closest, pointA);
		var dB = V2D.distance(closest, pointB);
		if(dA<distanceAB && dB<distanceAB){
			var fracA = dB/distanceAB;
			var fracB = dA/distanceAB; // 1.0 - fracA; //
			items.push({"value":cellA, "percent":fracA});
			items.push({"value":cellB, "percent":fracB});
		}else if(dB<dA){ // all B
			items.push({"value":cellB, "percent":1.0});
		}else if(dA<dB){ // all A
			items.push({"value":cellA, "percent":1.0});
		}
		
	}else if(points.length>=3){
*/
		//var isInside = Code.isPointInsidePolygon2D(point, hullFilled); // THIS IS BAD
		var tri = null;
			for(i=0; i<tris.length; ++i){// find containing triangle
				var t = tris[i];
				var a = points[t[0]];
				var b = points[t[1]];
				var c = points[t[2]];
				var inside = Code.isPointInsideTri2D(point, a,b,c);
				if(inside){
					tri = [ datas[t[0]], datas[t[1]], datas[t[2]]];
					break;
				}
			}
		var isInside = tri !== null;
		if(isInside){
			//???
			//console.log("triangleNeighbors: "+triangleNeighbors.length);
			var cw = 0;
			var ccw = 0;
			var minAngle = 1000
			for(var k=0; k<triangleNeighbors.length; ++k){
				var t = triangleNeighbors[k];
				//console.log(k+": "+t+" .............");
				var a = t.a();
				var b = t.b();
				var c = t.c();
				var vA = cells[a.id()];
				var vB = cells[b.id()];
				var vC = cells[c.id()];
				var toA = vA.to();
				var toB = vB.to();
				var toC = vC.to();
				// console.log(toA);
				// console.log(toB);
				// console.log(toC);
				// throw("X")
				var isCCW = Code.isCCW(toA,toB,toC);
				minAngle = Math.min( minAngle, Code.minimumTriAngle(toA,toB,toC) );
				if(isCCW){
					ccw += 1;
				}else{
					cw += 1;
				}
			}
			
			if( (cw>0 && ccw>0) || minAngle<Code.radians(10) ){
				// USE LOCAL EXPANSIONONLY, NOT TRIANGULAR EXPANSION
				//console.log("FLIPPED");
//				interpolateTriangular = false;
			}else{
				interpolateTriangular = true;

			}

			
				var areaTotal = V2D.areaTri(tri[0].from(),tri[1].from(),tri[2].from());
				if(areaTotal==0){
					Code.printPoints(this._triangulator.points());
					console.log(tri[0].row(),tri[0].col(),"  ",tri[1].row(),tri[1].col(),"  ",tri[2].row(),tri[2].col());
					console.log(tri[0].from(),tri[1].from(),tri[2].from());
				}
				// console.log("HAVE TRI "+tri+" >>> "+areaTotal);
				for(k=0; k<3; ++k){
					var c = tri[k];
					var area = V2D.areaTri(tri[(k+1)%3].from(),tri[(k+2)%3].from(),point);
					var percent = area / areaTotal;
					items.push({"value":c, "percent":percent,"triangular":true});
				}
			//}
		}else{
			var closestDistance = null;
			var closestPoint = null;
			var cellA = null;
			var cellB = null;
			var rayA = null;
			var rayB = null;
			for(i=0; i<hull.length; ++i){ // for every pair of hull points
				var curr = hull[i];
				var next = hull[(i+1)%hull.length];
				var a = points[curr];
				var b = points[next];
				var ab = V2D.sub(b,a);
				var rA = rays[curr];
				var rB = rays[next];
				var closest = Code.closestPointLineSegment2D(a,ab, point);
				if(closest){
					var distance = V2D.distance(point,closest);
					if(closestDistance==null || distance<closestDistance){
						var pointA = Code.rayLineIntersect2D(point,ab, a,rA);
						var pointB = Code.rayLineIntersect2D(point,ab, b,rB);
						if(pointA && pointB){
							var dA = V2D.distance(point, pointA);
							var dB = V2D.distance(point, pointB);
							var dAB = V2D.distance(pointA, pointB);
							if(dA<=dAB && dB<=dAB){ // check to see point is between 2 rays
								closestDistance = distance;
								closestPoint = closest;
								cellA = datas[curr];
								cellB = datas[next];
								rayA = rA;
								rayB = rB;
							}
						}
					}
				}
			}
			if(cellA && cellB){
/*
// find 3rd point from hull
				var cellC = null;
				for(i=0; i<tris.length; ++i){
					var tri = tris[i];
					var a = points[tri[0]];
					var b = points[tri[1]];
					var c = points[tri[2]];
					console.log(a,b,c);
					if( 
						(V2D.equal(a,cellA.from()) && V2D.equal(b,cellB.from())) ||
						(V2D.equal(b,cellA.from()) && V2D.equal(a,cellB.from()))
						){
						cellC = datas[tri[2]];
							break;
					}else if(
						(V2D.equal(a,cellA.from()) && V2D.equal(c,cellB.from())) ||
						(V2D.equal(c,cellA.from()) && V2D.equal(a,cellB.from())) 
						){
						cellC = datas[tri[1]];
							break;
					}else if(
						(V2D.equal(b,cellA.from()) && V2D.equal(c,cellB.from())) ||
						(V2D.equal(c,cellA.from()) && V2D.equal(b,cellB.from()))
						){
							cellC = datas[tri[0]];
							break;
					}
				}
				
console.log(cellC);
//TODO: find closest triangle & do interpolation with NEGATIVE amounts ?
tri = [cellA,cellB,cellC];
				var areaTotal = 0;//V2D.areaTri(tri[0].from(),tri[1].from(),tri[2].from());
				for(k=0; k<3; ++k){
					var c = tri[k];
					var area = V2D.areaTri(tri[(k+1)%3].from(),tri[(k+2)%3].from(),point);
					area = Math.abs(area);
					areaTotal += area;
				}
				for(k=0; k<3; ++k){
					var c = tri[k];
					var area = V2D.areaTri(tri[(k+1)%3].from(),tri[(k+2)%3].from(),point);
					area = Math.abs(area);
					var percent = area / areaTotal;
					console.log(area+" / "+areaTotal+" = "+percent);
					items.push({"value":c, "percent":percent});
				}
return items;
*/
				var cA = cellA.from();
				var cB = cellB.from();
				
				// use rays
				// var gamma = V2D.sub(cB,cA);
				// var pointA = Code.rayLineIntersect2D(point,gamma, cA,rayA);
				// var pointB = Code.rayLineIntersect2D(point,gamma, cB,rayB);
				// var dA = V2D.distance(point, pointA);
				// var dB = V2D.distance(point, pointB);
				// var distanceAB = V2D.distance(pointA, pointB);

				// use nearest
				var pointA = cellA.from();
				var pointB = cellB.from();
				var dA = V2D.distance(closestPoint, pointA);
				var dB = V2D.distance(closestPoint, pointB);
				var distanceAB = V2D.distance(pointA, pointB);
				/*
dA = V2D.distance(point,pointA);
dB = V2D.distance(point,pointB);
	// dA = dA * dA;
	// dB = dB * dB;
distanceAB = dA + dB;
var fracA = 1.0 - dA/distanceAB;
var fracB = 1.0 - dB/distanceAB;

// if(dA<dB){
// 	items.push({"value":cellA, "percent":1.0});
// }else{
// 	items.push({"value":cellB, "percent":1.0});
// }

items.push({"value":cellA, "percent":fracA});
items.push({"value":cellB, "percent":fracB});
return items;
				*/
				var tr = interpolateTriangular;
				if(dA<distanceAB && dB<distanceAB){
					var fracA = dB/distanceAB;
					var fracB = 1.0 - fracA; // dA/distanceAB;
					items.push({"value":cellA, "percent":fracA, "triangular":tr});
					items.push({"value":cellB, "percent":fracB, "triangular":tr});
				}else if(dB<dA){ // all B
					items.push({"value":cellB, "percent":1.0, "triangular":tr});
				}else if(dA<dB){ // all A
					items.push({"value":cellA, "percent":1.0, "triangular":tr});
				}
				return items;
			}
		}
		
	//}
	//var pA = 1.0;
// TODO: if occlusion is detected (overlapping triangles)
//       => use distance metrics instead

	var pA = this._pA;
	var pB = 1.0 - pA;
	var triangleItems = items;


if(interpolateTriangular){
	return triangleItems;
}else{
	return distanceItems;
}


//return triangleItems;

items = [];
	for(i=0; i<distanceItems.length; ++i){
		var item = distanceItems[i];
		item["percent"] *= pA;
		items.push( item );
	}
	for(i=0; i<triangleItems.length; ++i){
		var item = triangleItems[i];
		item["percent"] *= pB;
		items.push( item );
	}

	return items;
}






/*
SUM_i((x_i - x_avg)*(y_i - y_avg)) / [sqrt( SUM_i((x_i - x_avg)^2) ) * sqrt( SUM_i((y_i - y_avg)^2) )]
*/
/*
- global queue (Q) keeps track of next-best-matches
  - Q is initialized with seed points (S)v

while(next match exists and has at least minimum score):
  - choose next best satallite point-match from Q
    => satellite operation =>
    - set as matched:
      - remove from Q
      - create areas Ai & Aj if features are not already inside an area
      - join/attach area cells to adjacent area(s)if possible (possible that satellite / seed point may not join any areas)
    - for all un-searched neighbor cells in I (Ai) and in J (Aj):
      - select cell definitive feature point (eg highest corner score)
      - search corresponding area's cell's neighbors [not just perimeter] for best match
      - add best match to global queue


check that match will be consistenf before allowing [consistency may have changed since added]
- should not make match if:
	an affected triangle will swap directions

on match:
	- update inerpolation-matching model
	for each unmatched neighbor cell:
		- search for match ONLY IN DIRECTION AWAY FROM CENTER CELL + error
		- use projected model for TO

	


*/


