<html>
<head>
<title>Surface Triangulation</title>
<script src="../code/FF.js"></script>
</head>
<script type="text/javascript">
function pageLoadedFxn(){
	var ff = new FF("../code/",ffLoadedFxn);
}
function ffLoadedFxn(){
	(new ScriptLoader("./",["PointCloud.js","BivariateSurface.js","MLSPoint.js","MLSEdge.js","MLSTri.js","MLSEdgeFront.js","MLSFront.js","MLSField.js","MLSMesh.js","SurfaceTri.js"],this,classesLoadedFxn)).load();
}
function classesLoadedFxn(){
	/*
	var res;
	var o = new V3D(0,0,0);
	var d = new V3D(1,1,0);
	var n = new V3D(1,0,1);
	var q = new V3D(1,2,3);
	res = Code.intersectRayPlane(o,d, q,n);
	console.log(res+"");
	// -------
	console.log("--------------");
	var a,b,c,d, pnt,nrm;
	pnt = new V3D(2,4,0);
	nrm = new V3D(1,2,0);
	pnt = Code.intersectRayPlane(new V3D(0,0,0),new V3D(0,1,0), pnt,nrm); // get new point in plane
	console.log(pnt+" "+nrm);
	//
	res = Code.planeEquationFromPointNormal(pnt,nrm);
	a = res.a; b = res.b; c = res.c; d = res.d;
	console.log(a+" "+b+" "+c+" "+d);
	//
	res = Code.planePointNormalFromEquation(a,b,c,d);
	pnt = res.point;
	nrm = res.normal;
	console.log(pnt+" "+nrm);
	//
	res = Code.planeEquationFromPointNormal(pnt,nrm);
	a = res.a; b = res.b; c = res.c; d = res.d;
	console.log(a+" "+b+" "+c+" "+d);

	res = Code.planePointNormalFromEquation(a,b,c,d);
	pnt = res.point;
	nrm = res.normal;
	console.log(pnt+" "+nrm);
	*/
/*
var pnts = [ 1, 1, 1.0,
			1,-1, -0.5,
		   -1, 1, 1.0,
		   -1,-1, 1.0,
		    0, 0,-1.0,
		    1, 0, 0.0,
		   -1, 0, 0.0,
		    0, 1, 0.0,
		    0,-1, 0.0];
var i, points = new Array();
var index = 0;
for(i=0;i<pnts.length;i+=3){
	points[index] = new V3D(pnts[i],pnts[i+1],pnts[i+2]);
	++index;
}
console.log(points);
var sur = new BivariateSurface();
sur.fromPoints(points, 4);
*/
/*
console.log("triangulate surface");

console.log(this._pointCloud._tree.size());

//console.log(this._pointCloud.toString()+"");

var arr;

//arr = this._pointCloud.pointsInsideCuboid( (new V3D(-1,-1,-1)).scale(0.6), (new V3D(1,1,1)).scale(0.6) );

var cen = new V3D(0.5,0,0);
rad = 0.6;
//arr = this._pointCloud.pointsInsideSphere( cen,rad);

var closest = this._pointCloud.closestPointToPoint(cen)
console.log(  V3D.distanceSquare(cen,closest) );


arr = this._pointCloud.kNearestNeighborsToPoint(10, cen);

console.log( arr );
for(var i=0;i<arr.length;++i){
	//console.log( V3D.distance(cen,arr[i]) );
	console.log(  i+": "+ V3D.distanceSquare(cen,arr[i]) );
}

console.log("CORRECT ANSWER: ---------------------------");

arr = this._pointCloud._points;
arr.sort( function(a,b){ return V3D.distanceSquare(a,cen)-V3D.distanceSquare(b,cen); } );


for(var i=0;i<arr.length && i<10;++i){
	console.log( i+": "+ V3D.distanceSquare(cen,arr[i]) );
}
*/
/*
var org, dir, A, B, q;

A = new V3D(1,1,0);
B = new V3D(4,4,0);
point = new V3D(4,2,0);

org = A;
dir = V3D.sub(B,A);
q = Code.closestPointLineSegment3D(org,dir, point);
console.log(org+"");
console.log(dir+"");
console.log("--- "+point);
console.log(q+"");
return;
*/
/*
var ll = new LinkedList(true);
var l1,l2,l3,l4,l5,l6,l7,l8,l9;
console.log(ll.toString());

// -- a1

l5 = ll.push(5);
l6 = ll.push(6);
l7 = ll.push(7);
console.log(ll.toString());
l3 = ll.unshift(3);
console.log(ll.toString());
l4 = ll.addAfter(l3,4);

console.log(ll.toString());
l9 = ll.push(9);
console.log(ll.toString());
l8 = ll.addBefore(l9,8);

console.log(ll.toString());

// -- r1
ll.pop();
console.log(ll.toString());
ll.shift();
console.log(ll.toString());
ll.shift();
ll.shift();
ll.shift();
ll.shift();
console.log(ll.toString());
ll.pop();
ll.pop();
console.log(ll.toString());

// -- a2

l1 = ll.push(1);
l2 = ll.push(2);
l3 = ll.push(3);
console.log(ll.toString());
ll.removeNode(l2);
console.log(ll.toString());
ll.removeNode(l3);
console.log(ll.toString());
ll.removeNode(l1);
console.log(ll.toString());

return;
*/

/*
var org, dir, a,b,c, p;
org = new V3D(-1,-1,-1);
dir = new V3D(3.666666666666,2,1);
dir.scale(1E9);
a = new V3D(0,0,0);
b = new V3D(3,0,0);
c = new V3D(2,3,0);
p = Code.intersectRayTri(org,dir, a,b,c);
console.log(p+"");
return;
*/

/*
var oa,da,ob,db;
oa = new V3D(1,1,0); da = new V3D(3,3,0); ob = new V3D(3,1,1); db = new V3D(-1,3,0);
// parallel
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(-2,0,1); db = new V3D(1,0,0);
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(-1,0,1); db = new V3D(1,0,0);
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(-1,0,1); db = new V3D(2,0,0);
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(-1,0,1); db = new V3D(5,0,0);
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(0,0,1); db = new V3D(1,0,0);
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(0.5,0,1); db = new V3D(1,0,0);
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(1,0,1); db = new V3D(2,0,0);
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(2,0,1); db = new V3D(1,0,0);
oa = new V3D(0,0,0); da = new V3D(2,0,0); ob = new V3D(3,0,1); db = new V3D(1,0,0);

p = Code.closestPointsSegments3D(oa,da, ob,db);
console.log(p+"");
return;
*/

/*
var pA,pB, oa,da, ob,db;

oa = new V3D(0,3,0); da = new V3D(8,2,0); ob = new V3D(4,0,0); db = new V3D(3,5,0);
oa = new V3D(0,3,0); da = new V3D(8,2,0); ob = new V3D(4,0,0); db = new V3D(1,2,0);
ob = new V3D(0,3,0); db = new V3D(8,2,0); oa = new V3D(4,0,0); da = new V3D(1,2,0); // flip
oa = new V3D(3,2,0); da = new V3D(2,2,0); ob = new V3D(4,2,0); db = new V3D(1,1,0);
oa = new V3D(3,2,0); da = new V3D(2,2,0); ob = new V3D(1,1,0); db = new V3D(4,0,0);

arr = Code.closestPointsSegments3D(oa,da, ob,db);
pA = arr[0];
pB = arr[1];
console.log(pA+"");
console.log(pB+"");
return;
*/

/*
var o,d, a,b,c, r;
a = new V3D(0,0,0); b = new V3D(3,0,0); c = new V3D(1.5,3,2);
o = new V3D(2,1,0); d = new V3D(3,0,0);
o = new V3D(1,0.5,0); d = new V3D(1,0,0.1);
o = new V3D(0.5,2,0); d = new V3D(3,0,0);
o = new V3D(0.5,2,1.33); d = new V3D(3,0,0);
o = new V3D(3,0,0); d = new V3D(1,2,0);

r = Code.closestDistanceSegmentTri3D(o,d, a,b,c);
console.log(r+"");
return;
*/

/*
var qa, qb, qt, d, v, u, m, angle1, angle2;

angle1 = Math.PI*(1.0/2.0);
angle2 = -Math.PI*(1.0/2.0);
d = new V3D(0,0,1);
v = new V3D(2,1,0);
u = new V3D();
qa = new V4D();
qb = new V4D();
qt = new V4D();
qt.qClear();
qa.qRotateDir(d.x,d.y,d.z, angle1);
qb.qRotateDir(d.x,d.y,d.z, angle2);

V4D.qMul(qt, qb,qt);
V4D.qMul(qt, qa,qt);


m = V4D.qMatrix(qt);
u = m.multV3D(u,v);
console.log(qa+"");
console.log(m+"");
console.log(v+"");
console.log("----------------->");
console.log(u+"");
return;
*/
/*
var pA,nA, pB,nB, line;

nA = new V3D(1,0,0);
pA = new V3D(2,1,1);
nB = new V3D(1,1,0);
nB.norm();
pB = new V3D(1,2,2);

// var i = 0, count = 1000000;
// Code.timerStart()
// //Code.timerQuickDifferenceSeconds();
// for(i=count;i--;){
// 	line = Code.planePlaneIntersection(pA,nA, pB,nB);
// }
// Code.timerStop();
// console.log("seconds: "+Code.timerDifferenceSeconds());

line = Code.planePlaneIntersection(pA,nA, pB,nB);
console.log(line)
if(line){
	console.log(line[0]+"")
	console.log(line[1]+"")
}
*/

/*
var a1,b1,c1,n1,  a2,b2,c2,n2;

a1 = new V3D(2, 3, 0);
b1 = new V3D(2,-3,-3);
c1 = new V3D(2,-3, 3);
n1 = V3D.cross(V3D.sub(b1,a1),V3D.sub(c1,a1)).norm();

a2 = new V3D(0,-1, 0);
b2 = new V3D(4,-1,-3);
c2 = new V3D(4,-1, 3);
n2 = V3D.cross(V3D.sub(b2,a2),V3D.sub(c2,a2)).norm();

// coplanar
a2 = new V3D(2, 3, 0);
b2 = new V3D(2,-3,-3);
c2 = new V3D(2,-3, 3);
n2 = V3D.cross(V3D.sub(b2,a2),V3D.sub(c2,a2)).norm();


console.log(a1+" | "+b1+" | "+c1+" | "+n1);
console.log(a2+" | "+b2+" | "+c2+" | "+n2);

intersect = Code.triTriIntersection(a1,b1,c1,n1, a2,b2,c2,n2);

console.log(intersect);
if(intersect){
	console.log(intersect.length);
	console.log(intersect[0]+" "+intersect[1])
}

return;
*/

	var surface = new SurfaceTri();
}
</script>
<body onload="pageLoadedFxn();">
</body>
</html>
