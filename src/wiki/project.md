# Project





## Proposal
- application goals
- purpose
- audience
- metrics for success


## Initial Design

- UI, UX, sequences
- data flow / data structures / diagrams
- systems
	- design modularly (/generically?)
- individual features
- entirety of app thought out before pieces are put together in final source project
	- all main and edge cases need to be defined
		- things like:
			- connection failure, server failure, client failure, ...


## Prototyping Design

- seperately iterate on:
	- systems
	- features
	- experiments
	- ...
- a prototype app can be made, but seperately from actual app code base
- systems designed with entirety of problem/scope defined are easier to piece together
- prototype systems put together ad hoc cause bugs and maintenence buildup & harder to change

## Iterating

- steps loop:
	- define
	- design
	- implement
	- test / find deltas = difference in definition & product
	- update definitions (& expectations)
- systems & features need to be mostly completed before including in application code base


## Communication

- available to everyone:
	- calendar
		- simple with key dates
		- detailed with agreements / expectations
	- UI/UX diagrams
	- Data Flow diagrams
	- System communication
		- simple diagrams [interfaces]
		- detailed interface definitions
	- delivery definitions
	- tasks database
	- standup meetings
	- design meetings
	- action items
	- individual daily/weekly summaries
		- keep track of current priorities
	- aggregated project daily/weekly summaries
		- keep track of project progress

## Time Management

- stages of feature development:
	- task completion date (development)
	- QA testing time [week]
	- fixing time [days]
	- delivery dates [cutoff]


## Engineering

- code tests
	- behaviors & data definitions
	- API definition compliance
- documentation
	- features stay on specific topic
	- related topics are defined on their own pages
		- eg: general usage of an application (xcode) vs using application as step (xcode > build)


























