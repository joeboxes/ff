<html>
<head>
<title>Averaging</title>
<script src="../code/FF.js"></script>
</head>
<script type="text/javascript">
function pageLoadedFxn(){
	var ff = new FF("../code/",ffLoadedFxn);
}
function ffLoadedFxn(){
	// (new ScriptLoader("./",["R3D.js"],this,classesLoadedFxn)).load();
	(new ScriptLoader("./",[],this,classesLoadedFxn)).load();
}
function setupDisplay(){
	this._canvas = new Canvas(null,0,0,Canvas.STAGE_FIT_FILL, false,false, true);
	this._stage = new Stage(this._canvas, 1000/20);
	this._root = new DO();
	this._stage.addChild(this._root);
	GLOBALSTAGE = this._stage;

	this._canvas.addListeners();
	this._stage.addListeners();
	this._stage.start();
	
	// console.log(this._stage)
}


function classesLoadedFxnA(){
	setupDisplay();

	// create absolute locations
	var m;

	var absolutes = [];
		m = new Matrix3D(); m.rotateZ(Code.radians(0.0)); m.rotateX(Code.radians(0.0)); m.rotateY(Code.radians(0.0)); m.translate(-1,1,-1);
	absolutes.push(m.toMatrix());
		m = new Matrix3D(); m.rotateZ(Code.radians(10.0)); m.rotateX(Code.radians(20.0)); m.rotateY(Code.radians(25.0)); m.translate(1,1,1);
	absolutes.push(m.toMatrix());
		m = new Matrix3D(); m.rotateZ(Code.radians(-10.0)); m.rotateX(Code.radians(10.0)); m.rotateY(Code.radians(50.0)); m.translate(3,2,2);
	absolutes.push(m.toMatrix());

	// generate extrinsic matrices
	var extrinsics = [];
	for(var i=0; i<absolutes.length; ++i){
		var absolute = absolutes[i];
		var extrinsic = Matrix.inverse(absolute);
		extrinsics[i] = extrinsic;
	}
	console.log(extrinsics);

	// create absolute inital graph (error)
	var initials = [];
	for(var i=0; i<extrinsics.length; ++i){
		var extrinsic = extrinsics[i];//.copy();
		var initial = Matrix.inverse(extrinsic);
			// ADD ERROR
			var mag = 0.50;
			var errorA = (Math.random()-0.5)*mag;
			var errorB = (Math.random()-0.5)*mag;
			var errorC = (Math.random()-0.5)*mag;
			var gam = 0.10;
			var errorX = (Math.random()-0.5)*gam;
			var errorY = (Math.random()-0.5)*gam;
			var errorZ = (Math.random()-0.5)*gam;
console.log(errorA,errorB,errorC, errorX,errorY,errorZ)
			var m = new Matrix3D(); m.rotateZ(Code.radians(errorA)); m.rotateX(Code.radians(errorB)); m.rotateY(Code.radians(errorC)); m.translate(errorX,errorY,errorZ);
				m = m.toMatrix();
// console.log("A:\n"+initial+"");
			initial = Matrix.mult(initial,m);
		initials[i] = initial;
// console.log("B:\n"+initial+"");
	}
	// throw "??????????";

	// create pair edges [truth]
	var edges = [];
		edges.push([0,1]);
		edges.push([0,2]);
		edges.push([1,2]);
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var indexA = edge[0];
		var indexB = edge[1];
		var absoluteA = Matrix.inverse(extrinsics[indexA]);
		var absoluteB = Matrix.inverse(extrinsics[indexB]);
		// var absoluteAtoB = Matrix.relativeWorld(absoluteA,absoluteB);
		var absoluteAtoB = Matrix.relativeReference(absoluteA,absoluteB);
		//
console.log("A:\n"+Matrix.relativeReference(initials[indexA],initials[indexB])+"");
console.log("B:\n"+absoluteAtoB+"");
		//
		edge[2] = absoluteAtoB;
	}
// throw "???"
	// test
	console.log(initials);
	console.log(edges);
	var result = Code.graphAbsoluteUpdateFromRelativeTransforms(initials, edges);
	console.log(result);
	var optimums = result["values"];

	for(var i=0; i<extrinsics.length; ++i){
		var extrinsic = extrinsics[i];
		var absolute = Matrix.inverse(extrinsic);
		var optimum = optimums[i];
		console.log(i+" : ");
		console.log("  A \n"+absolute);
		console.log("  B \n"+optimum);
	}
	// ...
	throw "..."
}




function classesLoadedFxn(){
	setupDisplay();

	// var matrixCount = 10;
	var matrixCount = 20;
	// var matrixCount = 50;
	var transforms = [];
	var variableP = [];
	// make some absolute matrixes
	for(var i=0; i<matrixCount; ++i){
		var m = new Matrix(4,4).identity();
			m = Matrix.transform3DTranslate(m, 0,0,-10);
			m = Matrix.transform3DRotateY(m, Code.radians(-10*i));
			m = Matrix.transform3DTranslate(m, 1,2,3);
			// m = Matrix.inverse(); // if want extrinsic
		transforms[i] = m;
		if(i%2==1){
			variableP.push(i);
		}
	}
	// make some relative references:
	var pairs = [];
	for(var i=0; i<matrixCount; ++i){
		var staJ = i+1;
		var endJ = Math.min(staJ+2,matrixCount);
		for(var j=staJ; j<endJ; ++j){
			pairs.push([i,j]);
		}
	}


	var s = 0.0;
	// var s = 0.10;
	// var s = 0.50;

	var a = Code.radians(0.0);
	// var a = Code.radians(10.0);
	// var a = Code.radians(30.0);

	for(var i=0; i<pairs.length; ++i){
		var pair = pairs[i];
		var indexA = pair[0];
		var indexB = pair[1];
		var matrixA = transforms[indexA];
		var matrixB = transforms[indexB];
			var relAB = Matrix.relativeReference(matrixA,matrixB);
			relAB = Matrix.transform3DTranslate(relAB, (Math.random()-0.5)*s,(Math.random()-0.5)*s,(Math.random()-0.5)*s);
			relAB = Matrix.transform3DRotateX(relAB, (Math.random()-0.5)*a);
			relAB = Matrix.transform3DRotateY(relAB, (Math.random()-0.5)*a);
			relAB = Matrix.transform3DRotateZ(relAB, (Math.random()-0.5)*a);
			pair[2] = relAB;
	}

	// set initial offsets
	var initialP = [];
	// var s = 0.0;
	// var s = 0.50;
	// var s = 1.0;
	var s = 2.0;
	// var a = Code.radians(0.0);
	// var a = Code.radians(30.0);
	var a = Code.radians(45.0);
	for(var i=0; i<matrixCount; ++i){
		var transform = transforms[i];
		var P = transform.copy();
		var center = P.multV3DtoV3D(new V3D());
			P = Matrix.transform3DTranslate(P, -center.x,-center.y,-center.z);
			P = Matrix.transform3DRotateX(P, (Math.random()-0.5)*a);
			P = Matrix.transform3DRotateY(P, (Math.random()-0.5)*a);
			P = Matrix.transform3DRotateZ(P, (Math.random()-0.5)*a);
			P = Matrix.transform3DTranslate(P, center.x,center.y,center.z);
			P = Matrix.transform3DTranslate(P, (Math.random()-0.5)*s,(Math.random()-0.5)*s,(Math.random()-0.5)*s);
		initialP[i] = P;
	}

	console.log(transforms);
	console.log(variableP);
	console.log(pairs);


	// make some static


	// variableP
	// variableP = [0];
	variableP = null;

	var result = Code.graphAbsoluteFromRelativePose3D(pairs,initialP, 1000,1000, variableP);
	// var result = Code.graphAbsoluteUpdateFromRelativeTransforms(initialP, pairs, 1000, variableP);
	console.log(result);
	var values = result["values"];
	console.log(values);

	// throw "?"
	
	displayViewGraph(initialP,pairs);

	displayViewGraph(values,pairs, 1000,null, 0xFFFF0000);
	// displayViewGraph(values,pairs, 1000);

	throw "yep"
}


function displayViewGraph(transforms, pairs, offsetX, groupIDs, colorLine){
	offsetX = offsetX!==undefined ? offsetX : 0.0;
	colorLine = Code.valueOrDefault(colorLine, 0x990000CC);

	
	console.log("displayViewGraph");
	console.log(pairs);
	console.log(transforms);

	var displaySize = 500;
	var displayPadding = 20;
	var displayWidth = displaySize - displayPadding*2.0;
	var displayHeight = displaySize - displayPadding*2.0;
	var offset2D = new V2D(displaySize*0.5,displaySize*0.5);
	// new V2D(displayPadding + displayWidth*0.5, displayPadding + displayHeight*0.5);
	// console.log("offset2D: "+offset2D);

	var centers = [];
	var normals = [];
	var forwards = [];
	var plus = new V3D(0,0,1);
	var zero = new V3D(0,0,0);
	var validCenters = [];
	var validForwards = [];
	var validIndexes = [];
	for(var i=0; i<transforms.length; ++i){
		var transform = transforms[i];
		if(!transform){
			transform = new Matrix(4,4).identity();
		}	
		var o, z, normal;
		if(false){
			o = null;
			z = null;
			normal = null;
		}else{
			o = transform.multV3DtoV3D(zero);
			z = transform.multV3DtoV3D(plus);
			normal = V3D.sub(z,o);
		}
		if(o){
			validCenters.push(o);
			validForwards.push(z);
			validIndexes.push(i);
		}
		centers.push(o);
		normals.push(normal);
		forwards.push(z);
	}
	var plane = Code.planeFromPoints3D(validCenters);
	var planeCenter = plane["point"];
	var planeNormal = plane["normal"];
	var centers2D = Code.projectPointsTo2DPlane(validCenters,planeCenter,planeNormal);
	var forwards2D = Code.projectPointsTo2DPlane(validForwards,planeCenter,planeNormal);
	var normals2D = [];
	for(var i=0; i<centers2D.length; ++i){
		var c2D = centers2D[i];
		var f2D = forwards2D[i];
		var n2D = V2D.sub(f2D,c2D);
		normals2D[i] = n2D;
	}

	var info2D = V2D.infoArray(centers2D);
	var size2D = info2D["size"];
	var origin2D = info2D["center"];
	var scaleToDisplay = Math.min(displayWidth/size2D.x, displayHeight/size2D.y);

	var transformTo2D = new Matrix2D();
		transformTo2D.identity();
		transformTo2D.translate(-origin2D.x,-origin2D.y);
		transformTo2D.scale(scaleToDisplay);
		transformTo2D.translate(offset2D.x,offset2D.y);

	// bounding:
	var display = new DO();
	// display.graphics().setLine(2.0,0xFF000000);
	// display.graphics().beginPath();
	// display.graphics().drawRect(0,0,displaySize,displaySize);
	// display.graphics().endPath();
	// display.graphics().strokeLine();

	var normalSize = 25.0;
	// var cameraSize = 5.0;
	var cameraSize = 2.0;
	var centersDisplay2D = [];
	for(var i=0; i<centers2D.length; ++i){
		var center2D = centers2D[i];
		if(!center2D){
			continue;
		}
		// var p2D = center2D.copy().sub(origin2D).scale(scaleToDisplay).add(offset2D);
		var p2D = transformTo2D.multV2DtoV2D(center2D);
		centersDisplay2D.push(p2D);
		// center:
		display.graphics().setLine(1.0,0xFF000000);
		display.graphics().setFill(0xFFFF0000);
		display.graphics().beginPath();
		display.graphics().drawCircle(p2D.x,p2D.y, cameraSize);
		display.graphics().endPath();
		display.graphics().fill();
		display.graphics().strokeLine();
		// normal:
		var n2D = normals2D[i];
		n2D.norm().scale(normalSize);
		// var n2D = V3D.perpendicularComponent(base,normal2D);
		display.graphics().setLine(1.0,0xFF000000);
		display.graphics().beginPath();
		display.graphics().moveTo(p2D.x,p2D.y);
		display.graphics().lineTo(p2D.x+n2D.x,p2D.y+n2D.y);
		display.graphics().endPath();
		display.graphics().strokeLine();
		var show = i+"";
		if(groupIDs){
			show = groupIDs[i]+"";
		}
		var text = new DOText(show, 16, DOText.FONT_ARIAL, 0xFF990099, DOText.ALIGN_CENTER);
		// text.matrix().scale(1,-1);
		text.matrix().translate(p2D.x, p2D.y-20.0);
		display.addChild(text);

	}

	// min & max errors:
	var errors = [];
	for(var i=0; i<pairs.length; ++i){
		var pair = pairs[i];
		errors.push(pair[ pairs.length-1 ]);
	}
	var info = Code.infoArray(errors);
	var minError = info["min"];
	// console.log(info);
	for(var i=0; i<pairs.length; ++i){ // this is only useful with scales not so 
// break;
		var pair = pairs[i];
		var a = pair[0];
		var b = pair[1];
		//
		var fwd = pair[2];
		var error = pair[3];
		var bak = Matrix.inverse(fwd); // i
		var err = error/minError;

		// show would-be points:
		var ta = transforms[a];
		var tb = transforms[b];
		// depends on if relative or if extrinsic
		// var nb = Matrix.mult(fwd,ta);
		// var na = Matrix.mult(bak,tb);
		// var nb = Matrix.mult(bak,ta);
		// var na = Matrix.mult(fwd,tb);


		// var ia = Matrix.inverse(ta);
		// var ib = Matrix.inverse(tb);

		// var nb = Matrix.mult(fwd,ta); // NO
		// var na = Matrix.mult(bak,tb);

		// var nb = Matrix.mult(fwd,ia); // NO
		// var na = Matrix.mult(bak,ib);

		// fwd = Matrix.mult(ia,fwd);
		// bak = Matrix.mult(ib,bak);
		// fwd = Matrix.mult(fwd,ia);
		// bak = Matrix.mult(bak,ib);
		var nb = Matrix.mult(fwd,ta);
		var na = Matrix.mult(bak,tb);
		// var nb = Matrix.mult(ta,fwd);
		// var na = Matrix.mult(tb,bak);

							// absA = Matrix.inverse(newOriginR);
							// absB = Matrix.mult(relAB, absA);
							// extB = Matrix.inverse(absB);

		// var ns = [na,nb];
		// var ts = [ta,tb];
		var ts = [na,nb];
		var as = [ta,tb];

// console.log(fwd);
// console.log(bak);
// console.log(ta);
// console.log(tb);
// throw "?"
// console.log(na,nb,ta,tb);

		for(var j=0; j<ts.length; ++j){
break;
			var c3D = ts[j].multV3DtoV3D(new V3D(0,0,0));
			var p2D = Code.projectTo2DPlane(c3D.copy(),planeCenter,planeNormal);
			p2D = transformTo2D.multV2DtoV2D(p2D);
			// center:
			display.graphics().setLine(1.0,0xFF999999);
			display.graphics().setFill(0x66CCCCCC);
			display.graphics().beginPath();
			// display.graphics().drawCircle(p2D.x,p2D.y, cameraSize*err);
			display.graphics().drawCircle(p2D.x,p2D.y, 10.0);
			display.graphics().endPath();
			display.graphics().fill();
			display.graphics().strokeLine();


var c3D = as[j].multV3DtoV3D(new V3D(0,0,0));
var o2D = Code.projectTo2DPlane(c3D.copy(),planeCenter,planeNormal);
	o2D = transformTo2D.multV2DtoV2D(o2D);

			display.graphics().setLine(1.0,0xCC990000);
			display.graphics().beginPath();
			display.graphics().moveTo(o2D.x,o2D.y);
			display.graphics().lineTo(p2D.x,p2D.y);
			display.graphics().endPath();
			display.graphics().fill();
			display.graphics().strokeLine();

		}
		







		var p2DA = centersDisplay2D[a];
		var p2DB = centersDisplay2D[b];
		display.graphics().setLine(2.0,colorLine);
		display.graphics().beginPath();
		display.graphics().moveTo(p2DA.x,p2DA.y);
		display.graphics().lineTo(p2DB.x,p2DB.y);
		display.graphics().endPath();
		display.graphics().strokeLine();

		var c2D = V2D.avg(p2DA,p2DB);

		// var text = new DOText(Code.fixed(""+err,5), 16, DOText.FONT_ARIAL, 0xFF990099, DOText.ALIGN_CENTER);
		// // text.matrix().scale(1,-1);
		// text.matrix().translate(c2D.x, c2D.y);
		// display.addChild(text);
	}
	
	
	// display.matrix().scale(1,-1);
	// display.matrix().translate(0,displaySize);
	var off = new V2D(300+offsetX, 100);
	GLOBALSTAGE.addChild(display);
	// display.matrix().translate(300,100);
	display.matrix().translate(off.x,off.y);

	return {"points":centersDisplay2D, "offset":off};
}




function classesLoadedFxn_Q(){
	var m;

	m = new Matrix3D(); m.rotateZ(Code.radians(-10.0)); m.rotateX(Code.radians(-20.0));  m.rotateY(Code.radians( 10.0));
	var A = m;

	m = new Matrix3D(); m.rotateZ(Code.radians(25.0)); m.rotateX(Code.radians(-10.0));  m.rotateY(Code.radians( 50.0));
	var B = m;


	var quaternionA = V4D.qFromMatrix(A);
	var quaternionB = V4D.qFromMatrix(B);

	var quaternionInvA = quaternionA.copy().qInverse();
	var quaternionInvB = quaternionB.copy().qInverse();

	// var quaternionAB = V4D.qMul(quaternionInvA,quaternionB);
	var quaternionAB = V4D.qMul(quaternionB, quaternionInvA);
	var quaternionBA = V4D.qMul(quaternionA,quaternionInvB);

	var p = new V3D(0,0,1);
	//console.log("A:  "+quaternionA.qRotatePoint(p));
	console.log("B:  "+quaternionB.qRotatePoint(p));
	console.log("B2: "+ quaternionAB.qRotatePoint( quaternionA.qRotatePoint(p) ) );




	console.log("++++++++++++++++++++++++++++++++++++++++++++++++++");





	// throw "..."

	// var AB = Matrix3D.relative(A,B);
	// var BA = Matrix3D.relative(B,A);

	A = A.toMatrix();
	B = B.toMatrix();

	var invA = Matrix.inverse(A);
	var invB = Matrix.inverse(B);

	// var AB = Matrix.relative(A,B);
	// var BA = Matrix.relative(B,A);



	var AB = Matrix.mult(B,invA);
	var BA = Matrix.mult(A,invB);



	/// .............................................................


	// console.log("A:\n"+A);
	// console.log("B:\n"+B);
	// console.log("AB:\n"+AB);

	var p = new V3D(0,0,1);

	var pA = A.multV3DtoV3D(p);
	var pB = B.multV3DtoV3D(p);
	var pAB = AB.multV3DtoV3D(p);
	var pBA = BA.multV3DtoV3D(p);

	console.log("A:  "+pA);
	console.log("B:  "+pB);
	console.log("AB: "+pAB);
	console.log("BA: "+pBA);
console.log("..........");
	var qA = BA.multV3DtoV3D(pB);
	var qB = AB.multV3DtoV3D(pA);

	console.log("qA: "+qA);
	console.log("qB: "+qB);


	var pseudoB = Matrix.mult(AB,A);
	var pseudoA = Matrix.mult(BA,B);
	console.log("pA :"+ pseudoA.multV3DtoV3D(p) );
	console.log("pB :"+ pseudoB.multV3DtoV3D(p) );


console.log("..........");
	console.log(" original? :"+  BA.multV3DtoV3D(AB.multV3DtoV3D(p)) );





// var AB = Matrix.mult(B,invA);
// var BA = Matrix.mult(A,invB);

// var AB = Matrix.mult(invA,B);
// var BA = Matrix.mult(invB,A);

// vectorTwistFromQuaternion
	// var twistA = Code.vectorTwistFromQuaternion( V4D.qFromMatrix(A) );
	// var twistB = Code.vectorTwistFromQuaternion( V4D.qFromMatrix(B) );
console.log("TWISTS ")
	// var twistAB = Code.vectorTwistFromQuaternion( V4D.qFromMatrix(AB) );
	// var twistBA = Code.vectorTwistFromQuaternion( V4D.qFromMatrix(BA) );

	var twistAB = Code.vectorTwistFromMatrix3D( AB );
	var twistBA = Code.vectorTwistFromMatrix3D( BA );
	
	// console.log(twistA);
	// console.log(twistB);
	console.log(twistAB);
	console.log(twistBA);
	console.log(twistAB["angle"]);
	console.log(twistBA["angle"]);
	console.log(twistAB["direction"]);
	console.log(twistBA["direction"]);
	console.log(".............. inverse ...");
	var invAB = Code.vectorTwistInverse( twistAB );
	console.log(invAB["angle"]);
	console.log(invAB["direction"]);


	var qAB = Code.quaternionFromVectorTwist(twistAB);
	var qBA = Code.quaternionFromVectorTwist(twistBA);


	// console.log(" fwd/rev :"+ qBA.qRotatePoint( qAB.qRotatePoint( new V3D(1,0,0) ) ) );
	console.log(" fwd/rev :"+ qBA.qRotatePoint( qAB.qRotatePoint( new V3D(0,0,1) ) ) );



	setupDisplay();
	var displayScale = 50.0;
	var displayOffX = 600;
	var displayOffY = 600;
	var drawLine = function(pointA, pointB, color){
		var lineThick = 2.0;
		color = Code.valueOrDefault(color, 0xFFFF0000);

		var d = new DO();
			d.graphics().setLine(lineThick, color);
			d.graphics().beginPath();
			d.graphics().moveTo(pointA.x*displayScale,-pointA.y*displayScale);
			d.graphics().lineTo(pointB.x*displayScale,-pointB.y*displayScale);
			d.graphics().endPath();
			d.graphics().strokeLine();
		GLOBALSTAGE.addChild(d);
		d.matrix().translate(0 + displayOffX, 0 + displayOffY);
	}


	drawLine(new V2D(0,0), twistAB["direction"],  0xFFFF0000);
	drawLine(new V2D(0,0), twistBA["direction"],  0xFF0000FF);



	throw "done"
}

function classesLoadedFxn_X(){
	setupDisplay();
	// plot fwd & bak relative rotation matrices

	var m;

	m = new Matrix3D(); m.rotateZ(Code.radians(0.0)); m.rotateX(Code.radians(0.0));  m.rotateY(Code.radians( 0.0));
	var matrixO = m.toMatrix();

	m = new Matrix3D(); m.rotateZ(Code.radians(20.0)); m.rotateX(Code.radians(0.0));  m.rotateY(Code.radians(50.0));
	var matrixA = m.toMatrix();

	// m = new Matrix3D(); m.rotateZ(Code.radians(-20.0)); m.rotateX(Code.radians(10.0));  m.rotateY(Code.radians(-20.0));
	m = new Matrix3D(); m.rotateZ(Code.radians(20.0)); m.rotateX(Code.radians(0.0));  m.rotateY(Code.radians(0.0));
	var matrixB = m.toMatrix();



	var inverseA = Matrix.inverse(matrixA);
	// var matrixAB = Matrix.mult(matrixB,inverseA);
	var matrixAB = Matrix.mult(inverseA,matrixB);



	var cameraMatrix = new Matrix(4,4);
	var cameraRotationZ = Code.radians(0.0);
	var cameraRotationX = Code.radians(45.0);
	var cameraRotationY = Code.radians(45.0);
	var cameraTranslation = new V3D(0,0,10);
	


	var displayScale = 1.0;
	var displayOffX = 10;
	var displayOffY = 10;

	var screenWidth = 1000;
	var screenHeight = 800;

	var f = 2000;
	var cameraK = new Matrix(3,3).fromArray([f,0, screenWidth*0.5, 0,f, screenHeight*0.5, 0,0,1]);

	var projectPoint = function(p){
		// console.log(cameraMatrix+"")
		var local3D = cameraMatrix.multV3DtoV3D(new V3D(), p);
		// console.log(local3D+"")
		if(local3D.z>0){
			// console.log(local3D+"")
			var projected3D = cameraK.multV3DtoV3D(new V3D(), local3D);
			var image3D = new V3D(projected3D.x/projected3D.z,projected3D.y/projected3D.z,projected3D.z);
			// var screen3D = camera.applyDistortion(new V2D(), image3D);
			var screen3D = image3D;
			var point = new V3D(screen3D.x,screen3D.y,image3D.z);
			// console.log(point+"")
			if(0<=point.x && point.x<screenWidth){
				if(0<=point.y && point.y<screenHeight){
					return point;
				}
			}
		}
		return null;
	}
	var drawLine = function(pointA, pointB, color, lineThick){
		// console.log("drawLine: "+pointA+" - "+pointB);
		if(!pointA || !pointB){
			return;
		}
		lineThick = Code.valueOrDefault(lineThick,2.0);
		color = Code.valueOrDefault(color, 0xFFFF0000);

		var d = new DO();
			d.graphics().setLine(lineThick, color);
			d.graphics().beginPath();
			d.graphics().moveTo(pointA.x*displayScale,pointA.y*displayScale);
			d.graphics().lineTo(pointB.x*displayScale,pointB.y*displayScale);
			d.graphics().endPath();
			d.graphics().strokeLine();
		GLOBALSTAGE.addChild(d);
		// d.matrix().translate(0 + displayOffX, 0 + displayOffY);
	}
	var displayAxes = function(matrix, colorX,colorY,colorZ,lineThick){
		colorX = Code.valueOrDefault(colorX,0xFFFF0000);
		colorY = Code.valueOrDefault(colorY,0xFF0000CC);
		colorZ = Code.valueOrDefault(colorZ,0xFF00CC00);
		lineThick = Code.valueOrDefault(lineThick,2.0);

		var o = new V3D(0,0,0);
		var x = new V3D(1,0,0);
		var y = new V3D(0,1,0);
		var z = new V3D(0,0,1);
		
		o = matrix.multV3DtoV3D(o);
		x = matrix.multV3DtoV3D(x);
		y = matrix.multV3DtoV3D(y);
		z = matrix.multV3DtoV3D(z);

		o = projectPoint(o);
		x = projectPoint(x);
		y = projectPoint(y);
		z = projectPoint(z);

		
		drawLine(o,x, colorX,lineThick);
		drawLine(o,y, colorY,lineThick);
		drawLine(o,z, colorZ,lineThick);
	}

	var drawScene = function(){
		console.log("drawScene")
		var m = new Matrix(4,4);
		m.identity();
		m = Matrix.transform3DRotateZ(m, cameraRotationZ);
		m = Matrix.transform3DRotateX(m, cameraRotationX);
		m = Matrix.transform3DRotateY(m, cameraRotationY);
		m = Matrix.transform3DTranslate(m, cameraTranslation.x,cameraTranslation.y,cameraTranslation.z);
		cameraMatrix.copy(m);

		GLOBALSTAGE.removeAllChildren();


		// displayAxes(matrixO,null,null,null, 1.0);
		// displayAxes(matrixA,null,null,null, 3.0);
		// displayAxes(matrixB,null,null,null, 3.0);
		// displayAxes(matrixAB,null,null,null, 5.0);

		displayAxes(matrixO,null,null,null, 1.0);
		displayAxes(matrixAB,null,null,null, 5.0);

		// displayAxes(matrixA,null,null,null, 1.0);
		// displayAxes(matrixB,null,null,null, 5.0);

		var origin = new V3D();
		var origin = projectPoint(origin);

		var color = 0xFF000000;

		var p = new V3D(0,0,1);
		var pA = matrixA.multV3DtoV3D(p);
		var pB = matrixB.multV3DtoV3D(p);

		var quaternionA = V4D.qFromMatrix(matrixA);
		var quaternionB = V4D.qFromMatrix(matrixB);

		var twistA = Code.vectorTwistFromQuaternion(quaternionA);
		var twistB = Code.vectorTwistFromQuaternion(quaternionB);


		var percents = [0.5,0.5];
		var directions = [twistA["direction"],twistB["direction"]];
		var angles = [twistA["angle"],twistB["angle"]];

		var direction = Code.averageAngleVector3D(directions, percents);
		var angle  = Code.averageAngles(angles, percents);

		var twistAvg = {"direction":direction, "angle":angle};
		console.log(twistAvg);
		var q = Code.quaternionFromVectorTwist(twistAvg);
		var m = q.qMatrix().toMatrix();
		console.log(""+m);
		var pM = m.multV3DtoV3D(p);

		/*
		displayAxes(m, 0xFF660000, 0xFF000066, 0xFF006600, 5.0);
		drawLine(origin,projectPoint(pA), color, 3.0);
		drawLine(origin,projectPoint(pB), color, 3.0);
		drawLine(origin,projectPoint(pM), color, 5.0);
		*/

		// var qA = Code.quaternionFromVectorTwist();

	}

	var handleKeyboardDownFxn = function(e){
		var angle = Code.radians(10.0);
		if(e.keyCode==Keyboard.KEY_LF){
			cameraRotationY -= angle;
		}else if(e.keyCode==Keyboard.KEY_RT){
			cameraRotationY += angle;
		}else if(e.keyCode==Keyboard.KEY_DN){
			cameraRotationX -= angle;
		}else if(e.keyCode==Keyboard.KEY_UP){
			cameraRotationX += angle;
		}

		drawScene();
	}
	var keyboard = new Keyboard();
	keyboard.addFunction(Keyboard.EVENT_KEY_DOWN,handleKeyboardDownFxn,this);
	keyboard.addListeners();

	drawScene();

	throw "test relative"

}


function classesLoadedFxn_TEST(){
	setupDisplay();
	// counts 1D
	console.log("UNDERSTANDING RELATIVE POSITIONS IN RELATIVE MATRIX");


	var posA = new V2D(3,3);
	var posB = new V2D(9,4);
	var angA = Code.radians(-45);
	var angB = Code.radians(30);

	var matI = new Matrix2D();

	var matA = new Matrix2D();
		matA.rotate(angA);
		matA.translate(posA.x,posA.y);

	var matB = new Matrix2D();
		matB.rotate(angB);
		matB.translate(posB.x,posB.y);

	
	var invA = Matrix2D.inverse(matA);
	var invB = Matrix2D.inverse(matB);

	// var matAB = Matrix2D.relative(matB,matA);


	// no idea what this is
	var matAB = Matrix2D.relative(new Matrix2D(), matA,matB);


	// var matAB = Matrix2D.mult(matB,invA);
	var matAB = Matrix2D.mult(invA,matB);

	var matBA = Matrix2D.mult(invB,matA);

	// console.log("A:\n"+matA);
	// console.log("B:\n"+matB);
	// console.log("AB:\n"+matAB);


	// DISPLAY WORLD:
var displayScale = 50.0;
var displayOffX = 600;
var displayOffY = 600;
// var displayNorm = 0.5;


		// var d = new DO();
		// 	d.graphics().clear();
		// 	d.graphics().setFill(0xFFCC0000);
		// 	d.graphics().beginPath();
		// 	d.graphics().drawCircle(p.x*displayScale,p.y*displayScale, 5.0);
		// 	d.graphics().endPath();
		// 	d.graphics().fill();

		// var matrix = matI;
		var drawAxis = function(matrix, colorX, colorY){
			var lineThick = 4.0;
			colorX = Code.valueOrDefault(colorX, 0xFFCC0000);
			colorY = Code.valueOrDefault(colorY, 0xFF0000CC);

			var o = matrix.multV2DtoV2D(new V2D(0,0));
			var x = matrix.multV2DtoV2D(new V2D(1,0));
			var y = matrix.multV2DtoV2D(new V2D(0,1));

			var d = new DO();
				d.graphics().setLine(lineThick, colorX);
				d.graphics().beginPath();
				d.graphics().moveTo(o.x*displayScale,-o.y*displayScale);
				d.graphics().lineTo(x.x*displayScale,-x.y*displayScale);
				d.graphics().endPath();
				d.graphics().strokeLine();

				d.graphics().setLine(lineThick, colorY);
				d.graphics().beginPath();
				d.graphics().moveTo(o.x*displayScale,-o.y*displayScale);
				d.graphics().lineTo(y.x*displayScale,-y.y*displayScale);
				d.graphics().endPath();
				d.graphics().strokeLine();

			GLOBALSTAGE.addChild(d);
			d.matrix().translate(0 + displayOffX, 0 + displayOffY);
		}
		var drawLine = function(pointA, pointB, color){
			var lineThick = 2.0;
			color = Code.valueOrDefault(color, 0xFFFF0000);

			var d = new DO();
				d.graphics().setLine(lineThick, color);
				d.graphics().beginPath();
				d.graphics().moveTo(pointA.x*displayScale,-pointA.y*displayScale);
				d.graphics().lineTo(pointB.x*displayScale,-pointB.y*displayScale);
				d.graphics().endPath();
				d.graphics().strokeLine();
			GLOBALSTAGE.addChild(d);
			d.matrix().translate(0 + displayOffX, 0 + displayOffY);
		}
		var cInvX = 0xFFCC0099;
		var cInvY = 0xFF006699;

		var cRelX = 0xFFCCCCCC;
		var cRelY = 0xFF333333;

		drawAxis(matI);
		drawAxis(matA);
		drawAxis(matB);

		drawAxis(invA, cInvX, cInvY);
		drawAxis(invB, cInvX, cInvY);

		drawAxis(matAB, cRelX, cRelY);
		drawAxis(matBA, cRelX, cRelY);

		var info1 = Code.relativeComponentsFromMatrixes2D(matA.toMatrix(),matB.toMatrix());
		var info2 = Code.relativeComponentsFromMatrixes2D(matI.toMatrix(),matAB.toMatrix());

		console.log(info1);
		console.log(info2);

		var info3 = Code.relativeComponentsFromMatrixes2D(matB.toMatrix(),matA.toMatrix());
		var info4 = Code.relativeComponentsFromMatrixes2D(matI.toMatrix(),matBA.toMatrix());

		console.log(info3);
		console.log(info4);


		// DO SOME DRAWLING
		// drawLine( matA.multV2DtoV2D() );

		var cLinO = 0xFF00CC00;
		var cLinFwd = 0xFFCCCC00;
		var cLinRev = 0xFF00CCCC;


		drawLine( new V2D(0,0), matA.multV2DtoV2D(new V2D(0,0)), cLinO );
		drawLine( new V2D(0,0), matB.multV2DtoV2D(new V2D(0,0)), cLinO );

		drawLine( new V2D(0,0), matAB.multV2DtoV2D(new V2D(0,0)), cLinFwd );

		drawLine( new V2D(0,0), matBA.multV2DtoV2D(new V2D(0,0)), cLinRev );




		// drawAxis(matAB);

	throw "done";
}
/*
	var invA = Matrix.inverse(absA);
	var relativeAtoB = Matrix.mult(absB,invA);
	return relativeAtoB;
*/
function classesLoadedFxn_GRAPH(){
	setupDisplay();
	// counts 1D
/*
	console.log("--- counts 1D");
	//              0     1    2    3    4     5    6    7
	var counts = [1.0, 1.25, 2.5, 4.4, 10.0, 3.0, 2.0, 1.0];
	var edges = [ [0,1], [0,2], [1,3], [2,4], [2,5], [3,4], [4,5], [5,6], [5,7], [6,7] ];
	var errorMagnitude = 0.1;
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var error = errorMagnitude*Math.random();
		var delta = error*(Math.random()-0.5);
		var valueA = counts[edge[0]];
		var valueB = counts[edge[1]];
		var valueAB = valueB - valueA;
			valueAB += delta;
		edge[2] = valueAB;
		edge[3] = error;
	}
	var min = Code.min(counts);
	var result = Code.graphAbsoluteFromRelative1D(edges);
	var values = result["values"];
	for(var i=0; i<counts.length; ++i){
		console.log(" "+i+" : "+counts[i]+" =?= "+(values[i] + min));
	}


	// scales 1D
	console.log("--- scales 1D");
	//              0     1    2    3    4     5    6    7
	var scales = [1.0, 1.25, 2.5, 4.4, 10.0, 3.0, 2.0, 1.0];
	var edges = [ [0,1], [0,2], [1,3], [2,4], [2,5], [3,4], [4,5], [5,6], [5,7], [6,7] ];
	var errorMagnitude = 0.1;
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var error = errorMagnitude*Math.random();
		var delta = error*(Math.random()-0.5);
		var valueA = counts[edge[0]];
		var valueB = counts[edge[1]];
		var valueAB = Math.log(valueB/valueA) + delta;
			valueAB = Math.exp(valueAB);
			valueAB = Math.log(valueAB); // LOG SPACE
		edge[2] = valueAB;
		edge[3] = error;
	}
	var min = Code.min(scales);
	var result = Code.graphAbsoluteFromRelative1D(edges);
	var values = result["values"];
	for(var i=0; i<scales.length; ++i){
		console.log(" "+i+" : "+scales[i]+" =?= "+(Math.exp(values[i])) );
	}

	// positions 2D
	console.log("--- positions 2D");
	//                         0             1             2             3             4             5             6             7
	var positions = [new V2D(1,2), new V2D(3,5), new V2D(4,1), new V2D(6,2), new V2D(5,4), new V2D(7,7), new V2D(6,2), new V2D(5,0) ];
	var edges = [ [0,1], [0,2], [1,3], [2,4], [2,5], [3,4], [4,5], [5,6], [5,7], [6,7] ];
	var errorMagnitude = 0.1;
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var error = errorMagnitude*Math.random();
		var delta = V2D.random(error);
		var valueA = positions[edge[0]];
		var valueB = positions[edge[1]];
		var valueAB = V2D.sub(valueB,valueA);
			valueAB.add(delta);
		edge[2] = valueAB;
		edge[3] = error;
	}
	var result = Code.graphAbsoluteFromRelativeV2D(edges);
	var values = result["values"];
	var min = V2D.sub(values[0],positions[0]);
	for(var i=0; i<positions.length; ++i){
		console.log(" "+i+" : "+positions[i]+" =?= "+V2D.sub(values[i],min) );
	}

	// positions 3D
	var positions = [new V3D(1,2,0), new V3D(3,5,1), new V3D(4,1,2), new V3D(6,2,1), new V3D(5,4,0), new V3D(7,7,2), new V3D(6,2,0), new V3D(5,0,3) ];
	var edges = [ [0,1], [0,2], [1,3], [2,4], [2,5], [3,4], [4,5], [5,6], [5,7], [6,7] ];
	var errorMagnitude = 0.0;
	// var errorMagnitude = 0.1;
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var error = errorMagnitude*Math.random();
		var delta = V3D.random(error);
		var valueA = positions[edge[0]];
		var valueB = positions[edge[1]];
		var valueAB = V3D.sub(valueB,valueA);
			valueAB.add(delta);
		edge[2] = valueAB;
		edge[3] = error;
	}
	var result = Code.graphAbsoluteFromRelativeV3D(edges);
	var values = result["values"];
	var min = V3D.sub(values[0],positions[0]);
	for(var i=0; i<positions.length; ++i){
		console.log(" "+i+" : "+V3D.distance( positions[i] , V3D.sub(values[i],min) )+" - "+positions[i]+" =?= "+V3D.sub(values[i],min) );
	}

	// orientations 2D
	console.log("--- angles 2D");
	//                          0                 1                  2                 3                  4                 5                 6                 7
	var angles = [Code.radians(10), Code.radians(-20), Code.radians(30), Code.radians(50), Code.radians(-10), Code.radians(25), Code.radians(10), Code.radians(20)];
	var edges = [ [0,1], [0,2], [1,3], [2,4], [2,5], [3,4], [4,5], [5,6], [5,7], [6,7] ];
	var errorMagnitude = 0.1;
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var error = errorMagnitude*Math.random();
		var delta = error*(Math.random()-0.5);
		var valueA = angles[edge[0]];
		var valueB = angles[edge[1]];
		var valueAB = Code.angleDirection(valueA,valueB);
			valueAB += delta;
		edge[2] = valueAB;
		edge[3] = error;
	}
	var result = Code.graphAbsoluteFromRelativeAngle2D(edges);
	var values = result["values"];
	var min = Code.angleDirection(angles[0],values[0]);
	console.log(min);
	for(var i=0; i<angles.length; ++i){
		console.log(" "+i+" : "+Code.degrees(Code.angleZeroTwoPi(angles[i]))+" =?= "+Code.degrees(Code.angleZeroTwoPi(values[i]-min)) );
	}
*/


/*
	// angles 3d
	console.log("--- angles 3D");

	var m, t, q;
// 	m = new Matrix3D(); m.rotateZ(Code.radians(-10.0)); m.rotateX(Code.radians(10.0));  m.rotateY(Code.radians( 10.0));
// 	var same = m;
// // console.log(same+"");
	var orientations = [];
		// m = new Matrix3D(); m.rotateZ(Code.radians(20.0)); m.rotateX(Code.radians(-20.0));  m.rotateY(Code.radians( 20.0)); orientations.push( m ); // 0
		m = new Matrix3D(); m.rotateZ(Code.radians( 20.0)); m.rotateX(Code.radians(-20.0)); m.rotateY(Code.radians( 0.0)); orientations.push( m ); // 0
		m = new Matrix3D(); m.rotateZ(Code.radians(-10.0)); m.rotateX(Code.radians( 10.0)); m.rotateY(Code.radians( 10.0)); orientations.push( m ); // 1
		m = new Matrix3D(); m.rotateZ(Code.radians( 10.0)); m.rotateX(Code.radians( 20.0)); m.rotateY(Code.radians(-10.0)); orientations.push( m ); // 2
		m = new Matrix3D(); m.rotateZ(Code.radians( 25.0)); m.rotateX(Code.radians(-10.0)); m.rotateY(Code.radians( 30.0)); orientations.push( m ); // 3
		m = new Matrix3D(); m.rotateZ(Code.radians( 30.0)); m.rotateX(Code.radians( 30.0)); m.rotateY(Code.radians( 40.0)); orientations.push( m ); // 4
		m = new Matrix3D(); m.rotateZ(Code.radians( 50.0)); m.rotateX(Code.radians( 20.0)); m.rotateY(Code.radians( 20.0)); orientations.push( m ); // 5
		m = new Matrix3D(); m.rotateZ(Code.radians( 30.0)); m.rotateX(Code.radians( 10.0)); m.rotateY(Code.radians( 60.0)); orientations.push( m ); // 6
		m = new Matrix3D(); m.rotateZ(Code.radians( 10.0)); m.rotateX(Code.radians( 30.0)); m.rotateY(Code.radians( 50.0)); orientations.push( m ); // 7
	var edges = [ [0,1], [0,2], [1,3], [2,4], [2,5], [3,4], [4,5], [5,6], [5,7], [6,7] ];
	var errorMagnitude = 0.0;
	// var errorMagnitude = 0.1;
	// var errorMagnitude = 0.5;
	// var errorMagnitude = 1.0;
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var error = 1;
		var valueA = orientations[edge[0]];
		var valueB = orientations[edge[1]];
			valueA = valueA.toMatrix();
			valueB = valueB.toMatrix();
			// var inverseA = Matrix.inverse(valueA);
			// var valueAB = Matrix.mult(inverseA,valueB);
			var valueAB = Matrix.relativeReference(valueA,valueB);
		// if(false){
		if(true){
			error = errorMagnitude*Math.random();
			var delta = error*(Math.random()-0.5);
			var q = new V4D();
				q.qIdentity();
			var v = new V3D();
				v.random(2,2,2);
				v.norm();
				q.qRotateDir(v.x,v.y,v.z, delta);
			// apply error
			var m = q.qMatrix();
				m = m.toMatrix();
			valueAB = Matrix.mult(valueAB,m);
		}
		edge[2] = valueAB;
		edge[3] = error;
	}
	console.log(edges);

	var result = Code.graphAbsoluteFromRelativeAngle3D(edges);
	var values = result["values"];

	// CONVERT:
	for(var i=0; i<orientations.length; ++i){
		var a = orientations[i];
		var b = values[i];

		orientations[i] = a.toMatrix();
		// values[i] = b.toMatrix();
	}

	// what are the errors in angles between actual and expected ?

	// world twist difference
	var v0 = values[0];
	var o0 = orientations[0];
	// console.log("o0:\n"+o0);
	// console.log("v0:\n"+v0);
	// console.log(v0);
	// console.log(o0);
	var valueA = v0;
	var valueB = o0;
	var vToO = Matrix.relativeWorld(valueA,valueB);
	// console.log("vToO:\n"+vToO);

	for(var i=0; i<orientations.length; ++i){
		var a = orientations[i];
		var b = values[i];
		// OFFSET
		b = Matrix.mult(vToO,b);
		// b = Matrix.mult(b,vToO);
		var p = new V3D(0,0,1);
		// var p = new V3D(0,1,0);
		// var p = new V3D(1,0,0);
		var pA = a.multV3DtoV3D(p);
		var pB = b.multV3DtoV3D(p);

		var diff = V3D.angle(pA,pB);
		console.log(" "+i+" : "+Code.degrees(diff)+" =?= "+pA+" & "+pB);
	}

*/

/*

	// orientations 3d
	console.log("--- orientation 3D");
	//                          0                 1                  2                 3                  4                 5                 6                 7
	var m, t, q;
	var orientations = [];
		m = new Matrix3D(); m.rotateZ(Code.radians( 20.0)); m.rotateX(Code.radians(-20.0)); m.rotateY(Code.radians( 20.0)); m.translate( 0, 0, 0); orientations.push( m ); // 0
		m = new Matrix3D(); m.rotateZ(Code.radians(-10.0)); m.rotateX(Code.radians( 10.0)); m.rotateY(Code.radians( 10.0)); m.translate( 2, 0, 1); orientations.push( m ); // 1
		m = new Matrix3D(); m.rotateZ(Code.radians( 10.0)); m.rotateX(Code.radians( 20.0)); m.rotateY(Code.radians(-10.0)); m.translate( 1, 3, 0); orientations.push( m ); // 2
		m = new Matrix3D(); m.rotateZ(Code.radians( 25.0)); m.rotateX(Code.radians(-10.0)); m.rotateY(Code.radians( 30.0)); m.translate( 4, 2, 2); orientations.push( m ); // 3
		m = new Matrix3D(); m.rotateZ(Code.radians( 30.0)); m.rotateX(Code.radians( 30.0)); m.rotateY(Code.radians( 40.0)); m.translate( 2, 3, 4); orientations.push( m ); // 4
		m = new Matrix3D(); m.rotateZ(Code.radians( 50.0)); m.rotateX(Code.radians( 20.0)); m.rotateY(Code.radians( 20.0)); m.translate( 5, 4, 1); orientations.push( m ); // 5
		m = new Matrix3D(); m.rotateZ(Code.radians( 30.0)); m.rotateX(Code.radians( 10.0)); m.rotateY(Code.radians( 60.0)); m.translate( 6, 7, 4); orientations.push( m ); // 6
		m = new Matrix3D(); m.rotateZ(Code.radians( 10.0)); m.rotateX(Code.radians( 30.0)); m.rotateY(Code.radians( 50.0)); m.translate( 4, 5, 3); orientations.push( m ); // 7
	console.log(orientations)
	var edges = [ [0,1], [0,2], [1,3], [2,4], [2,5], [3,4], [4,5], [5,6], [5,7], [6,7] ];
	var errorMagnitude = 0.0;
	// var errorMagnitude = 0.1;
	// var errorMagnitude = 0.5;
	// var errorMagnitude = 1.0;
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var error = errorMagnitude*Math.random();
		var delta = error*(Math.random()-0.5);
		var valueA = orientations[edge[0]];
		var valueB = orientations[edge[1]];
			valueA = valueA.toMatrix();
			valueB = valueB.toMatrix();
		var valueAB = Matrix.relativeReference(valueA,valueB);
		error = 1.0;
		// random quaternion - orientation
		// if(false){
		// 	var q = new V4D();
		// 		q.qIdentity();
		// 	var v = new V3D();
		// 		v.random(2,2,2);
		// 		v.norm();
		// 		q.qRotateDir(v.x,v.y,v.z, delta);
		// 	// apply error
		// 	var m = q.qMatrix();
		// 		m = m.toMatrix();
		// 	valueAB = Matrix.mult(valueAB,m);
		// }
		edge[2] = valueAB;
		edge[3] = error;
	}


	console.log(edges);
	for(var i=0; i<orientations.length; ++i){
		orientations[i] = orientations[i].toMatrix();
	}
	
	var result = Code.graphAbsoluteFromRelativePose3D(edges, orientations);
	console.log(result);
	var values = result["values"];


	// var min = Code.angleDirection(orientations[0],values[0]);
	// console.log(min);
	// change reference to first location, rotate toward second
	var v0 = values[0];
	var v1 = values[1];
	var v2 = values[2];
	var o0 = orientations[0];
	var o1 = orientations[1];
	var o2 = orientations[2];

	var origin0 = o0.transform3DLocation();
	var origin1 = v0.transform3DLocation();

	var A = origin1.copy();
	var a = origin0.copy();

	var B = v1.transform3DLocation();
	var b = o1.transform3DLocation();

	var C = v2.transform3DLocation();
	var c = o2.transform3DLocation();

// throw "?";
	console.log("to same reference");
	// to origin reference frame
	c.sub(a);
	b.sub(a);
	// a.sub(a);

	C.sub(A);
	B.sub(A);
	// A.sub(A);

	// relative 1
	var directionB = V3D.cross(B,b);
		directionB.norm();
	var angleBA = V3D.angle(B,b);

	console.log("directionBA: "+directionB);
	console.log("angleBA: "+Code.degrees(angleBA));

	B.rotate(directionB,angleBA);
	C.rotate(directionB,angleBA);

	// relative 2
	var normal0 = V3D.cross(b,c);
	var normal1 = V3D.cross(B,C);
	var perp0 = V3D.perpendicularComponent(b,normal0);
		perp0.norm();
	var perp1 = V3D.perpendicularComponent(b,normal1);
		perp1.norm();

	console.log("perp0: "+perp0);
	console.log("perp1: "+perp1);

	var angleBC = V3D.angle(perp1,perp0);
	var normalB = b.copy().norm();
	console.log("normalB: "+normalB);
	console.log("angleBC: "+Code.degrees(angleBC));

	C.rotate(normalB,angleBC);

	console.log("A: "+V3D.distance(a,A));
	console.log("B: "+V3D.distance(b,B));
	console.log("C: "+V3D.distance(c,C));

	var transformWorld = new Matrix(4,4);
		transformWorld.identity();
	// move to 0
		transformWorld = Matrix.transform3DTranslate(transformWorld,-origin1.x,-origin1.y,-origin1.z);
	// rotate along vector 1
		transformWorld = Matrix.transform3DRotate(transformWorld,directionB,angleBA);
	// rotate along vector 2
		transformWorld = Matrix.transform3DRotate(transformWorld,normalB,angleBC);
	// move to origin a
		transformWorld = Matrix.transform3DTranslate(transformWorld,origin0.x,origin0.y,origin0.z);

	console.log("transformWorld: \n "+transformWorld);

	// var offsetRotationWorld = null;
	for(var i=0; i<orientations.length; ++i){
		var orientation = orientations[i];
		var value = values[i];
		var p0 = orientation.transform3DLocation();
		var p1 = value.transform3DLocation();
			p1 = transformWorld.multV3DtoV3D(p1,p1);
		console.log(" "+i+" : "+V3D.distance(p0,p1));
		
		// also show normal directions angular difference

		// console.log(" "+i+" : "+Code.degrees(Code.angleZeroTwoPi(angles[i]))+" =?= "+Code.degrees(Code.angleZeroTwoPi(values[i]-min)) );
	}

*/


	console.log("--- Full Pairs 3D");
	var viewIDs = ["A","B","C","D","E","F","G","H","I","J","K","L"];
	var views = [];
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate(-2,  0,  1); views.push( m ); // 0 - A
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate(-1,  1,0.5); views.push( m ); // 1 - B
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate(-1,  0, -1); views.push( m ); // 2 - C
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate( 2,  0,  0); views.push( m ); // 3 - D
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate( 1,  1,  1); views.push( m ); // 4 - E
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate( 2,1.5, -1); views.push( m ); // 5 - F
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate( 3,  0,  0); views.push( m ); // 6 - G
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate( 2, -1,  1); views.push( m ); // 7 - H
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate( 3, -2,  2); views.push( m ); // 8 - I
		m = new Matrix3D(); m.rotateZ(Code.radians( 0.0)); m.rotateX(Code.radians( 0.0)); m.rotateY(Code.radians( 0.0)); m.translate( 4, -1,  1); views.push( m ); // 9 - J
	var pairs = [
			[0,1],   // 0 - A-B
			[0,2],   // 1 - A-C
			[1,2],   // 2 - B-C
			[2,3],   // 3 - C-D
			[2,4],   // 4 - C-E
			[3,4],   // 5 - D-E
			[4,5],   // 6 - E-F
			[5,6],   // 7 - E-G
			[6,7],   // 8 - G-H
			[7,8],   // 9 - H-I
			[8,9],   // 10- I-J

			// [1,3],	 // 11 - B-D
		];
	var pairScales = [1,2,3,1,2,2,1,2,1,2];
	var triples = [
			// pairID - IS SCALED, pairID - IS SCALED, pairID - IS SCALED, 
			[0,1,  1,1, 2,1],
			[2,1,  3,1, null,0],
		// [2,1, 3,1, 11,1],
			[3,1,  4,1, 5,1],
			[5,1,  6,1, null,0],

			[7,0,  8,0, null,0],
			[8,1,  9,1, null,0],

			[9,1, 10,0, null,0],

			// [2,1, 3,1, 11,1],
		];
	var errorPairs = 0.0;
	var errorScales = 0.0;

	// var errorPairs = 0.1;
	// var errorScales = 0.1;

	// var errorPairs = 0.5;
	// var errorScales = 0.5;

	// var errorPairs = 1.0;
	// var errorScales = 0.5;
	for(var i=0; i<views.length; ++i){
		var transform = views[i];
			transform = transform.toMatrix();
		views[i] = {"id":viewIDs[i], "absolute":transform};
	}
	for(var i=0; i<pairs.length; ++i){
		var pair = pairs[i];
		var vA = pair[0];
		var vB = pair[1];
		var viewA = views[vA];
		var viewB = views[vB];
		var transformA = viewA["absolute"];
		var transformB = viewB["absolute"];
		var pairID = viewA["id"]+"-"+viewB["id"];
		var transformAB = Matrix.relativeReference(transformA,transformB);

		var pairScale = pairScales[i];
		var scale = pairScale;
			transformAB = Matrix.transform3DScale(transformAB,scale);
		var error = 1.0;
		// add error in relative
		// if(false){

		if(true){
			error = Math.random()*errorPairs;
			// roration
			var delta = error*(Math.random()-0.5);
			console.log("errorAngle: "+Code.degrees(delta));
			var q = new V4D();
				q.qIdentity();
			var v = new V3D();
				v.random(2,2,2);
				v.norm();
				q.qRotateDir(v.x,v.y,v.z, delta);
			var m = q.qMatrix();
				m = m.toMatrix();
			transformAB = Matrix.mult(transformAB,m);
			// location
			v.random(2,2,2);
			v.scale(error);
			console.log("errorTransform "+v.length());
			transformAB = Matrix.transform3DTranslate(transformAB,v);
			// scale
			var errorScale = Math.exp( error*(Math.random()-0.5) );
console.log("errorScale: "+errorScale)
			transformAB = Matrix.transform3DScale(transformAB,errorScale);

		}
		pairs[i] = {"id":pairID, "transform":transformAB, "A":viewA, "B":viewB, "scale":scale, "error":error};
	}
	for(var i=0; i<triples.length; ++i){
		var triple = triples[i];
		var sList = {};
		var viewIDs = {};
		// console.log("  "+i+" ...................");

		for(var j=0; j<triple.length; j+=2){
			var pairID = triple[j];
			var scale = triple[j+1];
			if(pairID!==null){
				var pair = pairs[pairID];
					pairID = pair["id"];
				var viewA = pair["A"];
				var viewB = pair["B"];
				var pairScale = pair["scale"];
				viewIDs[viewA["id"]] = viewA;
				viewIDs[viewB["id"]] = viewB;
				if(scale!==0){
					scale = scale * pairScale;
					var error = Math.exp( errorScales*(Math.random()-0.5) );
					scale = scale*error;
					console.log("triple error scale: "+error);
				}
				sList[pairID] = scale;
			}
		}
		var viewKeys = Code.keys(viewIDs);
		viewKeys.sort();
		var vA = viewKeys[0];
		var vB = viewKeys[1];
		var vC = viewKeys[2];
		// pair list
		var pairA = vA+"-"+vB;
		var pairB = vA+"-"+vC;
		var pairC = vB+"-"+vC;
		var pList = [pairA,pairB,pairC];
		// scale lise
		var scaleA = Code.valueOrDefault(sList[pairA],0);
		var scaleB = Code.valueOrDefault(sList[pairB],0);
		var scaleC = Code.valueOrDefault(sList[pairC],0);
		var scales = [scaleA,scaleB,scaleC];
		var tripleID = vA+"-"+vB+"-"+vC;

		triples[i] = {"id":tripleID, "views":viewKeys, "pairs":pList, "scales":scales};
	}
console.log(views);
console.log(pairs);
console.log(triples);
	var viewToID = function(view){
		return view["id"];
	}
	var pairToIDs = function(pair){
		return [pair["A"]["id"],pair["B"]["id"]];
	}
	var tripleToIDs = function(triple){
		return triple["views"];
	}
	var pairToError = function(pair){
		return pair["error"];
	}
	var pairToTransform = function(pair){
		return pair["transform"];
	}
	var tripleToScales = function(triple){
		return triple["scales"];
	}
	
	var absolutes = [];
	for(var i=0; i<views.length; ++i){
		absolutes.push(views[i]["absolute"]);
	}
	var result = Code.graphAbsoluteFromObjectLookup3D(views, pairs, triples, viewToID,pairToIDs,tripleToIDs, pairToError,pairToTransform, tripleToScales, absolutes);

	console.log(result);

throw "???"


	// pose 2D
	console.log("--- pose 2D");
	//                         0             1             2             3             4             5             6             7
	var poses = [];
		m = new Matrix2D(); m.rotate(Code.radians(-20.0));  m.translate(0,0); poses.push(m); // 0
		m = new Matrix2D(); m.rotate(Code.radians(10.0));  m.translate(2,1); poses.push(m); // 1
		m = new Matrix2D(); m.rotate(Code.radians(-10.0)); m.translate(1,1); poses.push(m); // 2
		m = new Matrix2D(); m.rotate(Code.radians(20.0));  m.translate(3,2); poses.push(m); // 3
		m = new Matrix2D(); m.rotate(Code.radians(-20.0)); m.translate(4,3); poses.push(m); // 4
		m = new Matrix2D(); m.rotate(Code.radians(60.0));  m.translate(1,4); poses.push(m); // 5
		m = new Matrix2D(); m.rotate(Code.radians(0.0));  m.translate(3,6); poses.push(m); // 6
		m = new Matrix2D(); m.rotate(Code.radians(10.0));  m.translate(4,5); poses.push(m); // 7
	var edges = [ [0,1], [0,2], [1,3], [2,4], [2,5], [3,4], [4,5], [5,6], [5,7], [6,7] ];
	// var errorMagnitude = 0.1;
	// var errorMagnitude = 0.5;
	// var errorMagnitude = 1.0;
	var errorMagnitude = 2.0;
	for(var i=0; i<edges.length; ++i){
		var edge = edges[i];
		var error = errorMagnitude*Math.random();
		var deltaAngle = 0.5*error*(Math.random()-0.5);
		var deltaPosX = error*(Math.random()-0.5);
		var deltaPosY = error*(Math.random()-0.5);
		var valueA = poses[edge[0]];
		var valueB = poses[edge[1]];
		var valueAB = Matrix2D.relativeReference(valueA,valueB);
		console.log(" "+i+" : "+V2D.sub( valueB.toMatrix().transform2DLocation(),valueA.toMatrix().transform2DLocation() ) + " : "  );
		// apply error
		if(true){
		// if(false){
			var m = new Matrix2D();
				m.rotate(deltaAngle);
				m.translate(deltaPosX,deltaPosY);
			valueAB.mult(m);
		}
		edge[2] = valueAB.toMatrix();
		edge[3] = error;
	}
	


	var displayScale = 100.0;
var displayOffX = 100;
var displayOffY = 50;
var displayNorm = 0.5;//1.0;

	// draw:
	for(var i=0; i<poses.length; ++i){
		var pose = poses[i];

			pose = pose.toMatrix();

		var p = pose.transform2DLocation();
		var a = pose.transform2DRotation();

		var d = new DO();
			d.graphics().clear();
			d.graphics().setFill(0xFFCC0000);
			d.graphics().beginPath();
			d.graphics().drawCircle(p.x*displayScale,p.y*displayScale, 5.0);
			d.graphics().endPath();
			d.graphics().fill();

		var n = new V2D(displayNorm,0).copy().rotate(a).add(p);

			d.graphics().setLine(2.0, 0xFFCC0099);
			d.graphics().beginPath();
			d.graphics().moveTo(p.x*displayScale,p.y*displayScale);
			d.graphics().lineTo(n.x*displayScale,n.y*displayScale);
			d.graphics().endPath();
			d.graphics().strokeLine();

		GLOBALSTAGE.addChild(d);
		d.matrix().translate(0 + displayOffX, 0 + displayOffY);

		var t = new DOText(""+i, 16, DOText.FONT_ARIAL, 0xFFCC0000, DOText.ALIGN_CENTER);
			t.matrix().translate(p.x*displayScale,p.y*displayScale + 20);
		d.addChild(t);


	}

	for(var i=0; i<edges.length; ++i){
// break;
		var edge = edges[i];
		var idA = edge[0];
		var idB = edge[1];
		var mAB = edge[2];
		// mAB = Matrix.inverse(mAB);

		var mA = poses[idA];
		var mB = poses[idB];

		mA = mA.toMatrix();
		mB = mB.toMatrix();

		// mAB = Matrix.relative(mA,mB);
		var invA = Matrix.inverse(mA);
		var mAB = Matrix.mult(invA, mB);
// mAB = Matrix.inverse(mAB);


		var offA = mA.transform2DLocation();
		var angA = mA.transform2DRotation();

		var offB = mB.transform2DLocation();
		var angB = mB.transform2DRotation();


		// console.log("A:\n"+mA+"\n");
		// console.log("B:\n"+mB+"\n");
		// console.log("AB:\n"+mAB+"\n");

			// mAB = mAB.toMatrix();
			
			// mAB = mAB.toMatrix();



			// mA = Matrix.mult(mA, );
		// var mAB = Matrix.relative(mA,mB);
		// var mAB = new Matrix(3,3);
		// 	mAB.identity();
		// 	mAB = Matrix.transform2DRotate(mAB, -angA);
		// 	mAB = Matrix.transform2DTranslate(mAB, V2D.sub(offB,offA));

		var offAB = mAB.transform2DLocation();
		var angAB = mAB.transform2DRotation();





		// var test = new V2D(.5,2);
		// console.log("    -> "+ Matrix.mult(mAB,mA).multV2DtoV2D(test) +"   &   "+mB.multV2DtoV2D(test)  );


/*
		
		// console.log(" "+idA+"-"+idB+" A : "+offAB+"  @  "+Code.degrees(angAB));

		var mAB = new Matrix(3,3);
			mAB.identity();
		// console.log(mAB+"");
			// mAB = Matrix.transform2DRotate(mAB, Code.angleZeroTwoPi(angB-angA) );
			
			mAB = Matrix.transform2DTranslate(mAB, V2D.sub(offB,offA));
			mAB = Matrix.transform2DRotate(mAB, angB );
			mAB = Matrix.transform2DRotate(mAB, -angA );
		// console.log(mAB+"");
			// mAB = Matrix.transform2DRotate(mAB, Code.angleDifference(angB,angA) );
			// mAB = Matrix.transform2DRotate(mAB, Code.angleZeroTwoPi(angB-angA) );
		// console.log(mAB+"");

		var offAB = mAB.transform2DLocation();
		var angAB = mAB.transform2DRotation();

		// console.log(" "+idA+"-"+idB+" B : "+offAB+"  @  "+Code.degrees(angAB));
*/



/*
// throw "?"

		// var t = offAB.copy();
			// t.rotate(-angA);
			// t.rotate(Code.radians(-20));

		// WORKS
		// var t = new V2D();
		// 	t.add(offB);
		// 	t.sub(offA);
		// 	t.rotate(-angA);
		// console.log(" t: "+t);


		var t = new V2D();
			t.add(offAB);
			// t.rotate(angAB);
			// t.add(offA);
			// t.rotate(angAB);
		console.log(" t: "+t);

		var a = new V2D();
			a.copy(offA);


		var b = new V2D(0,0);
			// b.rotate(angAB);
			b.add(t);
			// b.rotate(-angAB);
			b.rotate(angA);

			b.add(offA);

		console.log(" b:  "+b);







		var t = new V2D();
			t.add(offA);
			t.sub(offB);
			t.rotate(-angB);
		console.log(" t: "+t);
		

		var b = new V2D();
			b.copy(offB);

		var a = new V2D(0,0);
			a.add(t);
			a.rotate(angB);
			a.add(offB);

		console.log(" b: "+b);
		console.log(" a: "+a);



*/
		// console.log("????????????????????????????????????????")

// console.log("angA: "+Code.degrees(angA));

		var mI = new Matrix(3,3).identity();
		var result = Code.relativeComponentsFromMatrixes2D(mI,mAB);
		var A = result["A"];
		var B = result["B"];
		console.log(" ID "+idA+" - "+idB+" : "+A["offset"]+" @ "+Code.degrees(A["angle"]));

		var result = Code.relativeComponentsFromMatrixes2D(mA,mB);
		// console.log(result);
		var A = result["A"];
		var B = result["B"];
		console.log(" AB "+idA+" - "+idB+" : "+A["offset"]+" @ "+Code.degrees(A["angle"]));


		var b = V2D.copy(offB);
		var a = B["offset"].copy();
			a.rotate(angB);
			a.add(offB);
		// console.log(" "+b+" -> "+a+" @ "+Code.degrees(Code.angleZeroTwoPi(angB+B["angle"])));


		var a = V2D.copy(offA);
		var b = A["offset"].copy();
			b.rotate(angA);
			b.add(offA);

		// console.log(" "+a+" -> "+b+" @ "+Code.degrees(Code.angleZeroTwoPi(angA+A["angle"])));


		


/*
		// these are 'absolute' translations / rotations --- how to make them relative to the location?

		var mAA = Matrix.mult(mAB,mA);

		var offAA = mAA.transform2DLocation();
		var angAA = mAA.transform2DRotation();
		console.log("angAA: "+Code.degrees(angAA))
		console.log("angA: "+Code.degrees(angA))
		console.log("offAA: "+offAA)

		b = new V2D(0,0);
			b.add(offAB);
			b.rotate(-angA);
			// b.rotate(angAB);
			// b.rotate(-angAA);
			// b.rotate(angA);
			b.add(offA);


			// b.add(1,1);


		var a = new V2D();
			a.copy(offA);
*/


/*

console.log(Code.degrees(angA)+" + "+Code.degrees(angAB)+" =?= "+Code.degrees(angB)+" : "+" .. ");
console.log("   "+offA+" + "+offAB+" =?= "+offB);


var res = Matrix.mult(mAB,mA);
	res = res.multV2DtoV2D(new V2D(0,0));

console.log(" A "+mA.multV2DtoV2D(new V2D(0,0))+" ...");
console.log(" C "+mAB.multV2DtoV2D(new V2D(0,0))+" ...");
console.log(" B "+res+" ...");

// console.log(" ? "+mA.multV2DtoV2D(offAB)+" ...");
// copy().rotate(angAB)
		var a = new V2D();
			a.copy(offA);
		var b = new V2D(0,0);
		console.log(".      0) "+b);
		b = mA.multV2DtoV2D(b);
		console.log(".      1) "+b);
		b = mAB.multV2DtoV2D(b);
		console.log(".      2) "+b);


		b = new V2D(0,0);
		b.add(offA);
		b.rotate(angAB);
		b.add(offAB);

*/


// b = offA.copy().rotate(angAB).add(offAB);

			// b.rotate(angAB);
			// b.rotate(2*angA);
			// b.rotate(angA);
			// b.add(offA);
			//  + angAB
			// b.rotate(angA);
			// b.rotate(angA + angAB);
// b.copy(offB);

// b.copy(res);


		var d = new DO();
			d.graphics().clear();
			d.graphics().setLine(2.0, 0xCC0000CC);
			d.graphics().beginPath();
			d.graphics().moveTo(a.x*displayScale,a.y*displayScale);
			d.graphics().lineTo(b.x*displayScale,b.y*displayScale);
			d.graphics().endPath();
			d.graphics().strokeLine();
		GLOBALSTAGE.addChild(d);
		d.matrix().translate(0 + displayOffX, 0 + displayOffY);



	}
	// throw "huh"
	// Code.graphAbsoluteFromRelativePose2D







	// convert
	for(var i=0; i<poses.length; ++i){
		var pose = poses[i];
			pose = pose.toMatrix();
		var offset = pose.transform2DLocation();
		var angle = pose.transform2DRotation();
		poses[i] = {"offset":offset, "angle":angle};
	}
	var result = Code.graphAbsoluteFromRelativePose2D(edges);
	var values = result["values"];
	var deltas = result["edges"];




		// var n = new V2D(displayNorm,0).copy().rotate(a).add(p);

		// d.graphics().setLine(2.0, 0xFFCC0099);
		// d.graphics().beginPath();
		// d.graphics().moveTo(p.x*displayScale,p.y*displayScale);
		// d.graphics().lineTo(n.x*displayScale,n.y*displayScale);
		// d.graphics().endPath();
		// d.graphics().strokeLine();


	
	// var offsetAngleWorld = values[0]["angle"] - poses[0]["angle"];
	var p0 = poses[0]["offset"];
	var v0 = values[0]["offset"];
	var p1 = poses[1]["offset"];
	var v1 = values[1]["offset"];
	var offsetPositionWorld = V2D.sub(p0, v0);

	// var offsetAngleWorld = values[0]["angle"] - poses[0]["angle"];
	var dV = V2D.sub(v1,v0);
	var dP = V2D.sub(p1,p0);
	var offsetAngleWorld = V2D.angleDirection(dV, dP);

	for(var i=0; i<poses.length; ++i){
		var pose = poses[i];
		var value = values[i];
		// var o = V2D.sub(value["offset"], minOffset);
		// 	o.rotate(-worldAngle);
		// var a = value["angle"];
		// 	a = Code.angleZeroTwoPi(a-worldAngle);
		// Code.degrees(Code.angleZeroTwoPi(angles[i]))
		// Code.degrees(Code.angleZeroTwoPi(values[i]-min)) 
		// console.log(" "+i+" : "+pose["offset"]+" =?= "+o+"              "+Code.degrees(Code.angleZeroTwoPi(pose["angle"]))+" =?="+Code.degrees(Code.angleZeroTwoPi(a)) );

		console.log(" "+i+" : "+Code.degrees(pose["angle"])+" =?= "+Code.degrees(value["angle"]) );

		var offset = value["offset"];
		var angle = value["angle"];
		
		var p = offset.copy();
		p.add(offsetPositionWorld);
		p.rotate(offsetAngleWorld);

		var n = new V2D(displayNorm,0).copy().rotate(angle + offsetAngleWorld).add(p);

		var d = new DO();
			d.graphics().clear();
			d.graphics().setLine(1.0, 0xCC0000CC);
			d.graphics().setFill(0x66660066);
			d.graphics().beginPath();
			d.graphics().drawCircle(p.x*displayScale,p.y*displayScale, 10.0);
			d.graphics().endPath();
			d.graphics().fill();
			d.graphics().strokeLine();


			d.graphics().setLine(2.0, 0xFF009999);
			d.graphics().beginPath();
			d.graphics().moveTo(p.x*displayScale,p.y*displayScale);
			d.graphics().lineTo(n.x*displayScale,n.y*displayScale);
			d.graphics().endPath();
			d.graphics().strokeLine();

		GLOBALSTAGE.addChild(d);
		d.matrix().translate(0 + displayOffX, 0 + displayOffY);






		for(var j=0; j<deltas.length; ++j){
			var delta = deltas[j];
			// console.log(delta);
			var idA = delta[0];
			var idB = delta[1];
			var info = delta[2];
			var error = delta[3];
			//if(idA==i){// && i==0){

			if(idA==i){

				var fwd = info["forward"];

				var b = fwd["offset"].copy().rotate(angle).add(offset);
				var a = Code.angleZeroTwoPi(angle + fwd["angle"] + offsetAngleWorld);

				
					// a += offsetAngleWorld;
					b.add(offsetPositionWorld);
					b.rotate(offsetAngleWorld);

				var d = new DO();
					d.graphics().clear();

					d.graphics().setLine(2.0, 0xFF00CC00);
					d.graphics().beginPath();
					d.graphics().moveTo(p.x*displayScale,p.y*displayScale, 12.0);
					d.graphics().lineTo(b.x*displayScale,b.y*displayScale, 12.0);
					d.graphics().endPath();
					d.graphics().strokeLine();


					d.graphics().setLine(2.0, 0xFF00CC00);
					d.graphics().beginPath();
					d.graphics().drawCircle(b.x*displayScale,b.y*displayScale, 12.0);
					d.graphics().endPath();
					d.graphics().strokeLine();
					GLOBALSTAGE.addChild(d);
					d.matrix().translate(0 + displayOffX, 0 + displayOffY);
			}
		}

	}

	var valuesBefore = result["valuesBefore"];
	if(valuesBefore){
		for(var i=0; i<poses.length; ++i){
			var pose = poses[i];
			var value = valuesBefore[i];
			var offset = value["offset"];
			var angle = value["angle"];
			
			var p = offset.copy();
			p.add(offsetPositionWorld);
			p.rotate(offsetAngleWorld);

			var n = new V2D(displayNorm,0).copy().rotate(angle + offsetAngleWorld).add(p);

			var d = new DO();
				d.graphics().clear();
				d.graphics().setLine(1.0, 0xCCCC0000);
				d.graphics().setFill(0x66660066);
				d.graphics().beginPath();
				d.graphics().drawCircle(p.x*displayScale,p.y*displayScale, 10.0);
				d.graphics().endPath();
				d.graphics().fill();
				d.graphics().strokeLine();


				d.graphics().setLine(2.0, 0xCC990099);
				d.graphics().beginPath();
				d.graphics().moveTo(p.x*displayScale,p.y*displayScale);
				d.graphics().lineTo(n.x*displayScale,n.y*displayScale);
				d.graphics().endPath();
				d.graphics().strokeLine();

			GLOBALSTAGE.addChild(d);
			d.matrix().translate(0 + displayOffX, 0 + displayOffY);

		}
	}



throw "only show absolute angles minus original offset ..."





// ORIGINAL PLACEMENTS:

	/*
	// console.log(values);
	// console.log(poses);
	var minOffset = V2D.sub(values[0]["offset"],poses[0]["offset"]);
	var minAngle = Code.angleDirection(poses[0]["angle"],values[0]["angle"]);
		var angleP01 = V2D.sub(poses[1]["offset"],poses[0]["offset"]);
			// angleP01 = V2D.angleDirection(V2D.DIRX,angleP01);
		var angleV01 = V2D.sub(values[1]["offset"],values[0]["offset"]);
			// angleV01 = V2D.angleDirection(V2D.DIRX,angleV01);
		var worldAngle = V2D.angleDirection(angleP01,angleV01);
	console.log(minOffset);
	console.log(minAngle);
	console.log(worldAngle);

	for(var i=0; i<poses.length; ++i){
		var pose = poses[i];
		var value = values[i];
		var o = V2D.sub(value["offset"], minOffset);
			o.rotate(-worldAngle);
		var a = value["angle"];
			a = Code.angleZeroTwoPi(a-worldAngle);
		// Code.degrees(Code.angleZeroTwoPi(angles[i]))
		// Code.degrees(Code.angleZeroTwoPi(values[i]-min)) 
		console.log(" "+i+" : "+pose["offset"]+" =?= "+o+"              "+Code.degrees(Code.angleZeroTwoPi(pose["angle"]))+" =?="+Code.degrees(Code.angleZeroTwoPi(a)) );
		var p = pose["offset"];



		var p = o;

		var d = new DO();
			d.graphics().clear();
			d.graphics().setLine(1.0, 0xCC0000CC);
			d.graphics().beginPath();
			d.graphics().drawCircle(p.x*displayScale,p.y*displayScale, 10.0);
			d.graphics().endPath();
			d.graphics().strokeLine();
		GLOBALSTAGE.addChild(d);
		d.matrix().translate(0 + displayOffX, 0 + displayOffY);
	}
	
	*/








throw "???"

	// pose 3D
	console.log("--- pose 3D");
	//                         0             1             2             3             4             5             6             7
	



	// m = new Matrix3D(); m.rotateZ(Code.radians(20.0)); m.rotateX(Code.radians(-20.0));  m.rotateY(Code.radians(20.0));
	// console.log(m);
	// q = V4D.qFromMatrix(m);
	// console.log(q);
	// t = Code.vectorTwistFromQuaternion(q);
	// console.log(t);


	throw "...";
}

</script>
<body onload="pageLoadedFxn();">
</body>
</html>
