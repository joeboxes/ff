<html>
<head>
<title>FF Image Match</title>
<script src="../code/FF.js"></script>
<script src="../code/Code.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="match.css" />
<script type="text/javascript">
function pageLoadedFxn(){
	ff = new FF("../code/",defaultClassesLoadedFxn,null,false);
}
function defaultClassesLoadedFxn(){
	var list = ["ColorFloat.js","ColorAngle.js","ColorGradient.js","ColorMatRGBY.js","ImageFeature.js","Match.js"];
	scriptLoader = new ScriptLoader("./",list,this,customClassesLoadedFxn);
	scriptLoader.load();
}
function customClassesLoadedFxn(){
	var match = new Match();
	return;
	var a = new V2D(160,55);
	var b = new V2D(195,215);
	var c = new V2D(145,240);
	var d = new V2D(125,90);
	var width = 150;
	var height = 100;
	var A = new V2D(0,0);
	var B = new V2D(width,0);
	var C = new V2D(width,height);
	var D = new V2D(0,height);

	var fromPoints = new Array(a,b,c,d);
	var toPoints = new Array(A,B,C,D);

	var i, fr, to;
	var len = fromPoints.length;

	var matA = new Matrix(2*len,8);
	var matB = new Matrix(2*len,1);
	for(i=0;i<len;++i){
		fr = fromPoints[i];
		to = toPoints[i];
		matA.set(2*i,0,   fr.x);
		matA.set(2*i,1,   fr.y);
		matA.set(2*i,2,   1);
		matA.set(2*i,3,   0);
		matA.set(2*i,4,   0);
		matA.set(2*i,5,   0);
		matA.set(2*i,6,   -fr.x*to.x);
		matA.set(2*i,7,   -fr.y*to.x);
		matA.set(2*i+1,0, 0);
		matA.set(2*i+1,1, 0);
		matA.set(2*i+1,2, 0);
		matA.set(2*i+1,3, fr.x);
		matA.set(2*i+1,4, fr.y);
		matA.set(2*i+1,5, 1);
		matA.set(2*i+1,6, -fr.x*to.y);
		matA.set(2*i+1,7, -fr.y*to.y);
		matB.set(2*i  ,0, to.x);
		matB.set(2*i+1,0, to.y);
	}
	var x = Matrix.mult(Matrix.pseudoInverse(matA), matB);
	console.log(x.toString());

	var projection = (new Matrix(3,3)).setFromArray([x.get(0,0),x.get(1,0),x.get(2,0), x.get(3,0),x.get(4,0),x.get(5,0), x.get(6,0),x.get(7,0),1]);
	console.log(projection.toString());

	var calcA = new V3D();
	var calcB = new V3D();
	var calcC = new V3D();
	var calcD = new V3D();
	projection.multV2DtoV3D(calcA,a); calcA.x /= calcA.z; calcA.y /= calcA.z;
	projection.multV2DtoV3D(calcB,b); calcB.x /= calcB.z; calcB.y /= calcB.z;
	projection.multV2DtoV3D(calcC,c); calcC.x /= calcC.z; calcC.y /= calcC.z;
	projection.multV2DtoV3D(calcD,d); calcD.x /= calcD.z; calcD.y /= calcD.z;
	console.log( A.toString() );
	console.log( calcA.toString() );
	console.log( "    " );
	console.log( B.toString() );
	console.log( calcB.toString() );
	console.log( "    " );
	console.log( C.toString() );
	console.log( calcC.toString() );
	console.log( "    " );
	console.log( D.toString() );
	console.log( calcD.toString() );

	return;
	
	var i, j, k;
	var m = 4, n = 3, p = 2;
	var A = new Matrix(m,n);
	var B = new Matrix(n,p);
	var C = new Matrix(m,p);
	var b = new Matrix(1,1);
	var x = new Matrix(1,1);
	//A.identity();
	// for(i=0;i<m;++i){

	// }
	//A.setSize(3,3).setFromArray([1,3,4, 2,4,5, 4,3,0]);
	//A.setSize(3,5).setFromArray([1,2,3,4,5, 3,6,9,1,1, 2,5,4,0,1]);
	//A.setSize(3,5).setFromArray([1,2,3,5,7, 2,4,4,1,1, 2,3,0,0,1]);
	//A.setSize(3,4).setFromArray([1,2,1,1, 1,2,2,-1, 2,4,0,6]);
	//A.setSize(3,4).setFromArray([2,1,-1,8, -3,-1,2,-11, -2,1,2,-3]);
	//console.log( Matrix.transpose(B).toString() );
	//console.log( C.toString() );
	//var s = 4/0;
	//A.randomize(100,true);
	//B.randomize(100,true);
	//C.randomize(100,true);
	//B = A.copy();
	//B = A.copySize();
	//Matrix.RREF(B,A);
	//Matrix.transpose(C,A);
	// A.setSize(3,3).setFromArray([1,3,3, 1,4,3, 1,3,4]);
	// B.setSize(3,3).identity();
	//A.setSize(3,3).setFromArray([1,3,3, 1,4,3, 1,3,4]);
	//A.setSize(2,2).setFromArray([3,3.5, 3.2,3.6]);
	//A.setSize(2,2).setFromArray([4,3, 3,2]);
	//A.setSize(2,2).setFromArray([1,2, 3,4]);
	//B = Matrix.inverse(A);
// A.setSize(3,2).setFromArray([1,2, 3,4, 5,6]);
// B.setSize(2,3).setFromArray([1,1, 2,3, 0,1]);
// A.setSize(3,3).setFromArray([6,3,0, 2,5,1, 9,8,6]);
// B.setSize(3,2).setFromArray([7,4, 6,7, 5,0]);
// A.setSize(2,3).setFromArray([1,2,3, 4,5,6]);
// B.setSize(3,2).setFromArray([7,8, 9,10, 11,12]);
// A.setSize(???).setFromArray([1,2, 3,5, 6,7]);
// Matrix.mult(C,A,B);
//C = Matrix.mult(A,B);
var pointList = [new V2D(3,3), new V2D(4,5), new V2D(7,7), new V2D(1,3), new V2D(3,2)];
	b.setSize(pointList.length,1);
	A.setSize(pointList.length,2);
	for(i=0;i<pointList.length;++i){
		b.set(i,0, pointList[i].y);
		A.set(i,0, pointList[i].x); A.set(i,1, 1.0);
	}
	
	console.log( A.toString() );
	console.log( " " );
	console.log( b.toString() );
	console.log( " " );
	Matrix.mult( x, Matrix.pseudoInverse(A), b);
	console.log( x.toString() );
	var pt = new V2D( x.get(0,0), x.get(1,0) );
	console.log( pt.toString() );
	/*
	hold off;
	plot([3,4,7,1,3],[3,5,7,3,2],"b*");
	hold on;
	x = [-4:1:10];
	m = 0.78125;
	b = 1.1875000000000007;
	y = m*x + b;
	plot(x,y,"r-");

	*/
/*
HOMOGRAPHY = H = K * R * K^-1

projecting image A to B:
pA[i] = H^-1 * pB[i]

ORTHOPHOTO




NONLINEAR LEAST SQUARES: y = f(x)

JACOBIAN: J = dy/dx = [dfi/dxi] = 
[ df1/dx1 df1/dx2 ... df1/dxm ]
[   ...     ...         ...   ]
[ dfn/dx1 dfn/dx2 ... dfn/dxm ]

y0 = observations (truth)
x0 = initial guess for x
y = f(x) 


f(x) := given
y0 := given
x := x0
until dx is minimal (convergence):
	y = f(x)
	dy = y - y0
	J := [dfi/dxi]
	dy = J dx
	dx = pseudo(J)*dy
	x = x + dx

end





*/
/*
	//monty hall
	var i, theDoor, theGuess, removed, index, success, count;
	var array = new Array();
	count = 100000;
	for(i=0,success=0;i<count;++i){
		array = [0,1,2]; // all doors: 0, 1, 2
		theDoor = Math.round(Math.random()*3-0.5); // place prize behind a random door
		theGuess = Math.round(Math.random()*3-0.5); // choose a random door
		array.splice(theGuess,1);
		removed = array[Math.round(Math.random()*2-0.5)]; // remove one of the non-guessed doors
		if(removed==theDoor){ // can't remove the prize door
			removed = array[(index+1)%2];
		}
		// stay with original guess, don't switch
		if(theDoor==theGuess){ ++success; }
	}
	console.log("no switch success rate: " + (success/count));
	for(i=0,success=0;i<count;++i){
		array = [0,1,2]; // all doors: 0, 1, 2
		theDoor = Math.round(Math.random()*3-0.5); // place prize behind a random door
		theGuess = Math.round(Math.random()*3-0.5); // choose a random door
		array.splice(theGuess,1);
		index = Math.round(Math.random()*2-0.5);
		removed = array[index]; // remove one of the non-guessed doors
		if(removed==theDoor){ // can't remove the prize door
			removed = array[(index+1)%2];
		}
		// change guess to be opposite door
		if(removed==0){
			if(theGuess==1){
				theGuess = 2;
			}else{
				theGuess = 1;
			}
		}else if(removed==1){
			if(theGuess==0){
				theGuess = 2;
			}else{
				theGuess = 0;
			}
		}else if(removed==2){
			if(theGuess==0){
				theGuess = 1;
			}else{
				theGuess = 0;
			}
		}
		if(theDoor==theGuess){ ++success; }
	}
	console.log("switch success rate: " + (success/count));
	return;
*/
}
</script>
</head>
<body onload="pageLoadedFxn();" style="">
</body>
</html>

